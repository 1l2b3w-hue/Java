# Java基础

## java概述

​	程序 ：计算机完成某个操作或解决某个问题而编写的一段有序的指令集合

1995年，sun公司发布第一个版本的java ; Java 之父是**詹姆斯・高斯林（James Gosling）**

​	技术体系平台 ：
​		Java SE ：标准版

​		Java EE ： 企业版 SE的扩展 

​		Java ME ：小型版

### 	特点  

​		面向对象

​		健壮性（强类型机制、异常处理，垃圾自动回收....）

​		跨平台性 ： 编译好的文件可以在多个系统上运行(JVM来帮助解释执行)

​		解释性语言 ：经过编译后产生的文件，还需要解释器才能执行 （HTML、JavaScript、Java）

​			编译性语言 ：C 、C++

### 	JVM

​		Java虚拟机，一个虚拟计算机，包含在JDK中。

### 	JDK

​		Java开发工具包，包含JRE 和Java开发工具（javac 、java ....）

### 	JRE 

​		Java运行环境，包含JVM和Java核心类库,如果只是使用一个开发好的java程序，只需要JRE

### 环境变量path配置及其作用

​	为了在dos的任意目录下都能使用java和javac命令

​	1.在环境变量中增加一个JAVA_HOME,值为JDK安装的主目录

​	2.然后在path变量中新增一个%JAVA_HOME%\bin

### 	Java运行机制 

​		先编写java文件（源文件） ，通过javac  xxx.java来编译生成一个.class文件（字节码文件）, 再通过java xxx(不要带后缀名！！)来解释  

​		编译 ： 通过编译工具（javac.exe）生成能够被JVM识别的字节码文件(即.class文件),（有错误则报错，无错直接生成字节码文件）

​		运行 ： 通过运行工具（java.exe）将字节码文件装载到JVM机执行

​		需要注意的是

​			当编写的代码中存在中文，即便是注释里面的，应该将文件安装GBK的编码形式来重新保存，否则终端不认可（默认GBK）

​			新保存的java文件，应该重新编译形成新的class文件来保持执行的是新的java文件

### 	Java开发注意事项 

​		Java源文件以 ".java"为扩展名，其基本组成部分为类

​		Java应用程序执行的程序入口是main()方法，有固定格式 : public static void main(String[] args) { ... };

​		Java 严格区分大小写

​		Java方法的有语句组成，每条语句必须要有 ； 结尾

​		Java中每个{}都是成对出现，缺一不可

​		源文件中有且只有一个Public类，其他类个数不限制 ，对于源文件中出现的所有类，会生成相对应的class文件；可以将main方法写在非public类中，再调用运行非public类时，入口方法就是非public类的main方法

​		如果一个源文件中有一个public类，则文件名必须要与public类名一致

![image-20250914213135712](C:\Users\Administrator\AppData\Roaming\Typora\typora-user-images\image-20250914213135712.png)

​	

### 	转义字符

​		\t  : 一个制表符  \n :换行   \\"  一个双引号      \\' : 一个单引号      \r : 一个回车（并不是换行，而是计算机在读取该字符时，光标转到该行最前，然后进行读取覆盖）

### 	易犯错误 ：（语法错误）

​		找不到文件 ： 文件不存在或写错，路径错误

​		公共类名与文件夹名不一致

​		缺少分号

​		最难的是 ： 业务错误（逻辑上错了），环境错误

### 	注释 

​		单行注释 ： //

​		多行注释 ： /* .... */	不允许嵌套

​		被注释的内容不会被JVM识别和执行	

​		文档注释 ： javadoc -d 文件夹位置 -xx -yy... xxxx.java

### 	Java规范 

​		类和方法的注释采用 javadoc的方式来写

​		对于单行多行注释，是用来解释为什么这么写，怎么改，有什么影响

​		tab ： 整体左移，shift + tab ：整体右移

​		源文件应该采用utf-8

​		运算符、= 左右各空一格

​		单行不超80字符

​		代码编写行尾风格和次尾风格

## DOS 

​	磁盘操作系统

​	Dos系统 ： 接受指令（获取到一个指令），解析指令（分析要做什么），执行指令（在系统上执行这条指令）

​	相对路径 ：从当前目录开始定位，从而形成的路径

​	绝对路径 ：从根目录开始定位形成的路径

### 	常见Dos命令 

​		查看当前目录内容 ： dir

​		切换 ：cd   (切C盘 ： cd /D c:    上一级目录 ： cd  ..   切换跟目录 ： cd /)

​		查看下级的所有文件夹 ： tree 

​		清屏 ： cls

​		退出 ：ｅｘｉｔ

​		创建目录  ：md

​		删除目录  ：rd

​		复制文件 ： copy 

​		移动文件 ：remove

​		删除文件 ： del  ....

## 变量

​	变量是程序的基本组成部分

​	三要数 ： 类型 名称 变量值

​	变量是一块内存的数据存储空间的表示，通过变量名可以访问到变量值

​	不同变量类型不同，不同类型占用空间也不同，int ： 4字节  char ： 1字节  double ： 8字节  float ： 4字节

​	必须先声明，后使用 

​	一个变量的存储区域，该区域由自己的名称和类型 ，其存放的数据可以在同一类型范围内变化

​	在同作用域中，变量名不能重名

### 	\+ 的使用

​		当\+ 的旁边是数值类型时，做加法运算； 如果是一方有一个字符串，做拼串操作（运算从左到右）

### 	数据类型

#### 		基本数据类型 

​			数值  

​				整型 ： byte（字节 ，1）  ： -128 ~127

​					short （2） ： -(2^15) ~ 2^15-1  -32768 ~ 32767

​					int （4） ： -(2^31) ~ 2^31  - 1 

​					long （8） ： -(2^63) ~ 2^63  -  1 

​					整型的长度是固定的，与操作系统无关

​					Java整型常量默认为int类型声明long类型时，必须在常量后加 l 或L

​					整型变量一般使用int来存放，除非太大超出了，可以用long

​					当将一个具体的数值赋值给一个byte时，会先进行判断，这个数值是否在byte范围，是就赋值

​					bit（比特） ：计算机中最小存储单元 ，byte计算机的基本存储单元，1byte = 8 bit

​				浮点型  ： float （4）、double（8）

​					存放形式 ： 符号位 + 指数位 +尾数位 尾数位存在可能丢失的情况，从而造成精度丢失，小数都是近视值

​					长度是固定的，与操作系统无关

​					Java浮点型常量默认为double（double类型可以带 ：d后缀   即8d 表示一个double类型的8），因此声明float常量时，要加 f 或 F

​					小数表现形式 ： 

​						十进制 ： .123  等价于0.12

​						科学计数法 ： 2.12e3 (2.12 * 10^3)  2.21E-2(2.21*10^-2)

​					通常情况下，应该使用double类型，double类型精度高于float

​					当我们对运算结果是小数的进行比较时，应该注意小数可能是近似的（即计算机无法表示该小数），可能理论上相等，但实际上计算机不可能相等应该通过两个值的差的绝对值，在某个精度上来判断是否相等，小就等于；当然直接查询到的或者直接赋值的自然可以比较

​			字符类型  ： char(2)。存放单个字符,可以存放数字

​					必须使用单引号引起（双引号为字符串）

​					运行转义字符

​					在Java中，char本质是一个整数，输出是按照unicode编码输出，因此char可以是整数

​					char可以进行运算，本质是一个整数

​				字符型本质 ：
​					字符型数据存放到计算机时，需要先找出对应的码值，再将码值存放到计算机中

​					字符与码值的对应关系是通过字符编码表决定的

​			字符编码表 ： （不同的编码会对文件大小产生影响）

​				ASCII ： 一个字节 ，128个字符，虽然一个字节可以表示256个字符，但这里只使用了128个字符（因为最前面的比特位默认为0）

​					缺点 ： 不能表现所有字符

​				Unicode ： 两个固定字节（2^16），表示字母和汉字，易浪费空间（缺点），兼容ASCII

​				utf-8 ： 大小可变的编码方式，1-6 个字节来表示一个字符；  字母使用一个字节，汉字使用三个字节,使用最广

​				gbk ： 可以表示汉字，范围更加广泛 ，字母一个字节，汉字两个字节

​				gb2312 ： 表汉字，但gb2312 < gbk

​				big5 码 ： 繁体中文

​			布尔类型 ：boolean（1），存放 ：true false（两个值，不能为空）

​					用于逻辑运算

​					java中，不能使用0和非0来代替boolean类型的真假

#### 		引用数据类型

​			类（class）(string 属于类)

​			接口 （interface）

​			数组 （[]）		

### 自动类型转换 

​	当Java进行赋值或运算时，精度小的类型会自动转换为精度大的类型

​	char - int - long -float - double

​	byte - short - int - long - float - double

​	 当多种类型数据进行运算时，会自动转换为数据类型容量最大再运算

​	当把精度大（容量大）的数据转换为精度小（容量小）会报错，反之自动转换

​	byte和short 不能与char发生类型转换

​	byte short 与 char 进行运算时，只要出现，就会首先转换为int类型

​	boolean不参与自动转换

​	自动提升原则 ： 表达式结果的类型将会自动提升为操作数中最大的类型

### 强制类型转换 

​	自动转换的逆过程，使用强制转换符 ： （类型） ，可能会造成精度损失或溢出，因此要明确知道会这样，才去转

​	数据从大 --> 小，使用强制转换

​	强转符号只会针对最近的操作数有效，对于整个表达式来讲，需要（）提升优先级

​	char类型可以保存int常量值，但是无法保存变量值，需强转

### 基本数据类型与String类型相互转换

​	基本 ——> String :  + " "拼串

​	String ——> 基本：  使用基本数据类型对应的包装类的相应方法来实现转换

​	int :  Integer.parseInt() ;  short : Short,parseShort();  byte : Byte.parseByte() ; long : Long.parseLong()

​	boolean : Boolean.parseBoolean()(针对于"true","false"); 

​	float : Float.parseFloat(); double : Double.parseDouble 

​	字符串 转 字符 ： 通常将字符串的第一个字符拿出来存放

​			字符串.charAt(索引) ： 返回一个字符串的索引上的字符

​	但将String转换为基本类型数据时，应该保证String可转换为一个有效数据，如果不能转换成一个有效数据，会抛出错误，程序终止

## 运算符	 

​	一种特殊的符号，用于表示数据的运算，赋值和比较

### 算数运算符 

​		![image-20250916112219331](C:\Users\Administrator\AppData\Roaming\Typora\typora-user-images\image-20250916112219331.png)

​	% 的本质为 ： a % b == a - a / b * b;

​		a % b 时，a 是小数时， 本质为 a - （int）a / b * b

​	++ 使用 ： (底层存在一共强制类型转换)
 		作为独立语句使用  前后 ++ 完全等价于 +1

​		作为表达式使用  见上表 

​			前加本质 ： 会创建一个临时变量temp = i；然后执行 i = i + 1,最后执行 i = temp （i = i++）

​			后加本质 ： 创建一个临时变量temp，先执行i = i + 1; 在执行 temp = i，最后就是 i =temp

### 关系运算符（比较运算符） 

​	结果只会是true和false

​	关系运算符构成的表达式为关系表达式

​	![image-20250916134449168](C:\Users\Administrator\AppData\Roaming\Typora\typora-user-images\image-20250916134449168.png)



### 逻辑运算符 

​	用于链接多个条件（多个关系表达式），最终结果还是boolean

​	![image-20250916135829191](C:\Users\Administrator\AppData\Roaming\Typora\typora-user-images\image-20250916135829191.png)

​	与 ： 就是有假为假，全真为真 ； 或  ： 全假为假，有真为真

​	取反：真就是假，假就是真 ；异或 ： 相同为假，不同才真

​	短路与 && （常用） 和 逻辑与 &

​	对于&&，第一个条件为false，后面的条件不会被执行和判断； 而&无论如何将会全部执行判断真假 

​	短路或 ||（常用）  和 逻辑或 |

​	对于||，第一个条件为true，后面的条件不会被执行和判断； 而 | 无论如何将会全部执行判断真假 

### 赋值运算符 

​	将运算后的值赋值给指定变量

​	基本 ： =   ； 复合 ： +=， -=， *= ， /= ,%= 。(a +=b == a = a + b ....)

​	特点 ： 	

​		运算顺序为从右向左

​		左边只能是变量，右边可以说常量，变量，表达式

​		复合赋值运算会自动进行类型转换  a += b 等价于  a = (a的类型)(a + b)

### 三元运算符 

​	条件表达式 ： 表达式1 ？ 表达式2

​	条件表达式为真，执行表达式1；为假，执行表达式2

​	表达式 1，2 应该是可以赋值给接受变量的类型（或者可以自动转转换）(不匹配或无法自转，要求强转)

​	三元表达式可以转换为if-else语句

### 运算符优先级 

​	**![image-20250916171531072](C:\Users\Administrator\AppData\Roaming\Typora\typora-user-images\image-20250916171531072.png)

​	整体上可以通过（）来转换成你想要的运算顺序

​	单目运算（单个操作数），赋值运算符 ： 从右向左，其余从左向右

### 标识符规则和规范

​	标识符 ：对各种变量，方法和类命名的字符就是标识符（就自己命名的东西）

​	规则 ：

​		26个字母（大小写），数字，_，$组成

​		不能以数字开头

​		不能使用关键字和保留字 ，但能包含关键字和保留字（就是含有） 

​		严格大小写，长度无限制

​		标识符中，不能包含空格

​	规范 ：（更加专业）

​		包名 ：多个单词组成时，采用小写字母  . 隔开

​		类名 ：多单词构成时，首字母大写（大驼峰法）

​		变量名，方法名 ： 多单词构成，首单词小写后续单词首字母大写（小驼峰法，简称驼峰法）

​		常量 ： 字母大写，多单词下划线隔开

​	关键字 ： 被Java语言赋予了特殊的含义，用做专门用途的字符串（全是小写）

​	保留字 ： 现有版本尚未使用，但后续版本可能作为关键字使用

### 键盘输入 

​	接受用户输入数据

​	需要一个扫描器对象 ：Scanner

​	步骤 ：
​		导入该类的所在包 ： java.util.   导入形式 ： import java.包名.类名 （import java.util.Scanner）

​		创建该类对象（声明变量） ： new创建一个实例对象 new Scanner(System.in)  : System.in 接受键盘输入 

​		调用内部功能 ： next() : 字符串，nextInt() : 整形   nextDouble() ： double类型 .... ； char : next().charAt(0)

​		当执行到next方法时，程序会一直等待用户输入的信息

### 进制 

​	对于一个整数，有四种表现形式

​	二进制 0，1  0b 或0B开头

​	十进制 0~9

​	八进制 0~7  0开头

​	十六进制 0~9A~F（不分大小写）   0x 或0X 开头

### 原码、反码、补码 

​	有符号数：

​	最高位为符号位，0正1负

​	正数原反补一致

​	负数反码 = 原码符号位不变，其他位取反， 补码 = 反码 + 1；0的反码补码都是0；

​	Java中没有无符号位，即java中的数都是有符号数

​	计算机运算时，**以补码形式来进行运算**，但是运算结果是以原码出现

### 位移运算符  

​	& ：按位与  ：全1为1， 其余为0

​	| ：按位或  ： 全0 为0， 其余为 1

​	^  ： 按位异或  ： 相同为0，相异为1 

​		了解两个公式 ： a ^ 0 = a ; b ^ b = 0;两个实现数据交换

​	~ ：按位取反  ： 1是0 ， 0 是1

​	>> ：算数右移 ，低位溢出，高位补符号位 本质就是除以几个2

​	<< ： 算数左移，符号位不变，低位补0   本质就是乘几个2

​	>>> ： 逻辑右移， 低位溢出，高位补0  

​	注意 ： 没有逻辑左移

## 程序控制结构

### 	顺序控制

​		程序从上到下一步一步执行，中间没有任何判断和跳转

​		定义变量时，使用**前向引用**（先定义后引用）

### 	分支控制

​		让程序有选择的执行

#### 	if - else 分支

##### 		单分支

​			if(条件表达式) { 执行代码块 }（当执行代码块中只有一个语句，可以不用{}，但建议写上）
​			当条件表达式为真，执行{}中的执行代码块，为假，则不执行{}内的执行代码块

​			流程图（程序执行流程）

​			![image-20250917120345804](C:\Users\Administrator\AppData\Roaming\Typora\typora-user-images\image-20250917120345804.png)

##### 		双分支

​			if(条件表达式1) { 代码块1}

​			else{代码块2}

​			条件表达式1 为真，执行代码块1，为假执行代码块2；

​			流程图 ：

​				![image-20250917121834009](C:\Users\Administrator\Desktop\JavaSE\image\image-20250917121834009.png)

##### 		多分支

​			if(条件表达式1) {代码块1}

​			else if(条件表达式2) {代码块2}

​			....

​			else {代码块n}

​			条件表达式1 为真，执行代码块1，为假判断条件表达式2；真执行代码块2，假继续判断....知道全部为假，执行代码块n

​			流程图 ：
​	![image-20250917143038219](C:\Users\Administrator\AppData\Roaming\Typora\typora-user-images\image-20250917143038219.png)

​			整体上最多只允许有一个执行入口，可以没有执行入口（即没有else，且条件表达式都不成立）

##### 		嵌套分支

​			在一个分支结构中，嵌套一个完整的分支结构，里面分支为内层分支，外面的分支为外层分支；

​			规范 ： 不建议超过三层，可读性不好

#### 	switch分支	

```
switch(表达式) { java中，只要有值可以返回，就是一个表达式
	case 常量1 ： 代码块1
		break;
	case 常量2 ： 代码块2
		break;
	case 常量3 ： 代码块3
		break;
		....
	default :  代码块n
		break;
} 
```

​		switch是一个关键字，表示switch分支

​		表达式对应一个具体的值

​		case 常量1 表示 ： 当表达式的值等于常量1，则执行语句块1，然后break退出switch

​		和case 常量1匹配，执行语句块1，不匹配就开始匹配case 常量2 ......

​		如果一个都没有匹配，执行default中的代码块

​		流程图 ：

​	![image-20250917162009117](C:\Users\Administrator\AppData\Roaming\Typora\typora-user-images\image-20250917162009117.png)



​		注意事项 ：

​			表达式的数据类型应该和case常量的数据类型一致，或者可以自动转换为可以相互比较的类型

​			表达式返回的数据类型只能是 ： byte，short ，int，enum（枚举）， char ，String

​			case 子句中的值必须是常量或者是常量表达式，不能是变量

​			default 是可选的，没有default，且没有匹配到任何case子句，将会啥也不干

​			break用来在执行完一个case子句的代码块，跳出switch，如果没有break，会按照顺序执行下面的case子句代码，知道下面的全部执行或遇到break

​	switch 和 if

​		如果判断的数据类型不多，且符合 byte，short ，int，enum（枚举）， char ，String，建议使用switch

​		对区间判断，对结果为boolean类型判断时，使用if分支更加合适

​	

### 	循环控制

#### 	for循环

​		for(循环变量初始化 ； 循环条件 ； 循环变量迭代) { 循环操作 }

​		for ：关键字，表示循环控制

​		四要素 ：循环变量初始化 循环条件 循环操作 循环变量迭代

​		循环操作 ：可多条语句，单语句（{} 可省，但不要省）

![image-20250918093238824](C:\Users\Administrator\AppData\Roaming\Typora\typora-user-images\image-20250918093238824.png)

​		循环条件是一个返回布尔值类型的表达式

​		for循环中的初始化循环变量和循环变量迭代可以写在别的地方，但分号不能省略 (for(;;) 表示一个死循环)

​		循环变量的初始化可以有多条语句，但要类型相同；循环变量的迭代可以有多条语句；多条语句都由逗号隔开

#### 	while循环 

​		循环变量初始化；while（循环条件） { 循环操作 ； 循环变量迭代 }

​		四要素，位置不同

​		![image-20250918105419843](C:\Users\Administrator\AppData\Roaming\Typora\typora-user-images\image-20250918105419843.png)

​		循环条件还是一个返回布尔类型的表达式，先判断，后执行

#### 	do-while循环

​		循环变量初始化； do { 循环操作；循环变量迭代； }while（循环条件）；

​		先执行，再判断，一定会执行一次； **最后一定要有一个 ；号**

![image-20250918122150930](C:\Users\Administrator\AppData\Roaming\Typora\typora-user-images\image-20250918122150930.png)

#### 	多重循环

​		当一个循环中有另一个循环，将会构成循环嵌套，一般建议两层循环，最多不要超过三层

​		循环嵌套是将内层循环作为外层循环的循环体，只有内层循环结束后才会结束外层的一次循环

​		当外层循环要执行m次，内层循环执行n次，则内层循环体将会执行m * n 次

## 编程思想 

​	化繁为简

​		将复杂需求拆解为简单需求，逐步完成

​	先死后活

​		先考虑固定值，然后转成可以灵活变化的值

### 跳转控制语句

#### 	break

​	用于终止某个语句块的执行，常用于switch和循环

​	![image-20250918183620275](C:\Users\Administrator\AppData\Roaming\Typora\typora-user-images\image-20250918183620275.png) 

​	break 语句出现在多层嵌套的语句块中，可以通过标签指明要结束哪一层语句块

#### 	标签语法 

```
label1(只是一个标识符) ： {
	label2 ： {
		label3 ： {
			break label2;//结束 label2 的语句块
		}
	}
}
```

​		break 语句可以指定退出哪一层

​		label 是标签，名字由程序员确定

​		break后指定到哪个标签，就退出到哪里

​		并不推荐使用标签

​		break没有指定时，默认跳出最近的循环体

#### 	continue 

​		结束本次循环，继续执行下一行循环，也可以根据标签跳过指定循环

#### 	return

​		使用在方法中，表示跳出该方法；return写入main方法时，执行将会结束程序

## 数组、排序、查找

### 数组 

​	存放多个同一类型的数据；是一个引用类型的数据类型；数组就是一组数据

#### 	定义 

#### 		动态分配方式

​			数据类型[]   数组名([] 可以写在数组名后) = new 数据类型[元素个数]；

​			先声明：数据类型[] 数组名  或 数据类型 数组名[] （此时为空） ，再创建 ： 数组名 = new 数据类型[元素个数]

#### 		静态初始化 

​			数组类型[] 数组名 = {元素1，元素2....}  (知道由多少个数据使用静态方式)

​			等价于 ： 数组类型[] 数组名 = new 数据类型[个数]， 数组名[0] = 元素1....

​	数据类型[] 数组名 = new  数据类型[] { .... } 可以创建一个数组，但应该注意的是 ： new 数据类型[] 中的[] 不能填写数字，而是由计算机去读取后面的元素来确定数组长度

#### 	引用/使用 

​		数组名[下标/索引]

​		数组下标从0开始 

​	注意 ：

​		数组是多个相同数据类型的组合，用于实现对这些数据的同一管理

​		数组中的元素可以是任何数据类型，基本类型和引用类型都可以

​		数组被创建后，如果没有赋值，将会赋值默认值 ： 

​			//  int byte short long : 0; float double : 0.0 boolean : false String: null char :\u0000(0字符，u表示十六进制)

​		使用数组 ： 声明开辟数组，赋值，使用

​		下标从0开始

​		数组下标必须在指定范围内去使用，否则数组下标越界异常，编译可以通过，但是执行将会抛出异常

​		数组属于引用类型数据，数组型数据是对象（数组本事就是一个对象）

#### 	数组赋值机制 

​		基本数据类型赋值 ,赋值方式是值拷贝 ： 一个变量的变化不会影响到其他与其关联的变量

​		数组赋值，默认情况下是引用传递/地址拷贝，赋值方式是引用赋值，赋值的是地址

## 	值传递和引用传递的区别

​		前提 ： 在JVM中，内存分为三个部分 ： 栈 、 堆 、 方法区

​		对于基本数据类型，会直接存放在栈区中（变量名和变量存放的数据）

​		而对于数组来讲，数组名将会存放在栈区中，而具体存放内容将会放在堆区中，栈中的数组名将会存放一个地址，指向了存放在堆区中的数据

![image-20250919155917303](C:\Users\Administrator\AppData\Roaming\Typora\typora-user-images\image-20250919155917303.png)

​	当基本数据类型进行值传递时，会将一个变量存放的数据拷贝一份放入另一个变量，两个变量存放的数据并无关系，只是一样，

​	当数组进行引用传递时，会将一个数组名存放的地址拷贝一份放入另一个数组名，但是由于地址一样，导致新数组名可以根据地址信息找到存放在堆区的数据内容，此时发生更改将会影响其他指向该数据内容的数组。

#### 	数组的拷贝

​		要求数据空间相互独立

​		创建一个新的数组，使其大小一致，再遍历赋值，创建出两个相互独立的数组

#### 	数组的扩容

​		定义一个新的数组，使其长度为原数组长度 +1，依次将原数组元素赋值给新数组，并为新数组赋值一个新元素，使用引用拷贝替换原数组内容

## 	排序 

​		将多个数据，按照指定顺序进行排序的过程

### 		内部排序

​			将所有的数据全部加入内存进行排序

### 		外部排序

​			数据量过大，无法全部加载到内存中，需要借助外存来进行排序 

### 		冒泡排序 

​			通过对待排序序列从后向前，依次比较相邻元素的值，发现逆序就交换，使值较大的元素逐渐从前移向后部

​			注意点 ：

​				比较时应该注意是否越界，对于已经排列到最后的最大数时，不需要再比较（内层循环的条件应该小于数组长度　－　１　－　ｉ）；

​				拍到最后就剩一个数时，也不需要再排序（ｎ个数只需要ｎ－１次外层循环）

## 	查找

​		顺序查找　：遍历一边查找

​		二分查找 ：针对于一组有序数组，先查中间，看大小关系，大后找，小前找

## 	二维数组 

​		一个数组的元素又是一个数组，则这个数组称为二位数组

​		二位数组的元素个数 ： 数组名.length

​		如果需要得到二位数组中一位数组的元素，需要再遍历一个二位数组的元素

​		访问第i个一维数组的第j个元素 ： 数组名\[i -1][j - 1];

​		动态初始化 ：
​			类型\[][]  数组名 = new 类型\[][] (第一个[] 表示有几个一维数组，第二个[]表示一个一维数组有几个元素)

​			类型\[][] 数组名 ； 数组名 = new \[][]; 先声明，再创建

​			列数不确定，java中允许一维数组的个数不确定 ： 

​				先开辟出二维数组个数（int\[][] arr = new int\[3][]; 确定了二位数组空间，但是一位并没有赋空间），后面根据情况开辟一维数组元素个数(arr[i] = new int[i + 1];)

​		静态初始化 ：int\[][] arr = new int\[][] ;  int\[][] arr =  {{},{},{}}

​		声明 ：类型\[][]  数组名 ；类型  数组名\[][] ； 类型[] 数组名[]

​		内存存放方式 ：
​			![image-20250920151206463](C:\Users\Administrator\AppData\Roaming\Typora\typora-user-images\image-20250920151206463.png)



## 面向对象

引入 ： 

​	以前知识（单独变量，数组）存在不利于数据管理和效率低

​	java设计者引入类与对象(OOP),就是为了解决现有技术无法完美的解决现有需求（不利于管理和效率低）

一个程序就是一个世界，有很多的事物（可以通过对象来表示）(对象[属性，行为])

### 类与对象的关系 

​	类 ： 就是一个由程序员创建的数据类型，（将一种事物的属性和行为提前出来形成一个类）

​	对象 ： 可以通过一个类，创建一个具体的事物（具体的实例对象）

​	从类到一个对象 可以称为 ： 创建一个对象；实例化一个对象；把类实例化

​	类是抽象的，概念的，代表一类事物 （是一个数据类型）

​	对象是具体的，实际的，代表一个具体的事物 （是一个实例）

​	类是对象的模板，对象是类的一个个体，对应一个实例

### 对象内存布局 

​	![image-20250921103246637](C:\Users\Administrator\AppData\Roaming\Typora\typora-user-images\image-20250921103246637.png)

​	对于属性的存放 ： 如果是基本数据类型，将会存放到堆区，而String将会放入方法区的常量池（存放常量）中 

​	在创建一个对象时，会先在方法区中加载类的信息，在堆中开辟一块区域存放类的属性（默认值）

​	cat只是指向一个对象，称为对象引用或对象名，真正的对象是 ： new Cat（）

### 属性/成员变量

​	属性 = 成员变量 = field(字段)

​	属性是一个类的基本组成部分，可以是基本类型，也可以是引用类型

### 注意事项 

​	属性的定义语法 ： 访问修饰符  属性类型 属性名

​		访问修饰符 ：控制属性的访问范围； 四种 ： public , protected , 默认 , private

​	属性类型可以是基本类型，也可以是引用类型；

​	属性未被赋值时，取默认值，与数组规则一致

### 对象的创建 

​	先声明 ： 类  对象名 ； 对象名 =  new 类() 再创建对象

​	直接创建 ： 类 对象名 = new 类()；

### 访问对象属性

​	对象名.属性名

### 对象创建流程 

​	先加载相关类信息（属性和方法），只会加载一次；

​	在堆中分配空间，大小由类的属性个数决定，为属性赋默认值

​	将堆中对象的地址赋值给对象名

​	进行指定初始化

### 成员方法/方法

​	Java中，通过方法来描述一个具体事物的行为

	//方法的使用：
	// 方法写好后，不去调用（也称为使用），将会无法执行
	// 先创建一个对象，再调用方法
	Person p1 = new Person();
	p1.speak();//调用方法
	p1.cal02(5); //调用cal02方法，传递一个参数5，让n = 5
	// 调用getSum方法，传递两个参数，使num1 = 20, num2 = 10;
	// 并将返回值赋值给returnRes
	int returnRes = p1.getSum(20,10);


​	
​	// public 表示这个方法是公开的
​	// void 表示该方法没有返回值
​	// speak() : 表示该方法名称为speak，() : 形参列表，这里显示没有形参
​	// {} ： 方法体，里面放要执行的代码
​	public void speak() {}
​	// (int n) : 表示当前一个形参n，接受用户输入
​	public void cal02(int n) {}
​	
​	// int : 表示该方法执行后，会返回一个int类型的数据
​	// return result 表示将result的值返回
​	public int getSum(int num1, int num2) {
​	return result;}

### 方法调用机制 

![image-20250921144332910](C:\Users\Administrator\AppData\Roaming\Typora\typora-user-images\image-20250921144332910.png)

​	方法执行完毕或执行到return时就退出栈空间

方法的好处 

​	提高代码的复用性

​	可以将实现细节封装起来，其他用户调用即可

### 成员方法的定义 

​	访问修饰符 数据类型 方法名(形参列表) {语句块（方法主体）； return 返回值}；

​		形参列表 ：表示成员方法接受的值（形参）

​		数据类型 ： 表示成员方法返回的数据类型，void表示无返回值

​		语句块 ： 实现某一功能

​		return语句不是必须的

​	思路 ： 

​		确定方法返回类型

​		确定方法名

​		确定方法形参（个数和类型）

​		确定方法体

### 方法注意事项和细节

​	 访问修饰符 ： 控制方法的使用范围， 四种 ： public , protected , 默认 , private

​	返回数据类型 ：

​		一个方法最多只能有一个返回值，当需要返回多值时，采用返回数组的形式返回（将返回值存放在数组）

​		返回值的类型可以是任意类型（基本和引用都行）

​		如果方法要求有返回数据类型，则方法最后执行的语句为 return 值（值可以是一个数据或着一个表达式），并且要求返回值的数据类型必须与return返回的数据类型一致或兼容

​		如果返回类型为void，可以不用写return 或者直接写return（不能再写表达式或值）

​	方法名 ：采用驼峰命名法，见名知意

​	形参列表 ：一个方法可以有0个形参或多个形参（逗号隔开）；可以是任意类型，

​		调用含形参方法时，一定对应着参数列表传入相同数据类型或类型兼容的参数

​		方法定义时，参数被称为形式参数（形参），方法调用时，参数被称为实际参数（实参），形参实参的类型，个数，顺序要求一致

​	方法体 ： 不能再定义方法（不能嵌套定义方法）

### 方法调用注意事项

​	同一类中的方法调用时 ，直接可以进行调用

​	跨类的方法调用时，通过创建对象实例，使用对象名来进行调用。对象名.方法名()

​	跨类方法的调用和方法的访问修饰符有关

Math.random() ：随机生成一个0~1之间的double类型的数据

字符串比较方法 ：

​	equals()  ：String类中的方法，参数为想要比较的字符串，相等为true，不等为false

		System.out.println(name.equals("张三"));
		System.out.println("张三".equals(name)); //推荐，避免空指针 

### 方法传参机制

​	基本数据类型传参机制	

​		对于基本数据类型，传递的是值（值拷贝），形参的变化并不会影响到实参的变化

​	引用类型传参机制 

​		引用类型数据传递的是地址（值是地址），因此对形参指向的内容进行修改时，会影响实参中的数据，如果对形参进行执行修改，将不会影响到实参的数据

### 方法递归调用

​	方法自己调用自己，每次调用时传入不同的参数；用于解决复杂问题，并使代码比较简洁

​	规则 ：

​		每调用一次方法，会在栈中创建一个新的受保护的独立空间

​		方法的局部变量是独立的，不会相互影响

​		如果传递的参数是引用类型，将会共享该类型中的数据（都是指向堆区的同一个位置）

​		递归必须向退出递归的条件移动，否则将会出现无限递归，栈溢出（StackOverflowError）

​		当一个方法执行完毕或者遇到return，就会返回，遵循谁调用，返回给谁的原则，并且这个方法就执行完毕

### 方法重载（Overload）

​	java中允许同一个类中，多个同名方法存在，但是要求形参列表不一致

​	好处 ： 减轻了起名和记名的麻烦

​	注意事项 ：

​		方法名一定一样

​		方法的形参列表必须不同（类型，个数和顺序）

​		方法返回类型没有要求。（即如果两个方法名，形参列表一致，虽然返回类型不一样，但还是不构成方法重载，为方法重定义）

​		方法重载时，优先找匹配的形参列表，再找可以自动转换的，实在找不到报错

### 可变参数

​	Java中，允许将同一个类中的多个同名同功能但参数个数不同的方法封装成一个方法

​	基本语法 ：访问修饰符  返回类型 方法名（数据类型... 形参）

​	注意事项：

​		可变参数的实参可以是0~n个

​		可变参数的实参可以是一个数组

​		可变参数的本质就是一个数组

​		可变参数与普通类型的参数放在一个形参列表中，必须要保证可变参数是在最后面

​		一个形参列表中只允许出现一个可变参数

作用域

​	Java中，主要的变量为属性（成员变量）和局部变量

​	局部变量一般指定义在成员方法内的变量（定义在代码块的变量也是局部变量）

​	作用域分类 ：

​		全局变量 ：作用域为整个类

​		局部变量 ：除了属性变量之外的变量，作用域为所在的代码块中

​	全局变量可以不赋值直接使用（会赋默认值），局部变量必须赋值后才能使用，因为不会赋默认值

​	注意事项 ：
​		属性和局部变量可以重名，访问时遵循就近原则

​		同一个作用域中，不允许同名变量的出现

​		属性的生命周期较长，伴随着对象的创建而创建，伴随对象的销毁而销毁，局部变量的生命周期较短，伴随代码块的执行而创建，伴随着代码块的结束而销毁	

​		全局变量可以在本类中使用，也可以在其他类中使用（通过对象调用:跨类创建对象，或者方法接受一个类创见的实例作为参数）； 局部变量只能在本类的对应方法中使用

​		全局变量可以增加修饰（public、protected、private...），局部变量不能增加

构造方法/构造器（constructor）

​	是类的一种特殊方法，完成对**新对象的初始化** （对象已经存在，但其中的属性值由构造器完成赋值）

​	特点 ： 方法名与类名保持一致；没有返回值；在创建对象时系统自动调用该类的**构造器完成为对象的属性赋值**

​	基本语法 ：

​		[修饰符] 方法名(形参列表) {方法体}

​		修饰符可以是默认的，也可以是 ： public protected private

​		构造方法没有返回值

​		构造方法名必须与类名一致

​		形参列表要求与方法一致

​		构造器的调用由系统完成（new的时候就完成了）

​	注意事项 ：
​		一个类里面可以由多个构造器，实现构造器的重载

​		构造器与类名一致；没有返回值；在创建对象时，系统自动调用该类的构造器

​		构造器是完成对象的初始化，并不是创建对象；

​		如果没有定义构造器时，系统会自动生成一个默认无参构造方法（就是默认构造方法）

​		 **javap**  ： 反编译查看(不要加class后缀) （class -> java）

​		一旦定义了构造器，将会覆盖默认的构造器，无法再使用默认构造器，如果还是想使用，可以再定义一个无参构造器（显式定义，相当于构造器重载）

对象的创建 ：
		1.加载类信息（只会加载一次）

​		2.在堆中开辟一块空间，存放对象的属性，并赋默认值

​		3.根据类中对属性的赋值进行赋值（显式赋值）

​		4.再根据构造器进行赋值初始化

​		5.将堆中的对象的地址赋值给指定变量

### this关键字

​	Java虚拟机会为每个对象分配一个this，这个this代表着当前的对象

​	this可以看作为一个对象的隐藏属性，其存放的内容为当前对象的地址值（指向这个对象）

​	this ： 哪个对象调用，就指向哪个对象

​	注意事项 ： 

​		this关键字可以用来访问本类的属性（准确定位属性）、方法、构造器

​		this用于区分当前类的属性和局部变量

​		访问成员方法 ： this.方法名（参数列表）

​		访问构造器 ： this(参数列表)  ： 只能在构造器中使用，来访问另一个构造器（参数列表使用实参，要匹配你想要的构造器的形参列表），必须放在构造器的第一条语句中

​		this不能在类的外部使用，只能在类定义的方法中使用

​		方法中如果没有同名变量，则加不加this都是指向对象的属性

注意问题 ：

​	在处理一个数组类型的数据时，应该考虑到数组长度为0（为空），或者数组指向了一个空的问题

​	匿名对象 ：没有名字的对象  即new 类() 后并不会返回给一个对象应用，只能使用一次

​	对于复用构造器时，应该从构造器少的开始

​	hashCode（） ： 返回一个对象的int类型数据，该数据是通过对象在内存中的地址换算而来的，可以将其看成一个地址，但他本身并不是一个地址值（因为在JVM虚拟机上执行的，获取地址没用）

### 包

​	作用 ：

​		区分相同名字的类

​		当类的数量过多时，可以很好的管理类

​		控制访问范围

​	基本语法 ：

​		package 包名

​		package ： 关键字，表示打包

​	包的本质就是创建不同的文件夹来保存类

​	命名规则 ：

​		只包含数字、字母、下划线_、小圆点. 。不能以数字开头，不能为关键字和保留字

​	命名规范 ：

​		小写字母 + 小圆点  ： com.公司名.项目名.业务模块名

​	常用包 ：

​		java.lang : 基本包，直接用，不需要引用

​		java.util : 系统提供的工具包

​		java.net  ： 网络包

​		java.awt  ：界面开发

​	引入包 ：

​		引入一个包就是为了使用一个包中的某些类

​		引用方式可以有 ：

​			import 包名.具体的类  （推荐这种形式，需要什么就导入什么就行）

​			import 包名.* : 将包名中的所有类全部引进来

​	注意细节 ：

​		package 是声明当前类所在的包，要放在类或文件的最前面，一个类最多允许一个包	

​		import 指令放在package后面，类定义之前，可以有多条import，没有顺序要求

### 访问修饰符

​	Java提供四种访问修饰符号，用于控制方法和属性（成员变量）的访问权限（范围）

​	公开级别 ：public ， 对外公开

​	受保护级别 ：protected ，对子类和同一个包中的类公开

​	默认级别：没有修饰符，向同一个包中的类公开

​	私有级别：private ，只有类本身可以访问，不对外公开

​	![image-20250926150907973](C:\Users\Administrator\AppData\Roaming\Typora\typora-user-images\image-20250926150907973.png)

​	使用注意事项 ：

​		访问修饰符可以修饰类中的属性、方法以及类

​		类只能由public和默认修饰，遵循访问限制

​		成员方法的

​	封装

​		封装（encapsulation）就是把抽象出的数据[属性]和对数据的操作[方法]封装在一起，数据被保护在内部，程序的其它部分只有通过被授权的操作【方法]，才能对数据进行操作。

​		把细节封装起来，直接调用（用户用遥控器操作电视）

​		好处 ：
​			隐藏实现细节（调用者只需知道这个有什么用，怎么用）

​			可以对数据进行验证，保证安全合理

​		实现 ：

​			将一个属性进行私有化设置（private）

​			提供一个public的set方法，用来对属性判断并进行复制

​			提供一个public的get方法，用来获取这一个私有化属性的值

​		通常情况下，当调用构造器去设置一个对象的属性时，会直接赋值，并不会对数据进行验证，可以采用构造器 + set方法来实现验证

​	继承 

​		可以解决代码复用，使编程更加接近人类思维，将多个类中相同的属性和方法抽象出父类，在父类中定义这些属性和方法，之后所有的子类无需重新定义这些属性和方法，只需要通过extends来声明继承于父类

​		示意图

​		![image-20250929123743258](C:\Users\Administrator\AppData\Roaming\Typora\typora-user-images\image-20250929123743258.png)

​		继承语法 ：

​			class 子类 extends 父类{}

​			子类自动拥有父类定义的属性和方法

​		好处 ：

​			代码的复用性、维护性和可扩展性提高

​		细节 ：

​			子类继承了父类所有的属性和方法，但是私有属性和方法不能被子类直接访问，可以通过公共方法（父类提供的公共方法）间接访问

​			子类在创建一个对象时，必须调用父类的构造器（默认隐藏super()默认调用父类无参构造器），完成对父类的初始化。

​			当子类在创建一个对象时，不管使用子类的哪个构造器，都会默认调用父类的无参构造器去完成对父类的初始化，当父类中没有无参构造器时，就必须在子类的构造器中使用super()来指定要调用父类的哪个构造器来完成父类初始化，否则编译无法通过

​			如果想要指定的父类构造器来实现父类的初始化，直接通过super(参数)显示调用

​			super()必须放在子类构造器的第一行，super也只能存在构造器中（先执行完了父类构造器，再执行子类构造器，即·现有父亲再有儿子）

​			super和this都只能放在构造器的第一行，因此一个构造器中只能存在其中的一个

​			Java中，所有的类都是Object的子类（Object 是所有类的基类）

​			父类构造器的调用限于直接父类，将会一直往上追溯到Object类(顶级父类)（找祖宗，完成祖宗的初始化才能有儿子）

​			子类最多只能继承于一个父类（直接继承），java中是单继承制（那如何实现一个a类继承于两个类b，c，使用两个类的属性和方法？ ： 直接先继承于其中一个类，再让这个类继承于另外一个类）

​			不能滥用继承，子类和父类必须满足 ：is a 的逻辑关系（猫是一个动物，人不是一首音乐）

​		继承的本质 

​			示意图

​			![image-20250929160300972](C:\Users\Administrator\AppData\Roaming\Typora\typora-user-images\image-20250929160300972.png)

## Java 类的组织形式 

​	JDK中有很多包，每个包中含有多个接口、类、异常、枚举；其中类中又有多个字段，构造方法/器，成员方法/方法，

​	找： 先找包，再找类，最后找方法； 直接检索

