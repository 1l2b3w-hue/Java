# Java基础

## java概述

​	程序 ：计算机完成某个操作或解决某个问题而编写的一段有序的指令集合

1995年，sun公司发布第一个版本的java ; Java 之父是**詹姆斯・高斯林（James Gosling）**

​	技术体系平台 ：
​		Java SE ：标准版

​		Java EE ： 企业版 SE的扩展 

​		Java ME ：小型版

### 	特点  

​		面向对象

​		健壮性（强类型机制、异常处理，垃圾自动回收....）

​		跨平台性 ： 编译好的文件可以在多个系统上运行(JVM来帮助解释执行)

​		解释性语言 ：经过编译后产生的文件，还需要解释器才能执行 （HTML、JavaScript、Java）

​			编译性语言 ：C 、C++

### 	JVM

​		Java虚拟机，一个虚拟计算机，包含在JDK中。

### 	JDK

​		Java开发工具包，包含JRE 和Java开发工具（javac 、java ....）

### 	JRE 

​		Java运行环境，包含JVM和Java核心类库,如果只是使用一个开发好的java程序，只需要JRE

### 环境变量path配置及其作用

​	为了在dos的任意目录下都能使用java和javac命令

​	1.在环境变量中增加一个JAVA_HOME,值为JDK安装的主目录

​	2.然后在path变量中新增一个%JAVA_HOME%\bin

### 	Java运行机制 

​		先编写java文件（源文件） ，通过javac  xxx.java来编译生成一个.class文件（字节码文件）, 再通过java xxx(不要带后缀名！！)来解释  

​		编译 ： 通过编译工具（javac.exe）生成能够被JVM识别的字节码文件(即.class文件),（有错误则报错，无错直接生成字节码文件）

​		运行 ： 通过运行工具（java.exe）将字节码文件装载到JVM机执行

​		需要注意的是

​			当编写的代码中存在中文，即便是注释里面的，应该将文件安装GBK的编码形式来重新保存，否则终端不认可（默认GBK）

​			新保存的java文件，应该重新编译形成新的class文件来保持执行的是新的java文件

### 	Java开发注意事项 

​		Java源文件以 ".java"为扩展名，其基本组成部分为类

​		Java应用程序执行的程序入口是main()方法，有固定格式 : public static void main(String[] args) { ... };

​		Java 严格区分大小写

​		Java方法的有语句组成，每条语句必须要有 ； 结尾

​		Java中每个{}都是成对出现，缺一不可

​		源文件中有且只有一个Public类，其他类个数不限制 ，对于源文件中出现的所有类，会生成相对应的class文件；可以将main方法写在非public类中，再调用运行非public类时，入口方法就是非public类的main方法

​		如果一个源文件中有一个public类，则文件名必须要与public类名一致

### 	转义字符

​		\t  : 一个制表符  \n :换行   \\"  一个双引号      \\' : 一个单引号      \r : 一个回车（并不是换行，而是计算机在读取该字符时，光标转到该行最前，然后进行读取覆盖）

### 	易犯错误 ：（语法错误）

​		找不到文件 ： 文件不存在或写错，路径错误

​		公共类名与文件夹名不一致

​		缺少分号

​		最难的是 ： 业务错误（逻辑上错了），环境错误

### 	注释 

​		单行注释 ： //

​		多行注释 ： /* .... */	不允许嵌套

​		被注释的内容不会被JVM识别和执行	

​		文档注释 ： javadoc -d 文件夹位置 -xx -yy... xxxx.java

### 	Java规范 

​		类和方法的注释采用 javadoc的方式来写

​		对于单行多行注释，是用来解释为什么这么写，怎么改，有什么影响

​		tab ： 整体左移，shift + tab ：整体右移

​		源文件应该采用utf-8

​		运算符、= 左右各空一格

​		单行不超80字符

​		代码编写行尾风格和次尾风格

## DOS 

​	磁盘操作系统

​	Dos系统 ： 接受指令（获取到一个指令），解析指令（分析要做什么），执行指令（在系统上执行这条指令）

​	相对路径 ：从当前目录开始定位，从而形成的路径

​	绝对路径 ：从根目录开始定位形成的路径

### 	常见Dos命令 

​		查看当前目录内容 ： dir

​		切换 ：cd   (切C盘 ： cd /D c:    上一级目录 ： cd  ..   切换跟目录 ： cd /)

​		查看下级的所有文件夹 ： tree 

​		清屏 ： cls

​		退出 ：ｅｘｉｔ

​		创建目录  ：md

​		删除目录  ：rd

​		复制文件 ： copy 

​		移动文件 ：remove

​		删除文件 ： del  ....

## 变量

​	变量是程序的基本组成部分

​	三要数 ： 类型 名称 变量值

​	变量是一块内存的数据存储空间的表示，通过变量名可以访问到变量值

​	不同变量类型不同，不同类型占用空间也不同，int ： 4字节  char ： 1字节  double ： 8字节  float ： 4字节

​	必须先声明，后使用 

​	一个变量的存储区域，该区域由自己的名称和类型 ，其存放的数据可以在同一类型范围内变化

​	在同作用域中，变量名不能重名

### 	\+ 的使用

​		当\+ 的旁边是数值类型时，做加法运算； 如果是一方有一个字符串，做拼串操作（运算从左到右）

### 	数据类型

#### 		基本数据类型 

​			数值  

​				整型 ： byte（字节 ，1）  ： -128 ~127

​					short （2） ： -(2^15) ~ 2^15-1  -32768 ~ 32767

​					int （4） ： -(2^31) ~ 2^31  - 1 

​					long （8） ： -(2^63) ~ 2^63  -  1 

​					整型的长度是固定的，与操作系统无关

​					Java整型常量默认为int类型声明long类型时，必须在常量后加 l 或L

​					整型变量一般使用int来存放，除非太大超出了，可以用long

​					当将一个具体的数值赋值给一个byte时，会先进行判断，这个数值是否在byte范围，是就赋值

​					bit（比特） ：计算机中最小存储单元 ，byte计算机的基本存储单元，1byte = 8 bit

​				浮点型  ： float （4）、double（8）

​					存放形式 ： 符号位 + 指数位 +尾数位 尾数位存在可能丢失的情况，从而造成精度丢失，小数都是近视值

​					长度是固定的，与操作系统无关

​					Java浮点型常量默认为double（double类型可以带 ：d后缀   即8d 表示一个double类型的8），因此声明float常量时，要加 f 或 F

​					小数表现形式 ： 

​						十进制 ： .123  等价于0.12

​						科学计数法 ： 2.12e3 (2.12 * 10^3)  2.21E-2(2.21*10^-2)

​					通常情况下，应该使用double类型，double类型精度高于float

​					当我们对运算结果是小数的进行比较时，应该注意小数可能是近似的（即计算机无法表示该小数），可能理论上相等，但实际上计算机不可能相等应该通过两个值的差的绝对值，在某个精度上来判断是否相等，小就等于；当然直接查询到的或者直接赋值的自然可以比较

​			字符类型  ： char(2)。存放单个字符,可以存放数字

​					必须使用单引号引起（双引号为字符串）

​					运行转义字符

​					在Java中，char本质是一个整数，输出是按照unicode编码输出，因此char可以是整数

​					char可以进行运算，本质是一个整数

​				字符型本质 ：
​					字符型数据存放到计算机时，需要先找出对应的码值，再将码值存放到计算机中

​					字符与码值的对应关系是通过字符编码表决定的

​			字符编码表 ： （不同的编码会对文件大小产生影响）

​				ASCII ： 一个字节 ，128个字符，虽然一个字节可以表示256个字符，但这里只使用了128个字符（因为最前面的比特位默认为0）

​					缺点 ： 不能表现所有字符

​				Unicode ： 两个固定字节（2^16），表示字母和汉字，易浪费空间（缺点），兼容ASCII

​				utf-8 ： 大小可变的编码方式，1-6 个字节来表示一个字符；  字母使用一个字节，汉字使用三个字节,使用最广

​				gbk ： 可以表示汉字，范围更加广泛 ，字母一个字节，汉字两个字节

​				gb2312 ： 表汉字，但gb2312 < gbk

​				big5 码 ： 繁体中文

​			布尔类型 ：boolean（1），存放 ：true false（两个值，不能为空）

​					用于逻辑运算

​					java中，不能使用0和非0来代替boolean类型的真假

#### 		引用数据类型

​			类（class）(string 属于类)

​			接口 （interface）

​			数组 （[]）		

### 自动类型转换 

​	当Java进行赋值或运算时，精度小的类型会自动转换为精度大的类型

​	char - int - long -float - double

​	byte - short - int - long - float - double

​	 当多种类型数据进行运算时，会自动转换为数据类型容量最大再运算

​	当把精度大（容量大）的数据转换为精度小（容量小）会报错，反之自动转换

​	byte和short 不能与char发生类型转换

​	byte short 与 char 进行运算时，只要出现，就会首先转换为int类型

​	boolean不参与自动转换

​	自动提升原则 ： 表达式结果的类型将会自动提升为操作数中最大的类型

### 强制类型转换 

​	自动转换的逆过程，使用强制转换符 ： （类型） ，可能会造成精度损失或溢出，因此要明确知道会这样，才去转

​	数据从大 --> 小，使用强制转换

​	强转符号只会针对最近的操作数有效，对于整个表达式来讲，需要（）提升优先级

​	char类型可以保存int常量值，但是无法保存变量值，需强转

### 基本数据类型与String类型相互转换

​	基本 ——> String :  + " "拼串

​	String ——> 基本：  使用基本数据类型对应的包装类的相应方法来实现转换

​	int :  Integer.parseInt() ;  short : Short,parseShort();  byte : Byte.parseByte() ; long : Long.parseLong()

​	boolean : Boolean.parseBoolean()(针对于"true","false"); 

​	float : Float.parseFloat(); double : Double.parseDouble 

​	字符串 转 字符 ： 通常将字符串的第一个字符拿出来存放

​			字符串.charAt(索引) ： 返回一个字符串的索引上的字符

​	但将String转换为基本类型数据时，应该保证String可转换为一个有效数据，如果不能转换成一个有效数据，会抛出错误，程序终止

## 运算符	 

​	一种特殊的符号，用于表示数据的运算，赋值和比较

### 算数运算符 

​	% 的本质为 ： a % b == a - a / b * b;

​		a % b 时，a 是小数时， 本质为 a - （int）a / b * b

​	++ 使用 ： (底层存在一共强制类型转换)
 		作为独立语句使用  前后 ++ 完全等价于 +1

​			前加本质 ： 会创建一个临时变量temp = i；然后执行 i = i + 1,最后执行 i = temp （i = i++）

​			后加本质 ： 创建一个临时变量temp，先执行i = i + 1; 在执行 temp = i，最后就是 i =temp

### 关系运算符（比较运算符） 

​	结果只会是true和false

​	关系运算符构成的表达式为关系表达式

### 逻辑运算符 

​	用于链接多个条件（多个关系表达式），最终结果还是boolean

​	与 ： 就是有假为假，全真为真 ； 或  ： 全假为假，有真为真

​	取反：真就是假，假就是真 ；异或 ： 相同为假，不同才真

​	短路与 && （常用） 和 逻辑与 &

​	对于&&，第一个条件为false，后面的条件不会被执行和判断； 而&无论如何将会全部执行判断真假 

​	短路或 ||（常用）  和 逻辑或 |

​	对于||，第一个条件为true，后面的条件不会被执行和判断； 而 | 无论如何将会全部执行判断真假 

### 赋值运算符 

​	将运算后的值赋值给指定变量

​	基本 ： =   ； 复合 ： +=， -=， *= ， /= ,%= 。(a +=b == a = a + b ....)

​	特点 ： 	

​		运算顺序为从右向左

​		左边只能是变量，右边可以说常量，变量，表达式

​		复合赋值运算会自动进行类型转换  a += b 等价于  a = (a的类型)(a + b)

### 三元运算符 

​	条件表达式 ： 表达式1 ？ 表达式2 （表达式1和表达式2看成一个整体，并在执行前进行自动转换！！！）

​	条件表达式为真，执行表达式1；为假，执行表达式2

​	表达式 1，2 应该是可以赋值给接受变量的类型（或者可以自动转转换）(不匹配或无法自转，要求强转)

​	三元表达式可以转换为if-else语句

### 运算符优先级 

​	整体上可以通过（）来转换成你想要的运算顺序

​	单目运算（单个操作数），赋值运算符 ： 从右向左，其余从左向右

### 标识符规则和规范

​	标识符 ：对各种变量，方法和类命名的字符就是标识符（就自己命名的东西）

​	规则 ：

​		26个字母（大小写），数字，_，$组成

​		不能以数字开头

​		不能使用关键字和保留字 ，但能包含关键字和保留字（就是含有） 

​		严格大小写，长度无限制

​		标识符中，不能包含空格

​	规范 ：（更加专业）

​		包名 ：多个单词组成时，采用小写字母  . 隔开

​		类名 ：多单词构成时，首字母大写（大驼峰法）

​		变量名，方法名 ： 多单词构成，首单词小写后续单词首字母大写（小驼峰法，简称驼峰法）

​		常量 ： 字母大写，多单词下划线隔开

​	关键字 ： 被Java语言赋予了特殊的含义，用做专门用途的字符串（全是小写）

​	保留字 ： 现有版本尚未使用，但后续版本可能作为关键字使用

### 键盘输入 

​	接受用户输入数据

​	需要一个扫描器对象 ：Scanner

​	步骤 ：
​		导入该类的所在包 ： java.util.   导入形式 ： import java.包名.类名 （import java.util.Scanner）

​		创建该类对象（声明变量） ： new创建一个实例对象 new Scanner(System.in)  : System.in 接受键盘输入 

​		调用内部功能 ： next() : 字符串，nextInt() : 整形   nextDouble() ： double类型 .... ； char : next().charAt(0)

​		当执行到next方法时，程序会一直等待用户输入的信息

### 进制 

​	对于一个整数，有四种表现形式

​	二进制 0，1  0b 或0B开头

​	十进制 0~9

​	八进制 0~7  0开头

​	十六进制 0~9A~F（不分大小写）   0x 或0X 开头

### 原码、反码、补码 

​	有符号数：

​	最高位为符号位，0正1负

​	正数原反补一致

​	负数反码 = 原码符号位不变，其他位取反， 补码 = 反码 + 1；0的反码补码都是0；

​	Java中没有无符号位，即java中的数都是有符号数

​	计算机运算时，**以补码形式来进行运算**，但是运算结果是以原码出现

### 位移运算符  

​	& ：按位与  ：全1为1， 其余为0

​	| ：按位或  ： 全0 为0， 其余为 1

​	^  ： 按位异或  ： 相同为0，相异为1 

​		了解两个公式 ： a ^ 0 = a ; b ^ b = 0;两个实现数据交换

​	~ ：按位取反  ： 1是0 ， 0 是1

​	>> ：算数右移 ，低位溢出，高位补符号位 本质就是除以几个2

​	<< ： 算数左移，符号位不变，低位补0   本质就是乘几个2

​	>>> ： 逻辑右移， 低位溢出，高位补0  

​	注意 ： 没有逻辑左移

## 程序控制结构

### 	顺序控制

​		程序从上到下一步一步执行，中间没有任何判断和跳转

​		定义变量时，使用**前向引用**（先定义后引用）

### 	分支控制

​		让程序有选择的执行

#### 	if - else 分支

##### 		单分支

​			if(条件表达式) { 执行代码块 }（当执行代码块中只有一个语句，可以不用{}，但建议写上）
​			当条件表达式为真，执行{}中的执行代码块，为假，则不执行{}内的执行代码块

##### 		双分支

​			if(条件表达式1) { 代码块1}

​			else{代码块2}

​			条件表达式1 为真，执行代码块1，为假执行代码块2；				

##### 		多分支

​			if(条件表达式1) {代码块1}

​			else if(条件表达式2) {代码块2}

​			....

​			else {代码块n}

​			条件表达式1 为真，执行代码块1，为假判断条件表达式2；真执行代码块2，假继续判断....知道全部为假，执行代码块n

​			整体上最多只允许有一个执行入口，可以没有执行入口（即没有else，且条件表达式都不成立）

##### 		嵌套分支

​			在一个分支结构中，嵌套一个完整的分支结构，里面分支为内层分支，外面的分支为外层分支；

​			规范 ： 不建议超过三层，可读性不好

#### 	switch分支	

```
switch(表达式) { java中，只要有值可以返回，就是一个表达式
	case 常量1 ： 代码块1
		break;
	case 常量2 ： 代码块2
		break;
	case 常量3 ： 代码块3
		break;
		....
	default :  代码块n
		break;
} 
```

​		switch是一个关键字，表示switch分支

​		表达式对应一个具体的值

​		case 常量1 表示 ： 当表达式的值等于常量1，则执行语句块1，然后break退出switch

​		和case 常量1匹配，执行语句块1，不匹配就开始匹配case 常量2 ......

​		如果一个都没有匹配，执行default中的代码块

​		注意事项 ：

​			表达式的数据类型应该和case常量的数据类型一致，或者可以自动转换为可以相互比较的类型

​			表达式返回的数据类型只能是 ： byte，short ，int，enum（枚举）， char ，String

​			case 子句中的值必须是常量或者是常量表达式，不能是变量

​			default 是可选的，没有default，且没有匹配到任何case子句，将会啥也不干

​			break用来在执行完一个case子句的代码块，跳出switch，如果没有break，会按照顺序执行下面的case子句代码，知道下面的全部执行或遇到break

​	switch 和 if

​		如果判断的数据类型不多，且符合 byte，short ，int，enum（枚举）， char ，String，建议使用switch

​		对区间判断，对结果为boolean类型判断时，使用if分支更加合适

​	

### 	循环控制

#### 	for循环

​		for(循环变量初始化 ； 循环条件 ； 循环变量迭代) { 循环操作 }

​		for ：关键字，表示循环控制

​		四要素 ：循环变量初始化 循环条件 循环操作 循环变量迭代

​		循环操作 ：可多条语句，单语句（{} 可省，但不要省）

​		循环条件是一个返回布尔值类型的表达式

​		for循环中的初始化循环变量和循环变量迭代可以写在别的地方，但分号不能省略 (for(;;) 表示一个死循环)

​		循环变量的初始化可以有多条语句，但要类型相同；循环变量的迭代可以有多条语句；多条语句都由逗号隔开

#### 	while循环 

​		循环变量初始化；while（循环条件） { 循环操作 ； 循环变量迭代 }

​		四要素，位置不同

​		循环条件还是一个返回布尔类型的表达式，先判断，后执行

#### 	do-while循环

​		循环变量初始化； do { 循环操作；循环变量迭代； }while（循环条件）；

​		先执行，再判断，一定会执行一次； **最后一定要有一个 ；号**

#### 	多重循环

​		当一个循环中有另一个循环，将会构成循环嵌套，一般建议两层循环，最多不要超过三层

​		循环嵌套是将内层循环作为外层循环的循环体，只有内层循环结束后才会结束外层的一次循环

​		当外层循环要执行m次，内层循环执行n次，则内层循环体将会执行m * n 次

## 编程思想 

​	化繁为简

​		将复杂需求拆解为简单需求，逐步完成

​	先死后活

​		先考虑固定值，然后转成可以灵活变化的值

### 跳转控制语句

#### 	break

​	用于终止某个语句块的执行，常用于switch和循环 

​	break 语句出现在多层嵌套的语句块中，可以通过标签指明要结束哪一层语句块

#### 	标签语法 

```
label1(只是一个标识符) ： {
	label2 ： {
		label3 ： {
			break label2;//结束 label2 的语句块
		}
	}
}
```

​		break 语句可以指定退出哪一层

​		label 是标签，名字由程序员确定

​		break后指定到哪个标签，就退出到哪里

​		并不推荐使用标签

​		break没有指定时，默认跳出最近的循环体

#### 	continue 

​		结束本次循环，继续执行下一行循环，也可以根据标签跳过指定循环

#### 	return

​		使用在方法中，表示跳出该方法；return写入main方法时，执行将会结束程序

## 数组、排序、查找

### 数组 

​	存放多个同一类型的数据；是一个引用类型的数据类型；数组就是一组数据

#### 	定义 

#### 		动态分配方式

​			数据类型[]   数组名([] 可以写在数组名后) = new 数据类型[元素个数]；

​			先声明：数据类型[] 数组名  或 数据类型 数组名[] （此时为空） ，再创建 ： 数组名 = new 数据类型[元素个数]

#### 		静态初始化 

​			数组类型[] 数组名 = {元素1，元素2....}  (知道由多少个数据使用静态方式)

​			等价于 ： 数组类型[] 数组名 = new 数据类型[个数]， 数组名[0] = 元素1....

​	数据类型[] 数组名 = new  数据类型[] { .... } 可以创建一个数组，但应该注意的是 ： new 数据类型[] 中的[] 不能填写数字，而是由计算机去读取后面的元素来确定数组长度

#### 	引用/使用 

​		数组名[下标/索引]

​		数组下标从0开始 

​	注意 ：

​		数组是多个相同数据类型的组合，用于实现对这些数据的同一管理

​		数组中的元素可以是任何数据类型，基本类型和引用类型都可以

​		数组被创建后，如果没有赋值，将会赋值默认值 ： 

​			//  int byte short long : 0; float double : 0.0 boolean : false String: null char :\u0000(0字符，u表示十六进制)

​		使用数组 ： 声明开辟数组，赋值，使用

​		下标从0开始

​		数组下标必须在指定范围内去使用，否则数组下标越界异常，编译可以通过，但是执行将会抛出异常

​		数组属于引用类型数据，数组型数据是对象（数组本事就是一个对象）

#### 	数组赋值机制 

​		基本数据类型赋值 ,赋值方式是值拷贝 ： 一个变量的变化不会影响到其他与其关联的变量

​		数组赋值，默认情况下是引用传递/地址拷贝，赋值方式是引用赋值，赋值的是地址

## 	值传递和引用传递的区别

​		前提 ： 在JVM中，内存分为三个部分 ： 栈 、 堆 、 方法区

​		对于基本数据类型，会直接存放在栈区中（变量名和变量存放的数据）

​		而对于数组来讲，数组名将会存放在栈区中，而具体存放内容将会放在堆区中，栈中的数组名将会存放一个地址，指向了存放在堆区中的数据

​	当基本数据类型进行值传递时，会将一个变量存放的数据拷贝一份放入另一个变量，两个变量存放的数据并无关系，只是一样，

​	当数组进行引用传递时，会将一个数组名存放的地址拷贝一份放入另一个数组名，但是由于地址一样，导致新数组名可以根据地址信息找到存放在堆区的数据内容，此时发生更改将会影响其他指向该数据内容的数组。

#### 	数组的拷贝

​		要求数据空间相互独立

​		创建一个新的数组，使其大小一致，再遍历赋值，创建出两个相互独立的数组

#### 	数组的扩容

​		定义一个新的数组，使其长度为原数组长度 +1，依次将原数组元素赋值给新数组，并为新数组赋值一个新元素，使用引用拷贝替换原数组内容

## 	排序 

​		将多个数据，按照指定顺序进行排序的过程

### 		内部排序

​			将所有的数据全部加入内存进行排序

### 		外部排序

​			数据量过大，无法全部加载到内存中，需要借助外存来进行排序 

### 		冒泡排序 

​			通过对待排序序列从后向前，依次比较相邻元素的值，发现逆序就交换，使值较大的元素逐渐从前移向后部

​			注意点 ：

​				比较时应该注意是否越界，对于已经排列到最后的最大数时，不需要再比较（内层循环的条件应该小于数组长度　－　１　－　ｉ）；

​				拍到最后就剩一个数时，也不需要再排序（ｎ个数只需要ｎ－１次外层循环）

## 	查找

​		顺序查找　：遍历一边查找

​		二分查找 ：针对于一组有序数组，先查中间，看大小关系，大后找，小前找

## 	二维数组 

​		一个数组的元素又是一个数组，则这个数组称为二位数组

​		二位数组的元素个数 ： 数组名.length

​		如果需要得到二位数组中一位数组的元素，需要再遍历一个二位数组的元素

​		访问第i个一维数组的第j个元素 ： 数组名\[i -1][j - 1];

​		动态初始化 ：
​			类型\[][]  数组名 = new 类型\[][] (第一个[] 表示有几个一维数组，第二个[]表示一个一维数组有几个元素)

​			类型\[][] 数组名 ； 数组名 = new \[][]; 先声明，再创建

​			列数不确定，java中允许一维数组的个数不确定 ： 

​				先开辟出二维数组个数（int\[][] arr = new int\[3][]; 确定了二位数组空间，但是一位并没有赋空间），后面根据情况开辟一维数组元素个数(arr[i] = new int[i + 1];)

​		静态初始化 ：int\[][] arr = new int\[][] ;  int\[][] arr =  {{},{},{}}

​		声明 ：类型\[][]  数组名 ；类型  数组名\[][] ； 类型[] 数组名[]

## 面向对象

引入 ： 

​	以前知识（单独变量，数组）存在不利于数据管理和效率低

​	java设计者引入类与对象(OOP),就是为了解决现有技术无法完美的解决现有需求（不利于管理和效率低）

一个程序就是一个世界，有很多的事物（可以通过对象来表示）(对象[属性，行为])

### 类与对象的关系 

​	类 ： 就是一个由程序员创建的数据类型，（将一种事物的属性和行为提前出来形成一个类）

​	对象 ： 可以通过一个类，创建一个具体的事物（具体的实例对象）

​	从类到一个对象 可以称为 ： 创建一个对象；实例化一个对象；把类实例化

​	类是抽象的，概念的，代表一类事物 （是一个数据类型）

​	对象是具体的，实际的，代表一个具体的事物 （是一个实例）

​	类是对象的模板，对象是类的一个个体，对应一个实例

### 对象内存布局 

​	对于属性的存放 ： 如果是基本数据类型，将会存放到堆区，而String将会放入方法区的常量池（存放常量）中 

​	在创建一个对象时，会先在方法区中加载类的信息，在堆中开辟一块区域存放类的属性（默认值）

​	cat只是指向一个对象，称为对象引用或对象名，真正的对象是 ： new Cat（）

### 属性/成员变量

​	属性 = 成员变量 = field(字段)

​	属性是一个类的基本组成部分，可以是基本类型，也可以是引用类型

### 注意事项 

​	属性的定义语法 ： 访问修饰符  属性类型 属性名

​		访问修饰符 ：控制属性的访问范围； 四种 ： public , protected , 默认 , private

​	属性类型可以是基本类型，也可以是引用类型；

​	属性未被赋值时，取默认值，与数组规则一致

### 对象的创建 

​	先声明 ： 类  对象名 ； 对象名 =  new 类() 再创建对象

​	直接创建 ： 类 对象名 = new 类()；

### 访问对象属性

​	对象名.属性名

### 对象创建流程 

​	先加载相关类信息（属性和方法），只会加载一次；

​	在堆中分配空间，大小由类的属性个数决定，为属性赋默认值

​	将堆中对象的地址赋值给对象名

​	进行指定初始化

### 成员方法/方法

​	Java中，通过方法来描述一个具体事物的行为

	//方法的使用：
	// 方法写好后，不去调用（也称为使用），将会无法执行
	// 先创建一个对象，再调用方法
	Person p1 = new Person();
	p1.speak();//调用方法
	p1.cal02(5); //调用cal02方法，传递一个参数5，让n = 5
	// 调用getSum方法，传递两个参数，使num1 = 20, num2 = 10;
	// 并将返回值赋值给returnRes
	int returnRes = p1.getSum(20,10);


​	
​	// public 表示这个方法是公开的
​	// void 表示该方法没有返回值
​	// speak() : 表示该方法名称为speak，() : 形参列表，这里显示没有形参
​	// {} ： 方法体，里面放要执行的代码
​	public void speak() {}
​	// (int n) : 表示当前一个形参n，接受用户输入
​	public void cal02(int n) {}
​	
​	// int : 表示该方法执行后，会返回一个int类型的数据
​	// return result 表示将result的值返回
​	public int getSum(int num1, int num2) {
​	return result;}

### 方法调用机制 

​	方法执行完毕或执行到return时就退出栈空间

方法的好处 

​	提高代码的复用性

​	可以将实现细节封装起来，其他用户调用即可

### 成员方法的定义 

​	访问修饰符 数据类型 方法名(形参列表) {语句块（方法主体）； return 返回值}；

​		形参列表 ：表示成员方法接受的值（形参）

​		数据类型 ： 表示成员方法返回的数据类型，void表示无返回值

​		语句块 ： 实现某一功能

​		return语句不是必须的

​	思路 ： 

​		确定方法返回类型

​		确定方法名

​		确定方法形参（个数和类型）

​		确定方法体

### 方法注意事项和细节

​	 访问修饰符 ： 控制方法的使用范围， 四种 ： public , protected , 默认 , private

​	返回数据类型 ：

​		一个方法最多只能有一个返回值，当需要返回多值时，采用返回数组的形式返回（将返回值存放在数组）

​		返回值的类型可以是任意类型（基本和引用都行）

​		如果方法要求有返回数据类型，则方法最后执行的语句为 return 值（值可以是一个数据或着一个表达式），并且要求返回值的数据类型必须与return返回的数据类型一致或兼容

​		如果返回类型为void，可以不用写return 或者直接写return（不能再写表达式或值）

​	方法名 ：采用驼峰命名法，见名知意

​	形参列表 ：一个方法可以有0个形参或多个形参（逗号隔开）；可以是任意类型，

​		调用含形参方法时，一定对应着参数列表传入相同数据类型或类型兼容的参数

​		方法定义时，参数被称为形式参数（形参），方法调用时，参数被称为实际参数（实参），形参实参的类型，个数，顺序要求一致

​	方法体 ： 不能再定义方法（不能嵌套定义方法）

### 方法调用注意事项

​	同一类中的方法调用时 ，直接可以进行调用

​	跨类的方法调用时，通过创建对象实例，使用对象名来进行调用。对象名.方法名()

​	跨类方法的调用和方法的访问修饰符有关

Math.random() ：随机生成一个0~1之间的double类型的数据

字符串比较方法 ：

​	equals()  ：String类中的方法，参数为想要比较的字符串，相等为true，不等为false

		System.out.println(name.equals("张三"));
		System.out.println("张三".equals(name)); //推荐，避免空指针 

### 方法传参机制

​	基本数据类型传参机制	

​		对于基本数据类型，传递的是值（值拷贝），形参的变化并不会影响到实参的变化

​	引用类型传参机制 

​		引用类型数据传递的是地址（值是地址），因此对形参指向的内容进行修改时，会影响实参中的数据，如果对形参进行执行修改，将不会影响到实参的数据。需要注意的是，当传递的是一个不可变的的引用数据类型，传副本，跟基本类型一样，不影响原值

### 方法递归调用

​	方法自己调用自己，每次调用时传入不同的参数；用于解决复杂问题，并使代码比较简洁

​	规则 ：

​		每调用一次方法，会在栈中创建一个新的受保护的独立空间

​		方法的局部变量是独立的，不会相互影响

​		如果传递的参数是引用类型，将会共享该类型中的数据（都是指向堆区的同一个位置）

​		递归必须向退出递归的条件移动，否则将会出现无限递归，栈溢出（StackOverflowError）

​		当一个方法执行完毕或者遇到return，就会返回，遵循谁调用，返回给谁的原则，并且这个方法就执行完毕

### 方法重载（Overload）

​	java中允许同一个类中，多个同名方法存在，但是要求形参列表不一致

​	好处 ： 减轻了起名和记名的麻烦

​	注意事项 ：

​		方法名一定一样

​		方法的形参列表必须不同（类型，个数和顺序）

​		方法返回类型没有要求。（即如果两个方法名，形参列表一致，虽然返回类型不一样，但还是不构成方法重载，为方法重定义）

​		方法重载时，优先找匹配的形参列表，再找可以自动转换的，实在找不到报错

### 可变参数

​	Java中，允许将同一个类中的多个同名同功能但参数个数不同的方法封装成一个方法

​	基本语法 ：访问修饰符  返回类型 方法名（数据类型... 形参）

​	注意事项：

​		可变参数的实参可以是0~n个

​		可变参数的实参可以是一个数组

​		可变参数的本质就是一个数组

​		可变参数与普通类型的参数放在一个形参列表中，必须要保证可变参数是在最后面

​		一个形参列表中只允许出现一个可变参数

作用域

​	Java中，主要的变量为属性（成员变量）和局部变量

​	局部变量一般指定义在成员方法内的变量（定义在代码块的变量也是局部变量）

​	作用域分类 ：

​		全局变量 ：作用域为整个类

​		局部变量 ：除了属性变量之外的变量，作用域为所在的代码块中

​	全局变量可以不赋值直接使用（会赋默认值），局部变量必须赋值后才能使用，因为不会赋默认值

​	注意事项 ：
​		属性和局部变量可以重名，访问时遵循就近原则

​		同一个作用域中，不允许同名变量的出现

​		属性的生命周期较长，伴随着对象的创建而创建，伴随对象的销毁而销毁，局部变量的生命周期较短，伴随代码块的执行而创建，伴随着代码块的结束而销毁	

​		全局变量可以在本类中使用，也可以在其他类中使用（通过对象调用:跨类创建对象，或者方法接受一个类创见的实例作为参数）； 局部变量只能在本类的对应方法中使用

​		全局变量可以增加修饰（public、protected、private...），局部变量不能增加

构造方法/构造器（constructor）

​	是类的一种特殊方法，完成对**新对象的初始化** （对象已经存在，但其中的属性值由构造器完成赋值）

​	特点 ： 方法名与类名保持一致；没有返回值；在创建对象时系统自动调用该类的**构造器完成为对象的属性赋值**

​	基本语法 ：

​		[修饰符] 方法名(形参列表) {方法体}

​		修饰符可以是默认的，也可以是 ： public protected private

​		构造方法没有返回值

​		构造方法名必须与类名一致

​		形参列表要求与方法一致

​		构造器的调用由系统完成（new的时候就完成了）

​	注意事项 ：
​		一个类里面可以由多个构造器，实现构造器的重载

​		构造器与类名一致；没有返回值；在创建对象时，系统自动调用该类的构造器

​		构造器是完成对象的初始化，并不是创建对象；

​		如果没有定义构造器时，系统会自动生成一个默认无参构造方法（就是默认构造方法）

​		 **javap**  ： 反编译查看(不要加class后缀) （class -> java）

​		一旦定义了构造器，将会覆盖默认的构造器，无法再使用默认构造器，如果还是想使用，可以再定义一个无参构造器（显式定义，相当于构造器重载）

对象的创建 ：
		1.加载类信息（只会加载一次）

​		2.在堆中开辟一块空间，存放对象的属性，并赋默认值

​		3.根据类中对属性的赋值进行赋值（显式赋值）

​		4.再根据构造器进行赋值初始化

​		5.将堆中的对象的地址赋值给指定变量

### this关键字

​	Java虚拟机会为每个对象分配一个this，这个this代表着当前的对象

​	this可以看作为一个对象的隐藏属性，其存放的内容为当前对象的地址值（指向这个对象）

​	this ： 哪个对象调用，就指向哪个对象

​	注意事项 ： 

​		this关键字可以用来访问本类的属性（准确定位属性）、方法、构造器

​		this用于区分当前类的属性和局部变量

​		访问成员方法 ： this.方法名（参数列表）

​		访问构造器 ： this(参数列表)  ： 只能在构造器中使用，来访问另一个构造器（参数列表使用实参，要匹配你想要的构造器的形参列表），必须放在构造器的第一条语句中

​		this不能在类的外部使用，只能在类定义的方法中使用

​		方法中如果没有同名变量，则加不加this都是指向对象的属性

注意问题 ：

​	在处理一个数组类型的数据时，应该考虑到数组长度为0（为空），或者数组指向了一个空的问题

​	匿名对象 ：没有名字的对象  即new 类() 后并不会返回给一个对象应用，只能使用一次

​	对于复用构造器时，应该从构造器少的开始

​	hashCode（） ： 返回一个对象的int类型数据，该数据是通过对象在内存中的地址换算而来的，可以将其看成一个地址，但他本身并不是一个地址值（因为在JVM虚拟机上执行的，获取地址没用）

### 包

​	作用 ：

​		区分相同名字的类

​		当类的数量过多时，可以很好的管理类

​		控制访问范围

​	基本语法 ：

​		package 包名

​		package ： 关键字，表示打包

​	包的本质就是创建不同的文件夹来保存类

​	命名规则 ：

​		只包含数字、字母、下划线_、小圆点. 。不能以数字开头，不能为关键字和保留字

​	命名规范 ：

​		小写字母 + 小圆点  ： com.公司名.项目名.业务模块名

​	常用包 ：

​		java.lang : 基本包，直接用，不需要引用

​		java.util : 系统提供的工具包

​		java.net  ： 网络包

​		java.awt  ：界面开发

​	引入包 ：

​		引入一个包就是为了使用一个包中的某些类

​		引用方式可以有 ：

​			import 包名.具体的类  （推荐这种形式，需要什么就导入什么就行）

​			import 包名.* : 将包名中的所有类全部引进来

​	注意细节 ：

​		package 是声明当前类所在的包，要放在类或文件的最前面，一个类最多允许一个包	

​		import 指令放在package后面，类定义之前，可以有多条import，没有顺序要求

### 访问修饰符

​	Java提供四种访问修饰符号，用于控制方法和属性（成员变量）的访问权限（范围）

​	公开级别 ：public ， 对外公开

​	受保护级别 ：protected ，对子类和同一个包中的类公开

​	默认级别：没有修饰符，向同一个包中的类公开

​	私有级别：private ，只有类本身可以访问，不对外公开

​	使用注意事项 ：

​		访问修饰符可以修饰类中的属性、方法以及类

​		类只能由public和默认修饰，遵循访问限制

​		成员方法的

### 	封装

​		封装（encapsulation）就是把抽象出的数据[属性]和对数据的操作[方法]封装在一起，数据被保护在内部，程序的其它部分只有通过被授权的操作【方法]，才能对数据进行操作。

​		把细节封装起来，直接调用（用户用遥控器操作电视）

#### 	好处 

​		隐藏实现细节（调用者只需知道这个有什么用，怎么用）

​		可以对数据进行验证，保证安全合理

#### 	实现 

​		将一个属性进行私有化设置（private）

​		提供一个public的set方法，用来对属性判断并进行复制

​		提供一个public的get方法，用来获取这一个私有化属性的值

​	通常情况下，当调用构造器去设置一个对象的属性时，会直接赋值，并不会对数据进行验证，可以采用构造器 + set方法来实现验证

### 继承 

​	可以解决代码复用，使编程更加接近人类思维，将多个类中相同的属性和方法抽象出父类，在父类中定义这些属性和方法，之后所有的子类无需重新定义这些属性和方法，只需要通过extends来声明继承于父类 （建立一个查找关系）,

#### 	继承语法 

​		class 子类 extends 父类{}

​		子类自动拥有父类定义的属性和方法

#### 	好处 

​			代码的复用性、维护性和可扩展性提高

#### 	细节 

​		子类继承了父类所有的属性和方法，但是私有属性和方法不能被子类直接访问，可以通过公共方法（父类提供的公共方法）间接访问

​		子类在创建一个对象时，必须调用父类的构造器（默认隐藏super()默认调用父类无参构造器），完成对父类的初始化。

​		当子类在创建一个对象时，不管使用子类的哪个构造器，都会默认调用父类的无参构造器去完成对父类的初始化，当父类中没有无参构造器时，就必须在子类的构造器中使用super()来指定要调用父类的哪个构造器来完成父类初始化，否则编译无法通过

​		如果想要指定的父类构造器来实现父类的初始化，直接通过super(参数)显示调用

​		super()必须放在子类构造器的第一行，super也只能存在构造器中（先执行完了父类构造器，再执行子类构造器，即·现有父亲再有儿子）

​		super和this都只能放在构造器的第一行，因此一个构造器中只能存在其中的一个

​		Java中，所有的类都是Object的子类（Object 是所有类的基类）

​		父类构造器的调用限于直接父类，将会一直往上追溯到Object类(顶级父类)（找祖宗，完成祖宗的初始化才能有儿子）

​		子类最多只能继承于一个父类（直接继承），java中是单继承制（那如何实现一个a类继承于两个类b，c，使用两个类的属性和方法？ ： 直接先继承于其中一个类，再让这个类继承于另外一个类）

​		不能滥用继承，子类和父类必须满足 ：is a 的逻辑关系（猫是一个动物，人不是一首音乐）

#### 	继承的本质 

​	创建一个子类时，就建立了一个查找关系

​		查找关系

​			1.先查看子类是否有该属性，有并且可以访问，则返回信息

​			2.如果子类没有，查看父类中是否含有该属性，有并且可以访问时，返回信息

​			3.如果父类还没有，继续往上找，直到Object还未找到，直接报错

​		当再查找过程中，发现找到了指定的属性，但是这个属性是私有的，即使后面有可以访问的指定属性，但是由于先找到了私有的，将会停止查找，并在编译时报错

​		当一个类作为父类时，如果没有默认构造函数，将会在某个类要继承于该类时产生错误，因为子类继承父类时，默认通过无参构造器进行父类初始化，而此时父类的无参构造器已被覆盖，从而产生错误，为此，应该显示调用super使其匹配父类现有的构造器

#### 	super关键字

​		代表父类的引用，用于访问父类的属性，方法和构造器

​		访问属性 ：

​			super.属性名， 不能访问父类的私有属性

​		访问方法 ：

​			super.方法名(形参列表)，不能访问父类的私有方法

​		访问构造器 ：

​			super(参数列表)    只能放在子类的构造函数中；只能放在第一句，有且只有一条super()语句

##### 		细节 

​			调用父类构造器的好处 ： 分工明确，父类属性由父类构造器初始化，子类由子类初始化

​			当子类的属性和方法名与父类的属性与方法名重名时，访问父类的属性和方法，必须使用super来访问，如果没有重名，使用super、this和直接使用没有区别

​			super的访问不限于直父类，如果爷爷类中含有与本类重名的属性或方法，也可以通过super来访问到爷爷类的属性和方法（前提父类没有），如果多个上级类都有重名成员，采取就近原则，谁先找到就是谁，遵循查找规则（私有无法直接得到）

```
此时想要调用某个方法，于是乎，出现了下面的查找顺序 (方法就从方法区中逐步查找)
//        1.先查找本类中是否含有该方法，有就调用自身的cal方法
//        2.如果本类中没有，将会到父类中去查找，如果有，并且可以访问，则执行该方法，如果不能执行，会在编译时报错(没有权限访问)
//        3.如果没有，重复步骤2，3执直到查完Object还没有找到，将t提示方法不存在(无法解析)
   下面三种逻辑在子类没有重名方法时，是等价的
        cal();
        this.cal(); // this的逻辑与直接写的逻辑完全一样
        super.cal();//与上面的查找存在不同 ： 直接查找父类，不会查本类
        
//        访问属性规则 (就直接从堆中直接往上(就是根据父子关系)查)
//        与查找方法是一样的规则
//        this 和 直接引用是等价的，super直接从父类查起
```

#### 	this 与super的区别

#### 方法重写/覆盖（override）

​	子类有一个方法，与父类方法的名称，返回值，形参列表全部一致，称子类的方法覆盖了父类的方法（父子关系不一定是直接关系，可以是祖宗）

##### 	细节 

​		子类的方法名，参数要与父类的方法名，参数必须一样

​		子类方法的返回类型要与父类方法的返回类型一样，或者是子类方法的返回类型是父类方法的返回类型的子类。	

```
父类为 public Object say()  子类可以 ：public String say() 或者 ： public Object say()
```

​		子类方法不能缩小父类方法的访问权限，但是可以放大(根据public > protected > 默认 > private，从左往右缩小，右往左放大)

##### 	与方法重载区别

### 多态 

​	问题 ： 在喂食这个场景中，如果随着动物的种类增多，喂食的方法也会变多，使代码复用性不高，不利于代码维护（引入多态解决）

​	方法和对象具有多种形态，是面向对象的第三大特征，建立在封装和继承基础之上

#### 	方法的多态 

​		方法的重写和重载

#### 	对象的多态（核心，重点，难点）

​		一个对象的编译类型和运行类型可以不一致

​		编译类型在定义对象时，就已经确定了，不能改变

​		运行类型是可以变化的,可以通过getClass() 

​		编译类型 看定义时 = 的左边，运行类型看定义时 = 的右边

```
Animal animal  =  new Dog() :  编译类型是Animal，而运行类型却是Dog，因此可以不一致
animal = new Cat() : 此时运行类型变更为Cat，
```

#### 	细节 

​		多态前提 ： 两个对象（类）存在继承关系

​		向上转型  ： 父类的引用指向了子类的对象（可以是直接子类，也可以是间接子类）

​			语法 ： 父类类型  引用名  = new  子类类型 ()

​			特点 ：可以调用父类中的所有成员(要遵守访问权限) ， 但是无法调用子类的特有成员（编译阶段，能调用的成员由编译类型决定，调用子类特有成员时，编译器无法识别）

​				最终运行结果由运行类型的调用决定，**调用方法时，先找运行类型是否含有，再找父类**（规则与找方法一样）

​		向下转型 ：

​			语法 ： 子类类型  引用名 = （子类类型）父类引用

​			特点 ： 只能强转父类的引用，不能强转父类的对象，

​				在强转父类的引用时，要求原本父类的引用必须指向当前目标类型的对象（如果乱来，虽然编译器看不出来，但是运行一定报错）

​				向下转型后可以调用子类的所有成员

​		属性没有重写之说，**属性的值由编译类型决定**（查找方式与方法不同）

​		instanceOf 比较操作符  ： 判断对象的运行类型是xx类型或在xx类型的子类型，是返回true，否为false （aa instanceof AA）

#### 动态绑定机制（非常重要）

​		调用对象方法时。该方法将会与该对象的运行类型/内存地址相互绑定。调用该运行类型中的方法，当没有找到时，发挥继承机制，到父类查找....

​		当访问对象属性时，没有动态绑定机制，哪里声明哪里调用

#### 多态数组

​	数组定义类型为父类类型，里面保存的实际元素类型为子类类型

​	通过遍历这个数组，来完成访问所有子类，并且可以通过类型判断后再通过向下转型成具体子类调用子类特有方法

#### 多态参数

​	方法定义的形参类型为父类类型，实参类型允许为子类类型

### Object类详解

#### 	equals 方法 

​		==  ：

​			可以用来判断基本类型，又可以用来判断引用类型

​			当判断基本类型时，主要通过判断基本类型的值是不是相等

​			当判断引用类型时，主要通过判断地址是否相同，即两个是不是同一个对象

​			只要有基本类型进行判断，则会判断两者值是否相等

​		equals ：

​			只能判断引用类型

​			默认判断的是地址是否相同（Object直接比较地址），子类往往重写该方法，使其用来判断内容是否相等

​		重写 ：

​			先判断两个对象是不是同一个对象（是true,否false）

​			在判断是不是同一个类型（是，进行向下转型并比较，否false）

#### 	hashCode

​		返回一个对象的哈希码值

​		提高具有哈希结构容器的效率

​		两个引用，指向的对象一样时，其哈希值肯定一样；如果指向不同的对象，则哈希值是不一样的

​		哈希值主要根据地址转换成一个整数（哈希值），但不能与地址等价

​		集合中，hashCode需要的话，也会进行重写

#### 	toString

​		返回对象的字符串表示形式

​		返回字符串 ： 全类名（包名 + 类名） + @ + 十六进制的hashCode值 

​		重写toString方法来实现输出对象的属性值，当然可以定制输出情况

​		当直接输出一个对象时，toString方法会被默认调用 （system.out.println(一个对象)  ==  对象.toString()）

#### 	finalize

​		以及被弃用了，会在对象销毁前，调用finalize方法 （对象并不会在对象没有引用指向时就消亡，会根据相关算法进行消亡）

​		System.gc() : 启动垃圾回收机制

### 断点调试（debug）

​	排错！整个断点调试是运行状态，是以对象的运行类型来执行的

​	快捷键 ： 

​		f11 : 跳入方法  

​		f10 ： 逐行执行

​		shift + f11  ： 跳出方法  : 跳出单个方法

获取一个yyyy-mm-dd hh-mm-ss 格式的时间 ：

​	Date date = new Date();

​	simpleDateFormat sdf = new simpleDateFormat("yyyy-MM-dd HH-mm-ss")；

​	sdf.format(date) : 获取

建议一段代码完成一个功能，尽量不涉及多个功能；

找出错误的条件，然后给出提示（然后正确代码不需判断），如果先正确，需要给出另一个分支来提示错误信息

当一个方法是static时，就是一个静态方法，静态方法可以通过类名直接来进行调用

房屋出租项目分析 ：

​	分层设计 ： （界面 —— 业务——实体）

​		确定系统中有多少个类（创建多少个文件或包，实现不同类不同包管理）

​		确定类与类之间的调用关系

​	架构图 ：（分析从上到下，实现从下到上)

​	实现功能的三部曲 ： 明确完成功能、思路分析、代码实现

## Java 类的组织形式 

​	JDK中有很多包，每个包中含有多个接口、类、异常、枚举；其中类中又有多个字段，构造方法/器，成员方法/方法，

​	找： 先找包，再找类，最后找方法； 直接检索

## 面向对象（高级部分）

### 类变量和类方法

​	类变量引入 

​		对于前面来将，当我们声明一个变量来记录某个类的实例对象完成的某个操作时，往往会定义一个变量通过++来记录，但是有一个非常尴尬的事情，那就是这个变量是独立于该类的，实例对象访问这个变量是十分麻烦的，并且不能体现出OOP，为此引入类变量

​		就在一个类中定义一个变量，通过static修饰这个变量使其成为一个类变量(静态变量)，对于这个变量，类的所有对象实例都可以访问到这个变量

​	类变量的内存布局

​		共识 ：static变量 是同一个类所有对象共享的；在类加载时候static变量就生成了，即使没有创建对象实例也可以访问

​	类变量 ： 

​		也称静态变量/静态属性，是该类的所有对象共享的变量，任何一个该类的对象都可以访问到这个变量（同一个值），任何一个该类的对象对该类的修改都将会影响到其他对象对其的访问（值被修改）

​	定义方式 ：

​		访问修饰符 static 数据类型  变量名（推荐）

​		static 访问修饰符 数据类型 变量名

​	访问 ：

​		类名.类变量名   （推荐）

​		对象名.类变量名（静态变量的访问修饰符与普通属性一致）

​	使用细节 

​		什么时候使用 ： 需要所有对象共享一个变量时，就可以考虑将该变量作为类变量

​		类变量和实例变量的区别 ：类变量是该类的所有对象共享的，实例变量是每个对象独有的

​		加上static就是类变量和静态变量，否则就是实例变量、普通变量、非静态变量

​		类变量可以通过类名.类变量名，对象名.类变量名来进行访问（前提符合访问修饰符），推荐类名.类变量名（java设计者）

​		实例变量不能通过类名.实例变量名访问

​		类变量在类加载是就被创建，因此，即使没有创建对象实例，也可以通过类名访问类变量

​		类变量的生命周期是从类加载时开始，随着类的消亡而销毁（与对象实例没关系）

​	类方法/静态方法

​	定义

​		访问修饰符 static 返回值类型 方法名(形参列表){} (推荐)

​		static 访问修饰符 返回值类型 方法名(形参列表){} 

​	调用 

​		类名.类方法名()

​		对象名.类方法名()

​		前提 ：满足访问修饰符的访问权限和范围

​	经典使用场景 

​		当方法 中不涉及到任何对象或其成员时，则可以将其设置为静态方法，提高开发效率

​		不想创建一个实例，也可以调用某个方法时，非常合适

​	使用细节

​		类方法和普通方法都是随着类的加载而加载，都将结构信息存储在方法区，类方法没有this参数（不能使用this），普通函数隐含this参数

​		类方法可以通过类名和对象名来调用

​		普通方法和对象有关，需要通过对象名来进行调用，不可使用类名调用

​		静态方法中不运行使用和对象有关的关键字 ： this super，普通方法可以使用

​		静态方法只能访问静态变量和静态方法

​		普通方法可以访问普通变量和静态变量

​	静态方法只能访问静态成员，非静态方法可以访问静态和非静态成员（必须遵守访问修饰符的访问范围和限制）

### main方法的语法

​	main方法是Java虚拟机调用的

​	Java虚拟机需要调用main方法，所以该方法必须是public

​	Java虚拟机执行main方法时，不必创建对象，所以是static

​	该方法接受一个String 类型的数组参数，该数组保存执行Java命令时传递给所运行类的参数

​	Java 执行程序 参数1 参数2 参数3....

​	提示 ：main方法中，可以直接调用main方法所在类的静态成员，但不能访问非静态成员，必须先创建一个对象实例，通过这个对象实例来完成访问

### 代码块/初始化块

​	属于类中的成员，类似于方法，将逻辑语句封装在方法体中，通过{}包围起来

​	但与方法不同，没有方法名，参数，返回值，只有方法体，不能通过对象或类显示调用，而是加载类或创建实例对象时，隐式调用

​	基本语法 ：

​		[修饰符] {代码};

​		修饰符 是可选的，使用也只能写 staitc

​		分两种，使用static修饰的为静态代码块，没有static修饰的为普通代码块

​		逻辑语句可以写任何逻辑语句（方法可以怎么写，里面就可以怎么写）

​		；可以省略，但建议带上 

​	理解 ：

​		相当于另一种形式的构造器（构造器的补充机制），可以实现初始化操作

​		使用场景 ：当多个构造器含有多个重复语句时，可以抽取到初始化块中，提高代码重用性

​		代码块的调用顺序优先于构造器

​	细节 ：

​		static代码块 ： 静态代码块，作用：对类进行初始化，随着类的加载而执行，并且**只会执行一次**，如果是普通代码块，每创建一个对象就是执行一次

类什么时候被加载 ：

​	创建对象实例时

​	创建子类对象实例时，父类将会被加载

​	使用类的静态成员时

​		普通代码块将会在创建对象实例时，被隐式调用，创建一次，调用一次。当执行类的静态成员时，普通代码块将不会执行

​		创建一个对象时，在一个类的调用顺序 ：

​			调用静态代码块和静态属性初始化 ：两个优先级一致，若存在多个静态代码块和静态属性初始化，按照定义顺序来调用

​			调用普通代码块和普通属性初始化 ： 两个优先级一致，存在多个，按定义顺序执行

​			调用构造方法

​		构造器的最前面其实是隐含了super()和调用本类的普通代码块

​		创建一个子类实例对象时，静态代码块、静态属性初始化、普通代码块、普通属性初始化、构造函数调用顺序：

​			父类静态代码块、静态属性初始化（优先级一致，看定义顺序）

​			子类静态代码块、静态属性初始化（优先级一致，看定义顺序）

​			父类普通代码块，父类普通属性初始化（优先级一致，看定义顺序）

​			父类构造器

​			子类普通代码块，子类普通属性初始化（优先级一致，看定义顺序）

​			子类构造器

​		静态代码块只能调用静态成员，普通代码块能

### 设计模式 

​	静态成员的经典使用

​	是在大量的实践中总结和理论化之后优选的代码结构，编程风格以及解决问题的思考方式

​	单例模式 

​		采取一定方法保证在整个软件运行过程中，对于某个类，只存在一个对象实例，并且该类只能提供一个取得其对象实例的方法

​		方式 ： 饿汉式   懒汉式

​		饿汉式 ：

​			类一旦加载，对象就被创建了，就不管会不会使用这个对象实例，都会创建出来（在单例模式中，对象是重量级的，如果创建不使用会造成资源的浪费）

​			 构造器私有化

​			类内部创建对象(静态)

​			向外暴露一个静态的公共方法 ： getInstance 

​		懒汉式 ：

​			只会等到你要使用这个对象实例，他才会创建出来

​			 构造器私有化

​			类内部创建对象(静态)（不进行赋值操作，）

​			向外暴露一个静态的公共方法 ： getInstance（只有使用时才会创建一个对象）

​		区别 ：

​			创建对象时机不同 ：饿汉在加载类信息时创建对象，懒汉在使用对象时才会创建对象

​			饿汉没有线程安全问题，懒汉有

​			懒汉没有资源浪费问题，饿汉有

### final

​	修饰类、属性、方法、局部变量

​	防止类被继承、方法被重写、属性值和局部变量被修改

​	细节 

​		final修饰的属性又称为常量（可以作为函数形参），一般采用XX_XX_XX形式命名

​		final修饰的属性定义时必须赋值，可以在定义时赋值、构造器中赋值、代码块中赋值

​		如果final修饰的属性是静态的，只能在定义时赋值，静态代码块中赋值

​		final类不能继承，但可以实例化对象

​		如果类不是final，但含有final方法，虽然方法不能重写，但可以被继承

​		一般来讲，当一个类已经被final修饰，没有必要将方法也使用final修饰（可以，但没必要）

​		final不能修饰构造器

​		final 与static 搭配使用时，效率更高，不会引起类的加载，底层实现了优化处理

​		包装类： Integer 、Boolean 、String、Double...都是final类

### 抽象类

​	当父类的某些方法，需要声明时，但又不确定如何实现时，可以将其声明为抽象方法，则这个类就是抽象类

​	当一个类的方法无法确定时，可以使用abstract来修饰该方法，使其成为抽象方法，并使用abstract来修饰该类，使其成为抽象类，抽象类一般会被继承，抽象方法将会通过子类来实现

​	抽象方法 ： 就是通过abstract修饰的没有方法体的方法；访问修饰符 abstract 方法名（形参）；没有方法体！！

​	抽象类  ： 访问修饰符 abstract 类名 {}

​	抽象类更多再与设计，让子类继承并实现抽象类

​	细节 

​		抽象类不能进行实例化

​		抽象类不一定要包含abstract方法，抽象类可以没有abstract方法，还可以有实现的方法

​		一旦一个类有了抽象方法，则这个类必须使用abstract修饰

​		abstract只能修饰方法和类，不能修饰属性

​		抽象类可以有任意成员

​		一个类继承一个抽象类时，必须实现抽象类的所有抽象方法（有一个方法体就行，里面不加东西无所谓），除非这个类也是一个抽象类 

​		抽象方法不能使用private、final和static 所修饰（三者与重写相违背,static 与重写无关，且无法进行重写）

​	模板设计模式（抽象类使用场景）

​		在父类中定义方法来确定整个程序的执行流程，然后提供抽象方法，让子类来实现具体的操作步骤



### 接口（interface）

​	给出一些没有实现的方法，将其封装到一起，到某个类要使用时，再根据具体情况将方法写出来 (接口类也指接口)

​	语法 ： 

​		interface 接口名 { 属性、方法（抽象、默认实现方法、静态方法） }

​		class 类名 implements 接口 { 本类成员 ，必须实现接口中的抽象方法（没有方法体的方法，再接口中，abstract可以省略不写） }

​	jdk7.0前，接口中的所有方法都没有方法体，即全部都是抽象方法

​	jdk8.0后（包含8），接口中可以有静态方法，默认方法（需要使用 default 来修饰该方法），即接口中可以有具体方法的实现

​	细节 

​		接口不能实例化

​		接口中的所有方法都是public，抽象方法可以不用写abstract

​		一个普通类实现接口，就必须j将该接口的所有方法都实现

​		抽象类实现接口，可以不实现接口中的抽象方法

​		一个类可以实现多个接口，接口通过 ， 隔开

​		接口的属性只能为final，等价于public static final ，访问属性为 接口名.属性

​		接口不能继承于其他类，但可以**继承**（不是实现）多个其他接口

​		接口的修饰符只能由public 或默认修饰（与类一致）

​	接口与继承类

​		实现接口是对Java单继承的补充

​		子类继承于父类时，就自动拥有了父类的功能，如果子类还需要进行扩展，可以通过实现接口的方式进行扩展

​		本身就有的就是继承，实现是通过学习

​	不同 ：

​		解决问题不同 ： 

​			继承解决代码复用性和可维护性

​			接口设计各种规范，让其他类来进行实现，更加灵活

​		灵活性 ： 

​			继承必须是 is - a 的关系，而接口只需满足 like - a （像...）

​		接口一定程度上实现代码的解耦（接口规范性 + 动态绑定）

​	接口的多态特性

​		多态参数

​			当形参是一个接口类型时，可以接受任何实现该接口类创建的实例对象（接口类型的变量，可以指向实现了该接口的类的实例对象）

​		多态数组

​			接口类型的数组(多态数组) (可以存放实现了该接口类的实例对象)

​		多态传递

​			当一个接口B继承于另一个接口A，此时有一个类实现了接口B，那么就相当于这个类也实现了接口A

类的成员 ：属性、方法、构造器、代码块、内部类（重、难）

内部类（重难点）

​	一个类的内部中又完整了另一个类的结构，被嵌套的类就称为内部类，嵌套其他类的类被称为外部类，与外部类平级的没有嵌套其他类的称为外部其他类

​	最大特点：可以直接访问私有属性，体现类与类之间的包含关系

​	4种内部类

​		定义在外部类局部位置 （方法上...） 

​			局部内部类（有类名）

​			匿名内部类（无类名，重点）

​		定义在外部类的成员位置上

​			成员内部类（不用static修饰）

​			静态内部类（使用static修饰）

​	局部内部类

​		通常在方法上，可以直接访问外部类的所有成员，包括私有属性

​		局部内部类不能被访问修饰符所修饰，但可以被final修饰，使其不能被继承

​		本质还是一个类

​		作用域 ： 仅仅在局部内部类所在的方法或代码块中

​		外部类使用局部内部类，在方法（代码块）中去创建局部内部类的实例对象，再通过实例对象来完成调用

​		外部其他类不能访问局部内部类（本来就是一个局部变量）

​		当外部类与内部类的成员重名时，采用就近原则，如果想直接访问外部类成员 ，采用外部类.this.成员（外部类.this 就是一个对象，谁调用就是谁）

​	匿名内部类（！！！！）

​		本质是一个类，还是处于外部类的局部，没有类名字（系统分配名字，看不到罢了），同时还是一个对象

​		基本语法 ：

​			new 类或接口 （参数列表） {}

​		引入 ： 当我们要使用一个接口并创建一个对象时，传统上是直接创建一个类来实现该接口，并创建该类的实例对象，

​			但问题来了 ：如果我们只会使用一次这个类，用完了就不用了，那么按照传统的实用就不太合适了，于是匿名内部类就来了

```
基于接口
IA tiger = new IA() { //接口实现匿名内部类
	重写IA中的抽象方法
};
编译类型 ： IA  运行类型就是 ： 匿名内部类 （系统分配类名 ： 外部类 + $1） 
底层在创建了匿名内部类后会立马创建一个对象实例并返回给相关引用
匿名内部类返回实例后就会消失
底层匿名内部类实现 ： 
class XXXX implements IA {
	重写IA中的抽象方法
}
基于类
Father father = new Father(形参列表){
		重写Father 中的方法（如果Father是抽象类，则必须全部实现Father中的所有抽象方法）
};
编译类型 ： Father  运行类型 ： 外部类$1;
底层匿名内部类实现 ：
class XXXX extends Father{
	重写Father 中的方法（如果Father是抽象类，则必须全部实现Father中的所有抽象方法）
}
需要注意的是 ：
	形参列表将会传递给Father的构造器，而匿名内部类无法重写Father的构造器！
	Father father = new Father(); 与Father father = new Father(){};
	两者区别 ：前者就是Father类创建实例，运行类型为father，后者为基于father类创建匿名内部类，运行类型为 外部类$1
```

​	细节 

​		匿名内部类既是一个类，也是一个对象，因此调用一个方法有两种方法

​			使用引用接受，再通过引用调用 ； 直接调用

​		可以直接访问外部类的所有成员 （访问形式 ： 直接访问，）

​		匿名内部类不能添加访问修饰符（因为是一个局部变量）

​		作用域在所在的方法和代码块，并且使用一次就没了	

​		外部其他类无法访问到匿名内部类

​		当外部类与匿名内部类的成员重名时，采用就近原则，如果想直接访问外部类成员 ，采用外部类.this.成员 （外部类.this 就是一个对象，谁调用就是谁）

​	引用场景 

​		当作实参直接传递，简洁高效（相互不影响，不会一直存在）

成员内部类 

​	定义在外部类的成员位置，并且没有static修饰

​	可以直接访问外部类的所有成员，包括私有

​	可以添加任何访问修饰符，因为本质是一个成员

​	内部类访问外部类成员 ： 直接访问 

​	外部类访问内部类成员 ： 创建内部类实例对象，再访问

​	外部其他类访问内部类 ：

​		外部类.内部类  引用名 = 外部类实例.new 内部类名()

​		在外部类提供一个方法，返回内部类实例

​		new 外部类(). new 内部类()  相当于第一种形式

​	当外部类的成员与内部类的成员重名时，将遵循就近原则，如果想要访问外部类的成员，使用 ： 外部类.this.成员名

静态内部类 

​	定义在外部类的成员位置，使用static修饰

​	可以直接访问外部类的静态成员，不能访问非静态成员 （静态内部类访问外部类）

​	可以添加任何访问修饰符

​	作用域为整个外部类体

​	外部类访问静态内部类 ： 创建静态内部类对象进行访问

​	外部其他类访问静态内部类 ：

​		直接通过类名来进行访问（要确保符合访问权限） 外部类.内部类  引用 = new 外部类.内部类（）

​		编写方法返回静态内部类 （静态方法也行） （如果不想创建外部类实例对象，就可以通过静态方法来返回静态内部类）

​	当外部类的成员与内部类的成员重名时，将遵循就近原则，如果想要访问外部类的成员，使用 ： 外部类.成员名

```
/**
 * @author XXX
 * @version 1.0
 */在idea中自动生成这段代码 ：文件 - 编辑器 - 文件和代码模板 -include，加上就行
```

## 枚举与注解

### 枚举（enumeration，enum）

​	将具体的对象一个一个列举出来，就是一个枚举类

​	枚举就是一种常量的集合（一组特殊的类，里面包含一组有限特定的对象）

实现方式 

​	自定义枚举  

​		私有化构造器 ，使其无法通过构造器创建新的对象 

​		取消set方法，防止修改对象属性（枚举对象是只读 ）

​		在类的内部直接创建固定对象实例（static 、final、public 向外暴露对象）(访问就是类.对象名 )

​		枚举对象名通常全部使用大写（常量命名规范），根据需要，可以有多个属性

​	enum关键字实现枚举

​		使用enum代替class

​		使用 常量名(形参列表) 代替 public static final 类名 常量名 = new 类名(形参列表)  形参列表中的形参还会传递给构造器

​		多个常量对象使用 , 分隔

​		常量必须放在枚举类最前面

​	细节 

​		使用enum开发一个枚举类时，该类默认继承于Enum类，并且该枚举类还是一个final类型 （javap）

​		如果我们使用一个无参构造器来创建常量对象，则可以省略（），即 常量名

​		常量对象的匿名内部类 ：枚举常量后面的 `{}` 是在为该常量创建一个匿名内部类，这个内部类负责实现接口中的抽象方法，这是 Java 枚举类型支持的一种特殊语法

​	Enum常用方法 ：

​		name() :返回 一个枚举对象的名字

​		ordinal() : 返回一个枚举对象的编号

​		values ： 返回一个枚举类型数组，里面存放了所有的枚举类型对象

​		valuesOf() ： 接受一个字符串，将其转换为一个枚举对象（前提是这个字符串与枚举对象名字相等，否则报错）

​		compareTo() ： 接受一个枚举对象，比较调用该方法的枚举对象与接受的枚举对象的编号，返回两者的差值

​	细节 

​		类使用enum关键字后，隐式继承Enum类，不能再继承其他类（单继承机制）

​		enum类可以实现接口 enum 类名 implements 接口名

​	for()增强 ： 语法 ： for(类型  引用名 ： 数组){ 循环体 }  类型与数组类型一致   

​		执行流程 ： 依次从数组中取出一个元素，将其赋值给引用名，然后执行循环体，直到数组遍历完停止执行 

### 注解（Annotation）/ 元数据（Metadata）

​	注解 ： 被称为元数据，用于修饰解释 包、类、方法、属性、构造器、局部变量等数据信息

​	和注释一样，不影响程序逻辑，但注解可以被编译或运行，相当于嵌入在代码中的补充信息

​	JavaSE 中，注解往往是用于标记过时功能，忽略警告等，JavaEE 中，用于配置应用程序的任何切面，代替Java EE 旧版中所遗留的繁冗代码和 XML配置等

​	使用Annotation 时，在其前面增加 @，并将Annotation当作一个修饰符使用，用于修饰它支持的程序元素

​	基本Annotation ：

​		@Override ： 限定某个方法，是重写父类方法，该注解只能用于方法（不能修饰其他类，包、属性等）

​					如果不写@Override，结果还是父类方法的重写

​					写了@Override,编译器会主动检查是否重写了父类的方法，是就编译通过，不是就编译错误，起到语法校验

​		@Deprecated ： 用于表示某个程序元素（类、方法..）已经过时，即不推荐使用，但是还是可以使用的

​					可以修饰方法 、 包、 字段、 参数 、 类 ....

​					可以做到新旧版本的兼容和过渡

​		@SuppressWarnings : 抑制编译器警告

​					程序可以运行，但是编译器会使用下划线提示一个警告

​					如果不想显示这些警告，可以通过@SuppressWarnings来抑制这些警告

​					在{""}中，可以加入你想要抑制的警告信息,all 是抑制所有的警告信息

​					SuppressWarnings作用范围与放置位置有关(语句、方法、类)

​					 修饰类、字段、方法、参数、构造器...传递一个字符串数组，表明可以接受多个抑制信息



​	@interface的说明 ： 表示是一个注解类，并不表示接口（jdk1.5加入）

​	@Target ：是修饰注解的注解，为元注解

​	元注解 

​		修饰注解的注解

​		Retention : 指定注解的作用范围

​				@Retention包含一个RetentionPolicy类型的成员变量，使用该元注解必须为该value成员变量指定值

​				RetentionPolicy.SOURCE ： 编译器使用后，直接丢弃这种策略的注解（Java源码上生效）

​				RetentionPolicy.CLASS ： 编译器使用后，将注解保留到class文件，运行时，JVM不会保留注解，这是默认值（一直到class文件上）

​				RetentionPolicy.RUNTIME ： 编译器使用后，将注解保留到class文件，运行时，JVM会保留注解，程序可以通过反射获取该注解

​		Target ： 指定注解使用的地方

​				也包含一个名为value的成员变量，里面指明可以使用的位置

​		Documented ： 指定注解是否会在javadoc上体现，注解会不会显示在javadoc文档上

​		Inherited ：子类会继承父类的注解 ，被其修饰的注解将会拥有继承性

## 异常Exception

​	异常 ： Java语言中，将程序执行中发生的不正常现象(语法错误和逻辑错误不是异常)

​	分类 ：

​		Error（错误） ：是严重错误，程序崩溃

​		Exception（异常） ： 运行时异常（程序运行时，发生的异常）

​						    编译时异常（编译时，编译器检查出来的异常）

异常体系图

​	虚线  ：实现接口 ，实现 ： 继承类

​	小结 

​		运行时异常，编译器是检查不出来，一般是编程时的逻辑错误，程序员应该避免，RuntimeException类及其子类都属于运行时异常

​		运行时异常不需要进行处理（太普遍了，会对程序可读性和运行效率产生影响）

​		编译时异常 ：编译器要求必须处理的异常

​	常见运行时异常

​		NullPointerException : 空指针异常 当程序试图在使用对象的时候使用了null，就抛出该异常

​		ArithmeticException :  出现异常的运算条件时，抛出该异常（除0）

​		ArrayIndexOutOfBoundsException : 数组索引为负数或者大于等于数组长度时，抛出该异常		

​		ClassCastException ： 试图将对象强制转化为不是实例的子类时，抛出改该异常

​		NumberFormatException : 数字格式不正确异常 ，将一个字符串转换为数值类型时，但字符串不能转成适当格式时抛出异常

​	常见编译异常

​		SOLException : 操作数据库时，查询表可能发生异常

​		IOEException ：操作文件时，发生异常

​		FileNotFoundException ： 操作一个不存在的文件

​		ClassNotFoundExceotion ：加载类，类不存在

​		EOFException ： 操作文件，到文件末尾，发生异常

​		IllegalArgumentException : 参数异常（命令行参数） 

​	异常处理 

​		发生异常时，对异常的处理方式

​		try - catch -finally ： 程序员在代码中捕获异常，自行处理  (idea 快速生成 ctrl + alt + T )

​		throws ： 将发生异常抛出，交给调用者（谁调用，谁处理）处理，最顶级的处理者为JVM（处理异常信息 ： 简单暴力，直接输出异常信息，中断程序）。	当发生异常后，没有try-catch-finally或者没有显示throws，将会默认给其添加一个隐式的throws		

​	try -catch方式 ：

​		基本语法 ：

​			try { 可疑代码 }catch(Exception e) { 异常处理 } （没有finally也是可以的）

​		细节 

​			如果发生异常，则异常发生后面的代码不会执行，直接进入到catch块

​			如果没有异常发，则顺序执行try的代码块，不进入catch

​			如果希望不管是否发生异常，都想要执行某段代码（关闭连接，释放资源），则使用finally

​			可以存在多个catch语句，捕获不同的异常（执行不同的业务处理），要求父类异常在后，子类异常在前，如果发生一个异常，将自会匹配到一个catch 

​			可以使用 try-finally（执行一段代码，不管是否发生异常，都必须执行某个业务逻辑），这种就是相当于没有捕获异常，程序会直接崩掉（但还是执行finally）

​		当一个方法体内部使用try-catch-finally来处理异常时，即使catch捕获到异常，并在catch内部执行了return语句，并返回了一个值，但并不会立马跳出方法，继续执行finally中的代码，如果这个finally也有return语句，将会对catch的return进行覆盖，返回finally中的值

​		如果finally中没有返回值，并修改了捕获了异常的catch中的返回值，则最终返回的值为之前的返回值（会使用临时变量进行存放返回值，然后返回临时变量的值）

throws 方式 ：

​	语法 ： 方法（） throws  异常,异常.....

​	如果一个方法可能产生某种异常，但并不能确定如何处理这种异常，则此方法应显示地声明抛出异常，表示该方法将不会处理这些异常，由**方法的调用者负责处理**

​	在方法声明中用throws语句可以声明抛出异常列表，throws后面的异常类型可以是方法中产生异常的类型或者其父类

​	细节 

​		对于编译异常，必须使用try-catch或throws处理

​		对于运行异常，程序没有处理（即没有显示处理），将会默认使用throws处理

​		子类方法重写父类方法时，对于异常处理规定有以下要求 ： 子类抛出的异常处理类型要么与父类异常处理类型一致或者是父类异常的子类

​		在throws过程中，如果有方法try-catch，就相当于异常处理，不需要再选择throws （二选一）

​		当一个方法主动抛出一个异常时，该异常将会交给调用该方法的调用者来处理这个异常，如果抛出了编译异常，就必须要求调用者通过try-catch或者继续抛出throws来解决这个编译异常，否则将会包错；如果抛出了运行异常，如果调用者不进行处理也可以（默认处理机制throws）

自定义异常

​	定义类 ： 自定义类名 继承Exception(属于编译异常)、RunTimeException（属于运行异常）（一般继承于RunTimeException，成为运行异常，可以使用默认处理机制）

throw 与 throws 的区别

## 常用类

### 包装类Wrapper

​	包装类 ： 针对八种基本数据类型相应的引用类型 (可以调用相应的方法)

​	包装类与基本数据类型的转换（装箱和拆箱）

​		装箱 ： 基本数据类型转换到包装类   拆箱 ：包装类转换到基本数据类型 （JDK5前是手动装箱，JDK5后为自动装箱）

```
	int 与 Integer 的转换 
	int n1 = 10;
	Integer integer1 = Integer.valueOf(n1); // 装箱  一个弃用的方法 ： Integer integer1 = new Integer(n1); (9~弃用并标记移除)
	int n2 = integer1.intValue(); // 拆箱
	
	自动：
	int n2 = 10;
	Integer integer2 = n2; // 底层还是valueOf()
	int n3 = integer2; // 底层是 intValue()
	（其余类型一致）
	
	Integer 与 String 的转换
	Integer i = 10; //都不会改变原来integer类型
	String str1 = i + ""; //1
	String str2 = i.toString(); //2
	String str2 = String.valueOf(i) //3 String.valueOf 是接受一个Object类型 ,并将其转换为字符串（可以借此将基本类型转为字符串）
	
	String str3 = "1234";
	Integer i2 = Integer.parseInt(str3);
	Integer i3 = new Integer(str3) // 9~弃用并标记移除
	
Integer 和 Character 的常用方法 
Integer.MIN_VALUE  ： 返回最大值
Integer.MAX_VALUE ： 返回最小值

Character.isDigit() ： 判断字符是不是数字
Character.isLetter() ： 判断字符是不是字母
Character.isUpperCase() ： 判断字符是不是大写
Character.isLowerCase() ： 判断字符是不是小写
Character.isWhitespace() ： 判断字符是不是空格
Character.toUpperCase() ： 将字符转换为大写
Character.toLowerCase() ： 将字符转换为小写
	
```

​		Integer.valueOf()  :  该方法再装箱时，会判断数值是否再在 -128 ~127之间，如果是，将直接从数组中返回对应值，如果不在，将主动新建一个对象并返回（return new Integer(i)） 

### String类

​	String对象用于保存字符串（一组字符序列）

​	字符串常量对象是用双引号括起的字符序列 ， 使用Unicode编码，一个字符两个字节

​	String类实现了两个接口 ： Serializable 和 Comparable ，前者可以使String对象进行串行化（网络传输），后者可以是String对象进行相互比较

​	String中有属性 ： private final char value[] ：用来存放字符串内容 （jdk9+后改为byte[],逻辑类似）

​	value被final修饰，表示不可修改，但是这个不可被修改是指指向的地址（一个字符数组）不可进行修改，但地址中的内容（数组存放的内容）可以进行修改

​	整体上String也是一个不可变类，然后对String的修改会导致创建并使value指向一个新的字符串

​	常用构造器 ：new String() ; new String(String original) ; new String(char[] a); new String(char[] a,int startIndex,int count); new String(byte[] b)

​	创建方式 ：

​		直接赋值 ：直接在常量池中查找是否含有该字符串，有则直接指向该字符串，没有则在常量池中创建一个字符串并指向该字符串

​		调用构造器 ： 先在堆中开辟一块空间，然后堆中的value指向常量池中的对应字符串（有就直接指向，没有就创建再指向），最后将堆中的地址返回给引用

intern() ：最终返回的是常量池中存放相应字符串的地址（没有就会创建出来再返回地址）

对于 String a  = "hello" + "abc";这条语句，编译器会自动优化，使其等价于 ： String a = "helloabc"。即该语句会生成一个对象

编译器不傻，会判断常量池中的对象是否有引用指向，没有就不创建，有就创建一个

```
        String a = "hello";
        String b = "abc";
//        1.先创建一个 StringBuilder sb = StringBuilder();
//        2.执行 sb.append("hello");
//        3.再执行 sb.append("abc");
//        4. String c = sb.toString();
//        最后就是c指向了堆中的一个对象(String),该对象的value并不会指向常量池中的"helloabc"(并且常量池中
//        也没有"helloabc"这个字符串)，而是指向自身存放字符序列的数组
        String c = a + b;  // 创建StringBuffer对象，不断通过append将字符串加进去，存放到堆中
//        当调用intern()方法后，直接把当前堆中这个 String 对象引用放入常量池。
//        常量池的引用也将会指向堆中的String对象(新增字符串 ： "helloabc")
        System.out.println(c == c.intern()); // true
//        String d = "helloabc";
//        System.out.println(c == d);
    }
```

常量相加看池，变量相加看堆，final 特殊编译归池

intern() → 把堆中字符串注册到常量池（JDK7+ 不复制）,并返回字符串在常量池的索引



​	常用方法 

​		equals() 方法

​		equalsIgnoreCase() 忽略大小写比较内容

​		length() 

​		indexOf() : 获取字符或字符串在指定字符串中第一次出现的索引位置，找不到返回-1

​		lastIndexOf() ：获取字符或字符串在指定字符串中最后一次出现的索引位置，找不到返回-1

​		substring() : 截取指定范围的子串，一个参数就是从该索引到头，两个索引就是截取两个索引之间  [  )

​		trim() ：去前后格

​		 toUpperCase() : 转大写 (不会修改原字符串)

​		toLowerCase() : 转小写(不会修改原字符串)

​		concat() ：拼接字符串

​		 replace() : 替换字符串中的字符

​		split() : 分隔字符串，对于某些分隔字符，需要进行转义 ： | 、\\...  在对字符串进行分割，如果有特殊字符，需要加入转义符 ： /

​		toCharArryay() : 转换成字符数组

​		compareTo() 比较两个字符串的大小，前者大返回正数，后者大返回负数(前字符减去后字符)，相等为0

​			长度相同，并且每个字符都相同，返回0	

​			长度相同或不相同，在比较时，可以区分大小写，就返回 ： c1 - c2(c1 != c2)

​			如果前面的部分都相同，就返回str1.len - str2.len

​		format() 格式字符串  %s(字符串替换) %d(整数) %.2f(小数，并保留2位小数点，四舍五入) %c(char) : 都是占位符，由后面的变量替换

### StringBuffer 类

​	对String的增强，代表可变的字符序列，可以对字符串内容进行增删

​	主要使用在多线程

​	很多方法与String相同，但StringBuffer是可变长度，同时StringBuffer是一个容器

​	直接父类 ： AbstractStringBuilder, 存在属性 ：byte[] value 存放字符序列，没有final修饰

​	实现了Serializable 和 Comparable 接口，可以实现串行化 和比较

​	StringBuffer 被final修饰，无法被继承

​	StringBuffer 与 String的区别 ：

​		String保存的是字符串常量，不能被修改，每次更改都是改地址，创建新对象，效率低 （private final byte value[]）

​		StringBuffer 保存字符串变量，里面的值可以被修改，每次更改的是内容，不用每次更新地址/创建新对象（数组空间不够，才进行扩展修改地址/创建新对象）,效率高 （byte value[]，并存放在堆中）

​	StringBuffer 与 String 的相互转换

​		String 转 StringBuffer

​			StringBuffer构造器接受一个字符串 ； StringBuffer的append方法（实例方法），参数为接受字符串

​		StringBuffer 转 String

​			String的构造器接受StringBuffer； StringBuffer的toString方法

​	常用方法

​		append(String str) ： 在原先字符序列增加字符序列 ,当传递一个空对象时，主动转换为“null”字符串

​		delete(int a,intb) ： 删除索引在[a,b)之间的字符

​		replace(int a,int b,String str) ：将索引在[a,b)之间的字符序列替换成str

​		indexOf(String str) ：找出指定字串在字符串第一次出现的索引,找不到 ： -1

​		insert(int index,String str) ：在指定索引位置插入指定字符串，索引后的内容往后移

​		length() ： 返回长度

### StringBuilder类

​	一个可变的字符串序列，提供与StringBuffer兼容的API，但不保证同步（不是线程安全），是StringBuffer类的一个简易替换，**用在字符串缓存区被单个线程使用时**，建议使用该类，比StringBuffer更快（大多数实现上）

​	主要操作为 append 和 insert，可以重载这些方法，以接受任意类型数据

​	大体与StringBuffer一致

​	字符序列仍然存放在父类AbstractStringBuilder的byte value[]中(堆)

​	StringBuilder 的方法，没有做互斥处理，没有synchronized 关键字，因此在单线程的情况下使用StringBuilder

String 、StringBuffer、StringBuilder比较

​	StringBuffer 和 StringBuilder 非常相似，均是可变字符串序列，方法一致

​	String ： 不可变字符串序列，效率低，但复用性高(常量池不会出现相同字符串)

​	StringBuffer ：可变字符串序列，效率较高(增加，删除)，线程安全（方法都由 ： synchronized  修饰）

​	StringBuilder ：可变字符串序列，效率最高，线程不安全

​	String ： 在对String类型字符序列进行操作时，多次执行修改内容的操作会导致大量副本字符串对象（丢弃原有）留存在内存中，降低效率，极大影响效率

​	因此，当我们对String做出大量修改时，不使用String

使用 ： 

​	当字符串存在大量修改的操作，一般使用StringBuffer 和StringBuilder

​	当在单线程的情况下大量操作时，使用StringBuilder

​	当在多线程的情况下大量操作，使用Stringbuffer

​	如果对字符串很少修改，被多个对象引用，是用String

### Math类

​	执行基本数学运算的方法（大部分是静态方法）

​	abs ：绝对值

​	pow(int a,int b) : 求幂(a 的 b 次幂) (double)

​	ceil() : 向上取整，返回大于等于该参数的最小整数 (double)

​	floor() : 向下取整，返回小于等于该参数的最小整数(double)

​	round() : 四舍五入，floor(参数 + 0.5)

​	sqrt() : 求开方

​	random() : 随机数 ([0,1))  ：生成一个a - b 之间的数 ： Math.random * (b - a + 1) + a

​	max()最大值 、 min()最小值

### Arrays类

​	一系列静态方法，管理和操作数组

​	 toString() : 返回数组的字符串形式

​	sort() : 排序数组 分默认排序(传递数组就行，从大到小)和定制排序

```
定制排序 ： 传入一个接口Comparator实现定制排序(一个实现该接口的匿名内部类)
//                  两个参数 ： 一个是待排序数组，一个就是实现了Comparator接口的匿名内部类(实现compare方法)
//        执行流程 ：
//        先是Arrays.sort()方法，
//        进入TimSort类的private static <T> void binarySort(T[] a, int lo, int hi, int start,
//        Comparator<? super T> c)
//        代码执行binarySort方法时，会根据动态绑定机制执行我们传入的匿名内部类compare();
//        然后就是根据compare()的返回值来决定排列顺序
//        接口编程 + 动态绑定 + 匿名内部类 的综合使用
```

​	binarySearch() : 通过二分搜索进行查找，并返回下标，要求数组为有序数组

​		有序就行(大到小，小到大)，如果是无序的，将不能使用binarySearch

​		如果数组不存在该元素，返回负数(-(low + 1) 即这个数如果存在的话，下标+1的负数).

​	copyOf() : 数组元素的复制

​		从integers 数组中拷贝 integers.length 个元素到newArray中 （底层使用System.arraycopy()）

​		如果拷贝的长度大于原数组，将会在新数组的后面增加 null，如果长度小于0，抛出异常NegativeArraySizeException

​	fill() : 数组元素填充

​		把指定数组中的元素全部替换成指定元素

​	equals() : 比较两个数组中的元素是不是完全一样

​	asList() : 将一组值，转换为一个list集合

​		list 集合 ：编译类型 ： List(接口)， 运行类型 ： java.util.Arrays$ArrayList (Arrays 中的静态内部类)

### System类

​	exit() ：退出当前程序

​		参数 ：程序退出的状态， 0 表示正常状态

​	arraycopy() ： 复制数组（比较适合底层调用），一般情况下使用Arrays中的copyOf 

​		参数 ： 源数组， 源数组拷贝起始位置，目标数组，目标数组起始位置，拷贝长度

​	currentTimeMillens() ： 返回当前时间离1920-1-1的毫秒数

​	gc() ：运行系统垃圾回收机制

### BigInteger类

​	适合保存比较大的整数

​	在对 BigInteger 进行加减乘除时，应该使用相应方法，不能直接使用符号，可以通过创建一个要操作的BigInteger，再调用相关方法进行运算

​	底层上是将其作为一个字符串，然后再转为BigInteger

### BigDecimal类

​	适合保存精度较高的浮点数

​	整体与BigInteger一样，但是除法上有区别 ，可能抛错

​	当除法发生除不尽时，会抛出一个ArithmeticException错误，此时可以指定保留精度来避免抛错

​	在除法方法后增加 ：RoundingMode.CEILING 来使其自动保留到分子的精度  （BigDecimal.ROUND_CEILING(但是已经弃用)）

### 日期类

​	Date(第一代日期类) 

​		jdk1.0

​		单位毫秒，表事件特定的瞬间 （离1970.1.1 00:00:00 的毫秒数） 

​		获取当前系统时间 ： new Date() 通过创建一个对象获取时间 （此时该时间为国外格式，因此需要对格式进行转换）

​		给定指定毫秒数获取时间 ： new Date(long time) ： 传入一个long类型数值，会返回一个时间

​		转换格式 ： 创建一个 simpleDateFormat 对象 ，通过为构造器传参来指定时间格式

​				需要注意的是，格式的字母是规定好的，不能乱来

​		simpleDateFormat 的方法	

​			format() 方法 ：按照指定的格式将 Date 对象转换为字符串；

​			parse() 方法 ： 将字符串按照指定格式转换为 Date 对象 

```
SimpleDateFormat simpleDateFormat = new SimpleDateFormat("yyyy年MM月dd日 HH:mm:ss E");

String format = simpleDateFormat.format(date);

String format1 = "1996年12月12日 12:12:12 星期一";  // 必须符合 yyyy年MM月dd日 HH:mm:ss E ，否则抛错
Date parse = simpleDateFormat.parse(format1);

```

​	Calendar(第二代日期类)

​		jdk1.1 （引入Calendar后，Date大部分方法被弃用）

​		构造器受保护(protected)，通过getInstance()方法来获取实例对象

​		提供大量方法和字段供用户使用 （通过 实例对象.get(Calendar.字段) 获取相应字段表示的时间） （月份需 + 1 ，月份从零开始）

​		不提供格式化的类，需自行搭配

​	第三代日期类

​		jdk8

​		前两代日期问题 ：

​			可变性 ： 日期和时间这样的类是不能改变的，但calendar可以

​			偏移性 ： Date年份从1900开始，月从0开始（Calendar保持一致）

​			格式化 ：格式化对Date有用，但是对calendar没有用

​			前两代日期也不是线程安全，不能处理闰秒（每隔两天多出一秒）

​		LocalDate ：日期（年月日）

​		LocalTime ：时间 （时分秒）

​		LocalDateTime ： （年月日时分秒）

```
     使用now() 返回表示当前时间日期的 对象
        LocalDateTime date = LocalDateTime.now(); // 日期 + 时间
        System.out.println(date);
        System.out.println("年 :" + date.getYear());
        System.out.println("月 :" + date.getMonth()); // 英文
        System.out.println("月 :" + date.getMonthValue()); // 数值
        System.out.println("日 :" + date.getDayOfMonth());
        System.out.println("时 :" + date.getHour());
        System.out.println("分钟 :" + date.getMinute());
        System.out.println("秒 :" + date.getSecond());

        LocalDate date1 = LocalDate.now(); // 日

        LocalTime date2 = LocalTime.now(); // 时间
        
               //格式化 
               // 创建 DateTimeFormatter 对象 （静态方法 ： ofPattern("对应格式创建")）
               // 转换对应时间对象成字符串 （format 方法）
        DateTimeFormatter dateTimeFormatter = DateTimeFormatter.ofPattern("yyyy-MM-dd HH:mm:ss");
        String format = dateTimeFormatter.format(date);
        System.out.println(format);
        
        //        提供 plus 和 minus 方法来对当前时间进行加减
        LocalDateTime localDateTime = date.plusDays(890); // 增加890
        String format1 = dateTimeFormatter.format(localDateTime);
        System.out.println(format1);

        LocalDateTime localDateTime1 = date.minusMinutes(3456); // 查看3456分钟前的时间
        String format2 = dateTimeFormatter.format(localDateTime1);
        System.out.println(format2)；
```

IDEA小点 ： 在类的图标中，properties 指get，setxx方法中，认为xx是一个属性，并将其列出来

验证正确性 ： 列出正确情况，再取反获取错误情况

## 集合

​	数组缺点 ：

​		长度必须指定，并且无法进行更改

​		必须保存同一类型的数据

​		增加/删除元素较为困难

​	引入集合 ：

​		可以动态保存任意多个元素（类型可以不一致）

​		提供一系列操作元素的方法	

​		添加、删除元素代码更加简洁

### 集合的分类 

​	单例 ： Collection接口的两个重要子接口 ： set 和 List ，其实现子类都是单例集合	

​	双列 ： Map 接口的实现子类都是双列集合

​	关于集合体系图键image文件夹

```
//    单例集合(举个例子)
    ArrayList arrayList = new ArrayList();
    arrayList.add("a"); // 加单个数据的就是单例集合

//    双列集合
    HashMap hashMap = new HashMap();
    hashMap.put("Num1", "b"); // 加两个数据的就是双列集合
```



### Collection 接口实现类的特点

​	collection 实现子类可以存放多个元素，每个元素都可以是 Object 或其子类

​	有的可以存放重复元素，有的不行

​	实现子类有的是有序的（List），有的是无序的（Set）

​	没有直接实现子类，通过子接口的 List 和 Set 实现的

### Collection 常用方法

​	add() 添加单个元素 , 存在自动装箱过程

​	remove() : 删除单个元素 (两种形式 ： 删除指定索引(返回删除对象)，删除指定对象(返回true false))

​	contains() : 查找元素是否存在

​	size() : 获取元素个数

​	isEmpty() : 检查集合是否为空

​	clear() : 清空集合

​	addAll() : 添加多个元素 ，接受实现了Collection接口的类

​	containsAll() : 查找多个元素是否存在

​	removeAll() : 删除多个元素

### Collection 接口遍历元素方式

#### 	使用Iterator（迭代器） 

​		Iterator对象成为迭代器，主要用于遍历Collection集合的元素

​		任何实现了Collection接口的集合类都能获取到一个iterator()方法用于返回一个是实现了Iterator接口的对象（即一个迭代器）

​		Iterator仅用于遍历集合，本身不存放任何东西

​		迭代器的执行原理 ： 

```
通过iterator方法获取一个迭代器对象
Collection list = new ArrayList();
Iterator iterator = list.iterator(); // 获取
while(iterator.hasNext()) { 先通过hasNext()判断是否还有下一个元素
	System.out.println(iterator.next()); //  控制指针下移，返回下移后指针指向的集合元素
}
在调用迭代器的next()方法之前，必须先调用hasNext()方法进行检测，若不调用，并且下一条记录无效，直接调用next() 将会抛出NoSuchElementException

//       快速生成构造器遍历 ： itit (Ctrl + j 查看快捷键生成)

//        当执行完while循环时,next()已经指向了最后的一个元素,再次执行将会抛出错误
//        iterator.next(); // NoSuchElementException
//        因此,想要在遍历一次集合时,想要重置一遍迭代器
  iterator = list.iterator();
        while (iterator.hasNext()) {
            Object next =  iterator.next();
            System.out.println("next = " + next);
        }
```

​	

#### 	增强 for() 循环

​		就是简化版的iterator （底层仍然是迭代器） （快速生成 ： I 大写i）

### List接口和常用方法

​	是Collection接口的子接口

​	List 集合的类的元素是有序的(添加元素和取出顺序一致)，并可以重复

​	List 集合中每个元素都有对应的顺序索引(支持索引)(List 容器中每个元素都对应一个整数型序列号记载其在容器中的位置，可以根据序列号存取容器中的元素)

​	实现 List 接口的类有很多，但常用的为 ： ArrayList Vector LinkedList

​	常用方法

​	三种遍历方法

​		迭代器、增强for()、普通for

#### ArrayList 

​	细节 

​		ArrayList 可以加入多个 null

​		由数组来实现数据存储

​		基本等同于Vector，除 ArrayList 是线程不安全(没有synchronized修饰方法)(执行效率高)；多线程下不建议使用 ArrayList

​	底层结构解读：

​		ArrayList 中维护了一个 Object 类型的数组 ： elementData  transient Object[] elementData transient 表示该属性不会倍序列化

​		当创建一个 ArrayList 对象时，若使用无参构造器，则初始elementData 容量为0，进行第一次添加时，扩容为10，再次扩容时，则扩容1.5倍 

​		如果使用指定大小的构造器，则初始elementDate 的容量为指定大小，如果想要扩容，则扩容1.5倍

#### Vector 

​	底层也是一个对象数组 ： protected Object[] elementData

​	是线程同步的（线程安全），每个操作方法带有synchronized（但这样效率低），因此开发时，想要线程同步安全，考虑 Vector

​	底层结构 ：

​		无参构造器（直接调用有参构造器，赋10） 给10，满后按2倍扩容（其实可以指定每次扩容数）

​		有参构造器（单值），给指定值，满后按指定值2倍扩容

​		上面两个无参都会调用下面的双参构造器，并给最后的值赋值为0

​		双参构造器 ：一个是初始vector的存储数组长度，后面的参数就是每次扩容的空间（为0就是扩2倍）

#### LinkedList

​	底层实现了双向链表和双端队列特点

​	可以添加任意元素（可重复），null 也行

​	线程不安全，没有实现同步

​	底层操作机制

​		LinkedList 底层维护了一个双向链表；

​		维护两个属性 ： first 和 end 指向双向链表的第一个节点（首节点）和最后一个节点（尾节点）

​		每个节点都是 Node 对象，里面维护了 prev 、 next 、 item 三个属性，prev 指向前一个节点， next 指向后一个节点，最终实现了双向链表

​		LinkedList 的元素添加和删除，不通过数组完成，效率相对较高

​	ArrayList 和 LinkedList 选择

​		改查多 ： ArrayList  增删多 ： LinkedList （没有涉及线程并发的情况下，使用）

### Set 接口和常用方法

​		无序（存取顺序不一致），没有索引

​		不允许相同元素重复，最多包含一个null

​		常用方法 

​			继承与Collection，常用方法与Collection一样

​		遍历方式

​			迭代器 、 增强for()循环，不能使用索引方式获取（没有提供 get 方法）

#### 	HashSet

​		实现了 Set 接口

​		底层就是 HashMap

​		底层机制 ：HashMap， HashMap 的底层又是 ： 数组 + 链表 + 红黑树		

​		HashSet 底层添加元素实现

​			底层是 HashMap

​			添加一个元素时，会先得到 hash 值 ，hash 值将会通过转换形成索引值

​			找到存储数据的表 table ，查看该索引上是否已经存放了元素

​			如果没有，直接加入

​			如果有，调用 equals 比较（可以由程序员决定），如果相同，放弃添加，不同就添加到最后

​			JDK8 中 , 一条链表的元素个数到达 8（如果table大小未到，则直接为 table 扩容后树化），并且 table 的大小 大于等于 64，就会转换为红黑树（进行树化）（JDK17保持该特点）

因此，不能添加重复元素的根本原因在于 hash() 得到的哈希值 与 equals() 方法 两个都相同的情况下不能实现添加

```
源码解读
      7: new HashSet()
          public HashSet() {
               map = new HashMap<>();  // 底层就是 HashMap
           }
      8：add()
       public boolean add(E e) { // e : "java"
           return map.put(e, PRESENT)==null; //  static Object PRESENT = new Object()
       }

       put():
       public V put(K key, V value) {
           return putVal(hash(key), key, value, false, true);
       }
       hash(key) 会得到 key 的哈希值，但并不等价与 hashCode() ：h = key.hashCode()) ^ (h >>> 16)

       putVal() : 核心
       final V putVal(int hash, K key, V value, boolean onlyIfAbsent,
          boolean evict) {
           Node<K,V>[] tab; Node<K,V> p; int n, i; // 辅助变量
           // if 判断 table 是不是为空，或者table的大小是不是为0，整体上就是第一次扩容 (16)
           if ((tab = table) == null || (n = tab.length) == 0)
               n = (tab = resize()).length;
           // 求出 存放的 hash 值应该放入 table 的哪个索引位置，并将该位置的对象赋值给 p
           // 继续判断 p 是不是 null 看这个位置是不是空的
           空就创建一个Node对象newNode(hash(判断后面是不是相同的), key, value, null)，放入该位置
           没空就准备放链表
           if ((p = tab[i = (n - 1) & hash]) == null)
               tab[i] = newNode(hash, key, value, null);
           else {
               Node<K,V> e; K k;
               if (p.hash == hash &&
                   ((k = p.key) == key || (key != null && key.equals(k))))
                   //p.hash == hash : 如果当前索引位置上的对象的 hash 与要添加的 key 的哈希值一样
                   //(k = p.key) == key ：当前索引上的对象的 key 与 要添加 key 是同一个对象
                   //(key != null && key.equals(k)) ： 或者不是同一个对象，但是内容相同
                   // 满足，就不加入
                   e = p;
                   // 再判读 p 是不是红黑树，如果是，就调用 putTreeVal 进行添加
               else if (p instanceof TreeNode)
                   e = ((TreeNode<K,V>)p).putTreeVal(this, tab, hash, key, value);
               else {
                 // 依次与该链表中的每一个元素相比较，如果比到最后，都不同，直接加在链表最后面
                       // 添加元素到链表后，立即判断是不是该链表是否已经达到 8 个节点，
                       // 达到了就调用 treeifyBin 对当前链表进行树化
                       // 如果 table 的长度没有到达 64， 就会先对 table 进行扩容后才进行树化
                   // 如果再比较过程中，发现了相同情况，直接跳出 for 循环
                   for (int binCount = 0; ; ++binCount) {
                       if ((e = p.next) == null) {
                           p.next = newNode(hash, key, value, null);
                           if (binCount >= TREEIFY_THRESHOLD - 1) // -1 for 1st
                               treeifyBin(tab, hash);
                           break;
                       }
                       if (e.hash == hash &&
                           ((k = e.key) == key || (key != null && key.equals(k))))
                           break;
                       p = e; // 移动 p 节点
                   }
               }
               if (e != null) { // existing mapping for key
                   V oldValue = e.value;
                   if (!onlyIfAbsent || oldValue == null)
                       e.value = value;
                   afterNodeAccess(e);
                   return oldValue;
               }
           }
           ++modCount;
           if (++size > threshold) // 在第一次扩容中 resize() 方法中确定的临界值
               resize();
           afterNodeInsertion(evict); //HashMap 留给子类去实现的一个空方法
           return null;
       }

*/
```

​	HashSet 扩容机制与 转换为红黑树机制

​		第一次扩容时，将会使 table 扩容为 16；临界值为 table.length * 加载因子（0.75 loadFactor）: 12

​		当 table 数组的元素达到临界值时，会再次扩容 （*2），再次计算临界值

​		只要往HashSet 增加一个节点，不管加在数组还是链表，增加一个节点size + 1

​		单条链表元素个数到达 8 ，并且 table 大小 大于等于 64，才会进行树化，否则仍采取数组扩容机制

#### LinkedHashSet

​	HashSet 的子类 ， 不能添加重复元素

​	底层是 LinkedHashMap , 底层维护一个 数组 + 双向链表

​	LinkedHashSet 是根据元素的 HashCode 决定存放位置，同时使用链表维护元素的次序图（存放与取出是同一顺序），使其看起来是插入保存到

​	底层机制 ：

​		LinkedHashMap 中维护了一个 hash 表和双向链表（有 head 和 tail 分别指向该链表的头部和尾部）

​		每个节点都会有 before 和 after 属性，用于指向其他节点

​		在添加一个元素时，会先求出器 hash 值，再得出索引，确定该元素在 hashtable的位置，并将该元素加入双向链表，已存在就不添加（与 HashSet 一样）

​		这样使得插入的顺序与遍历的顺序一致

​		table 的类型为 : HashMap@Node[],存放的节点类型为 : LinkedHashMap@Entry(Entry 继承了 Node)(多态)

​		扩容和添加机制还是HashSet，唯一区别就是一个双向链表，一个节点可以指向上一个节点和下一个节点

#### TreeSet 

​	最大特点 ：可以排序(传入一个实现了 Comparator 接口的 匿名内部类)

```
TreeSet 底层就是 TreeMap
构造器会把传入的比较器对象传给 TreeMap (TreeSet的底层) 的 comparator 属性
 public TreeSet(Comparator<? super E> comparator) {
     this(new TreeMap<>(comparator));
 }
    public TreeMap(Comparator<? super K> comparator) {
     this.comparator = comparator;
 }

 private V put(K key, V value, boolean replaceOld) {
     Entry<K,V> t = root;
     if (t == null) {
         addEntryToEmptyMap(key, value);
         return null;
     }
     int cmp;
     Entry<K,V> parent;
     // split comparator and comparable paths
     Comparator<? super K> cpr = comparator; // 传入 构造器的匿名内部类的对象
     if (cpr != null) { // 如果没有传入 比较器，将会执行下面的else
         do {
         	// 遍历所有 key ，为当前添加的 key 寻找适当的位置
             parent = t;
             // 动态绑定，直接调用构造器传入的匿名内部类的 compare 方法
             cmp = cpr.compare(key, t.key);
             if (cmp < 0)
                 t = t.left;
             else if (cmp > 0)
                 t = t.right;
             else { // 发现 相等，就返回，不添加
                 V oldValue = t.value;
                 if (replaceOld || oldValue == null) {
                     t.value = value;
                 }
                 return oldValue;
             }
         } while (t != null);
     } else { 
         Objects.requireNonNull(key);
         @SuppressWarnings("unchecked")
         Comparable<? super K> k = (Comparable<? super K>) key; // 使用 key（实现了Comparable 这个接口） 的 比较方法
         do { 
             parent = t;
             cmp = k.compareTo(t.key);
             if (cmp < 0)
                 t = t.left;
             else if (cmp > 0)
                 t = t.right;
             else { // 如果通过比较器比较后两个对象相同(就是比较规则为0,则不会添加这次的元素)
                 V oldValue = t.value;
                 if (replaceOld || oldValue == null) {
                     t.value = value;
                 }
                 return oldValue;
             }
         } while (t != null);
     }
     addEntry(key, value, parent, cmp < 0);
     return null;
 }
```

### Map 接口

​	JDK8 的 Map 特点

​	用于保存具有映射关系的数据 ：key - value (双列元素)(Set 其实也是这样的，value 指常量对象 PRESENT)

​	key 和 value 可以是任意引用类型的对象，会被封装到 HashMap$Node 中(即 Node 对象的 key属性 和 value属性)

​	key 不能被重复，原因与 HashSet 一样，但采用替换机制;

​	value 可以重复

​	key 和 value 都可以为 null，但是 key 只能有一个 null， value 可以多个

​	常用 String 作 key

​	key 与 value 存在单向一对一的关系，通过 key 可以找到对应的 value

```
//        k - v 最后就是存放在 HashMap$Node (node = newNode(hash,key,value,null))
//        k - v 为了程序员的遍历方便，还会创建一个 EntrySet 集合，
//        该集合类型存放的元素类型为 Entry (即实现了Entry 接口类的实例对象)，
//        EntrySet<Entry<k,v>> 即： transient Set<Map.Entry<K,V>> entrySet;
//        entrySet 中，定义的类型就是 Map.Entry,但实际上存放的还是 HashMap$Node
//        因为 HashMap$Node 实现了 Map.Entry
//        当把 HashMap$Node 存放进 EntrySet 时是方便了遍历(Entry 提供了两个方法一次就可以拿到 k 和 v)
//        Entry 中提供了K getKey(); V getValue();两个方法
//        为什么要 EntrySet 这个集合 ： 将底层分散的Node（或其他Entry实现）包装成一个符合集合规范的视图(引用方式)
//        让Map的遍历既能统一、安全，又能屏蔽底层实现细节，这正是 Java 面向接口编程思想的典型体现

//        HashMap中创建的Node节点本身就是Entry接口的实现，因此天然可被视为Entry对象；EntrySet作为视图，
//        通过遍历底层Node并以Entry类型引用它们，实现了对键值对的统一访问，而非主动 “转换” 或 “存放”Entry。

//        keySet()和values()和entrySet()一样，都是视图机制，目的是 “以不同形式访问已有数据，不额外拷贝存储”，
//        keySet() 访问所有的 key; values() 访问所有的value entrySet()则访问所有的 key - value
```

#### 	方法

​		put() : 添加元素

​		remove() : 删除 , 指定 key 或 key 和 value 删除

​		get() : 根据指定的 Key 返回对应的 value

​		set() : 获取当前的元素个数

​		isEmpty() : 判断个数是否为0

​		clear() : 清空所有的键值对

​		containsKey() : 查找键是否存在

​		replace(k,v) : 用新的 value 将指定的 key 对应的 value 替换，如果没有找到 key 将不进行操作

#### 	遍历方式

​		三种遍历方式 : (都可以使用增强 for 循环 和 迭代器)

​			通过 keySet() 获取所有 key, 再通过 get() 方法获取 value

​			通过 Values 获取所有的 value,但是无法获取到 key

​			通过 entrySet() 获取所有的 key - value,这时可以使用 getKey() 和 getValue() 获取 Key 和 Value 或者使用迭代器

#### 	小结	

​		常用实现类 ： HashMap（使用率最高实现类） 、 Hashtable 、properties

​		HashMap 是以 key - value 对的方式来存储数据 （HashMap$Node）

​		key 不能重复，但 value 可以重复， null 可以作 key 或 value

​		添加相同的 key 时， 会覆盖原有的 key - value ，等同于修改 value

​		与 HashSet 一样， HashMap 不保证映射顺序，底层通过 hash 表存储

​		HashMap 没有实现线程同步，因此是线程不安全的

#### HashMap

​	底层机制 

​		jdk7 前为数组 + 链表

​		扩容机制 与 HashSet 完全一样		

```
1.执行构造器 new HashMap()；
    初始化加载因子 ： loadFactor = 0.75
    HashMap$Node[] table = null;
2.执行put() 方法
public V put(K key, V value) {
    return putVal(hash(key), key, value, false, true);
}
3.执行putVal方法
    final V putVal(int hash, K key, V value, boolean onlyIfAbsent,
       boolean evict) {
    Node<K,V>[] tab; Node<K,V> p; int n, i;
    if ((tab = table) == null || (n = tab.length) == 0)
        n = (tab = resize()).length;
    if ((p = tab[i = (n - 1) & hash]) == null)
        tab[i] = newNode(hash, key, value, null);
    else {
        Node<K,V> e; K k;
    // 如果新增的 Node 对象的 hash值与当前 table 表索引位置的 Node 对象的hash 值相等
    // 并且 新增的 Node 对象与当前对象是同一个对象 或者 他们的equals 是相等的
        if (p.hash == hash &&
            ((k = p.key) == key || (key != null && key.equals(k))))
            e = p;
        else if (p instanceof TreeNode) // 判断当前 table 表索引位置的 Node 对象是不是红黑树
          // 按照红黑树的逻辑处理新增的 Node
            e = ((TreeNode<K,V>)p).putTreeVal(this, tab, hash, key, value);
        else { // 如果节点的后面是链表，就进行循环比较
            for (int binCount = 0; ; ++binCount) {
                if ((e = p.next) == null) { // 链表中没有与新增的 Node对象相同，将其加在最后
                    p.next = newNode(hash, key, value, null);
                    // 判断链表树是不是达到8，达到就调用方法进行树化
                    if (binCount >= TREEIFY_THRESHOLD - 1) // -1 for 1st
                    // 不会立即树化，要求链表 达到8，并且table长度达64，如果没有，则进行扩容
                    //否则才会进行树化
                        treeifyBin(tab, hash);
                    break;
                }
                // 发现链表中有相同的，就退出循环不做处理，再进行替换处理
                if (e.hash == hash &&
                    ((k = e.key) == key || (key != null && key.equals(k))))
                    break;
                p = e;
            }
        }
        if (e != null) { // existing mapping for key
            V oldValue = e.value;
            if (!onlyIfAbsent || oldValue == null)
                e.value = value; // 对原来的 value 进行替换
            afterNodeAccess(e);
            return oldValue;
        }
    }
    ++modCount;
    if (++size > threshold)
        resize();
    afterNodeInsertion(evict);
    return null;
}
```

#### Hashtable

​	存放数据的形式 ： k - v 

​	键值都不能为 null ，否则抛出 NullPointerException

​	使用方法基本上和 HashMap 一样	

​	Hashtable 是线程安全的（synchronized），而 HashMap 是不安全的

```
底层分析 ：
    1.底层数组为 ： Hashtable$Entry[] ,初始化为 11  加载因子还是 ： 0.75 临界值算法一样
    2. 键值对 是存放在 Hashtable$Entry 中，注意区分与 Map.Entry 的区别
        private static class Entry<K,V> implements Map.Entry<K,V>
    3.扩容 ： 原大小 * 2 + 1

     public Hashtable() {
        this(11, 0.75f); (数组大小，加载因子)
    }

    public synchronized V put(K key, V value) {
        // Make sure the value is not null
        if (value == null) {
            throw new NullPointerException();
        }

        // Makes sure the key is not already in the hashtable.
        Entry<?,?> tab[] = table;
        int hash = key.hashCode();
        int index = (hash & 0x7FFFFFFF) % tab.length;
        @SuppressWarnings("unchecked")
        Entry<K,V> entry = (Entry<K,V>)tab[index];
        // 看当前 table 上指定索引位置是不是空的 ，是就加上去
        for(; entry != null ; entry = entry.next) {
            if ((entry.hash == hash) && entry.key.equals(key)) {
                V old = entry.value;
                entry.value = value;
                return old;
            }
        }

        addEntry(hash, key, value, index);
        return null;
    }

     private void addEntry(int hash, K key, V value, int index) {
        Entry<?,?> tab[] = table;
        if (count >= threshold) { // 判断达到临界值了没
            // Rehash the table if the threshold is exceeded
            rehash();

            tab = table;
            hash = key.hashCode();
            index = (hash & 0x7FFFFFFF) % tab.length;
        }

        // Creates the new entry.
        @SuppressWarnings("unchecked")
        Entry<K,V> e = (Entry<K,V>) tab[index];
        // 将增加的键值对加上table表，并让其 next 指向原来在该索引上的键值对(原来没有就指空)
        // 插头法，插在头部，不插在尾部
        tab[index] = new Entry<>(hash, key, value, e);
        count++; // table表中的元素数量
        modCount++; // 修改次数
    }

    protected void rehash() {
        int oldCapacity = table.length;
        Entry<?,?>[] oldMap = table;

        // overflow-conscious code
        int newCapacity = (oldCapacity << 1) + 1; // 这就是扩容
        if (newCapacity - MAX_ARRAY_SIZE > 0) {
            if (oldCapacity == MAX_ARRAY_SIZE)
                // Keep running with MAX_ARRAY_SIZE buckets
                return;
            newCapacity = MAX_ARRAY_SIZE;
        }
        Entry<?,?>[] newMap = new Entry<?,?>[newCapacity];

        modCount++;
        threshold = (int)Math.min(newCapacity * loadFactor, MAX_ARRAY_SIZE + 1);
        table = newMap; // 替换原数组 (清空了table)
        // 将原内容加入 table
        for (int i = oldCapacity ; i-- > 0 ;) {
            for (Entry<K,V> old = (Entry<K,V>)oldMap[i] ; old != null ; ) {
                Entry<K,V> e = old;
                old = old.next;

                int index = (e.hash & 0x7FFFFFFF) % newCapacity;
                e.next = (Entry<K,V>)newMap[index];
                newMap[index] = e;
            }
        }
    }
```

#### Properties

​	继承于 Hashtable 类并实现了 Map 接口，也采用 k - v 形式保存数据（但要存放字符串！） ，并都不能为空 

​	使用特点与 Hashtable 类似

​	更多用于从 xxx.properties 文件中，加载数据到 Properties 类对象，并进行读取与修改

​		xxx.properties 文件通常是配置文件 

​	 getProperty（） ：用于获取配置文件中指定键（key）对应的字符串值（value） 的核心方法

#### TreeMap

​	整体情况与 TreeSet 一致（底层就是 TreeMap 实现），源码情况一致

### 集合实现类的选择

​	先判断存储类型 ： 一组对象（单列） 还是 一组键值对（双列）

​		一组对象 ： Collection （是否允许重复）

​			重复 ： List

​					增删多 ： LinkedList （双向列表）

​					查找多 ：ArrayList （Object 的可变数组）

​			不重复 ： Set

​					无序 ： HashSet （HashMap，数组 + 链表 + 红黑树）

​					排序 ：TreeSet

​					插入与取出顺序一致 ： LinkedHashSet  （数组+ 双向列表）

​		一组键值对 ： Map

​			键无序 ：HashMap （哈希表， jdk7 ： 数组 + 链表；jdk8：数组 + 链表+ 红黑树）

​			键排序 ： TreeMap

​			键插入与取出顺序一致  LinkedHashMap

​			读取文件 ： Properties

### Collections 工具类

​	操作 List 、Set 和Map 等集合的工具类

​	提供了一系列的静态方法为集合元素进行排序、查询和修改等操作

​	方法

reverse() :反转集合中元素的顺序

shuffle() : 对集合元素进行随机排序

sort(List,Comparator) : 根据指定的 Comparator 对 List 进行排序

swap(List,int,int) : 将 List 集合中的索引 i ，j 上位置的元素进行交换，不能超过范围

max(Collection) : 返回根据自然顺序进行排序后，集合中最大的元素

max(Collection,Comparator) : 返回根据指定排序方式进行排序后，集合中最大的元素

min(Collection) : 返回根据自然顺序进行排序后，集合中最小的元素

min(Collection,Comparator) : 返回根据指定排序方式进行排序后，集合中最小的元素

frequency(Collection,Object) : 返回指定集合中，指定元素出现的次数

copy(List dest,List src) : 将 src 中的内容复制到 dest 中 ,要求 dest 中size 必须 >= src的size

boolean replaceAll(List list,Object oldVal,Object newVal) ： 将指定集合中的指定元素替换为新元素

```
HashMap 的 remove
final Node<K,V> removeNode(int hash, Object key, Object value,
                               boolean matchValue, boolean movable) {
        Node<K,V>[] tab; Node<K,V> p; int n, index;
        // table不能空，长度大于0， hash转的索引上的位置不能空
        if ((tab = table) != null && (n = tab.length) > 0 &&
            (p = tab[index = (n - 1) & hash]) != null) {
            Node<K,V> node = null, e; K k; V v;
//            判断是不是要删除的元素(hash,key,以及是不是相等的)
            if (p.hash == hash &&
                ((k = p.key) == key || (key != null && key.equals(k))))
                node = p; // 记录这个删除的元素
            else if ((e = p.next) != null) { //找链表下面的
                if (p instanceof TreeNode) // 看链表上是不是树
                    node = ((TreeNode<K,V>)p).getTreeNode(hash, key);
                else {
                    do { // 循环对比
                        if (e.hash == hash &&
                            ((k = e.key) == key ||
                             (key != null && key.equals(k)))) {
                            node = e;
                            break;
                        }
                        p = e;
                    } while ((e = e.next) != null);
                }
            }
            //看是不是记录了要删除的对象
            if (node != null && (!matchValue || (v = node.value) == value ||
                                 (value != null && value.equals(v)))) {
                //判断是不是树
                if (node instanceof TreeNode)
                    ((TreeNode<K,V>)node).removeTreeNode(this, tab, movable);
                else if (node == p) // 删除的位置是表头，
                    tab[index] = node.next; // 换成链表的下一个节点
                else
                    p.next = node.next;
                ++modCount;
                --size;
                afterNodeRemoval(node);
                return node;
            }
        }
        return null;
    }
```



## 泛型

​	传统上，无法对加入到集合 ArrayList 中的数据类型进行约束（不安全）

​	遍历时，需要进行类型转换，如果集合中的数据量较大，对效率有影响

泛型就提供了 ： 编译时，检查添加元素的类型，提高了安全性； 减少了类型转换的次数；不在提示编译警告

​	泛型就是表示一种数据类型（具体由程序员选择） 的数据类型

​	泛型又称参数化类型，jdk5 出现，解决数据类型安全性的问题

​	泛型的作用是 ：在类声明时，通过一个标识表示类中的某个属性的类型 ,或者某个方法的返回值或参数类型 (具体的数据类型会在该属性的数据类型在定义对象时指定 即编译期间确定)

### 声明 

​	interface 接口 <T> {}  class 类名 <K,V>{}

​	K、V、T 表示数据类型，任何字母都可以，常用 T 表示

### 实例化 

​	在类名后指定类型参数的值

### 使用细节

​	T 、E 只能是引用类型

​	在给泛型指定具体类型后，可以传入该类型或者该类型的子类类型

​	泛型使用形式

​		传统 ：ArrayList<Integer> integers1 = new ArrayList<Integer>();

​		简化 ：ArrayList<Integer> integers2 = new ArrayList<>(); 常用，编译器会进行类型推断，默认是右侧的 Integer

​		 如果要求你传入一个泛型时，如果没有传入泛型，将会默认看成 Object

### 自定义泛型类 

​	就自己写了一个类，然后在后面定义了一些泛型

#### 	语法 

​		class 类 <T ,R...> {}

#### 	细节 

​		普通成员可以使用泛型

​		使用泛型的数组不能进行初始化   因为泛型表示符只能在创建对象时才能得到确定，编译器都不知道表示符是啥类型，要开辟多少空间

​		静态方法中不能使用类的泛型  静态方法是和类相关的，但泛型只会在创建对象的时候得到确定，静态成员都不知道是啥，JVM 也不知道怎么初始化

​		泛型类的类型，在创建对象时确定（创建对象时，要指定泛型类型）

​		如果创建对象时，没有指定类型，默认 Object

### 自定义泛型接口

​	语法

​		interface 接口 <T,R...> {}

#### 	细节

​		接口中，静态成员也不能使用泛型

​		泛型接口的类型，在继承接口或者实现接口时被确定

​		没有指定类型，则默认为 Object

### 自定义泛型方法

#### 	语法 

​		修饰符 <T,R...> 返回类型 方法名（参数列表） {}

#### 	细节

​		泛型方法，可以定义在普通类中，也可以定义在泛型类中	

​		泛型方法可以是静态方法

​		当泛型方法被调用时，类型会被确定  当调用方法时，编译器会根据参数类型 自动判断泛型标识符的类型

​		像 public void f(E e)  这种方法，修饰符后没有<T,R...> ，并不是泛型方法，而是使用了泛型

​		泛型方法可以使用类声明的泛型，也可以使用自己声明的泛型

### 泛型的继承与通配符

​	泛型不具备继承性 : List<Object> list = new ArrayList<String>();

#### 	通配符 

​		<?> : 接受任意类型的泛型

​		<? extends AAA> : 表示上限 接受 AAA 或AAA的子类

​		<? super CCC> : 表下限，接受 CCC 或 CCC的父类，不限于直接父类



### JUnit

​	java 语言的单元测试框架

​	如何使用 ： 在想要测试的方法上一行增加 @Test ，然后鼠标悬停 alt + enter 使用 JUnit 5 等待加载完毕，

java绘图坐标体系

​	圆点在左上角，水平x ，垂直y ，单位像素， （x，y）

java绘图入门

​	原理 ：

​	Component类提供了两个和绘图相关的重要方法

​		paint(Graphics g) ：绘制组件外观

​		repaint() ：刷新组件外观

​	当组件第一次在屏幕显示的时候，程序会自动的调用 paint 方法来绘制组件

​	以下情况 paint 将会被调用 ：

​		窗口最小化后再最大化

​		窗口的大小发生改变

​		repaint 方法被调用

```
1. 先定义一个面板类，使其继承于 JPanel，后续画图将在这个面板进行
2. 重写 paint 方法，先调用 父类的 paint 方法，再进行绘制 重写方法参数 ：Graphics g
3. public 类继承 JFrame(对应窗口，就是一个画框)
4. 定义一个画板类属性
5. 实现一个无参构造器 ： 初始化一个画板，
6. this.add(画板对象) ： 将画板加入窗口
7. this.setSize(width,height) : 指定窗口大小
8. this.setVisible(true) : 使窗口可以显示
9. this.setDefaultCloseOperation(JFrame.EXIT_ON_CLOSE); ： 使点击关闭按钮实现程序完全退出
10. 在main 方法中创建一个public 类实例对象
```

Graphics 类	

```
   画园
//        g.drawOval(40, 40, 100, 100);

//        画直线
//        g.drawLine(25,25,50,50); // 各确定两个点连线

//        矩形边框
//        g.drawRect(25,25,100,100); // 确定一个点，后面为宽高

//        填充矩形
//        g.setColor(Color.blue);
//        g.fillRect(25,25,100,100);

//        填充椭圆
//        g.setColor(Color.red);
//        g.fillOval(25,25,100,100);

//        画图片 1.获取图片资源
//        图片必须放在 out 文件夹的 chapter15 即当前项目文件下
//        MyPanel.class.getResource("/5.png") MyPanel指你继承了 JPanel 类的 画板类，别乱来
//        Image image = Toolkit.getDefaultToolkit().getImage(MyPanel.class.getResource("/5.png"));
//        g.drawImage(image,25,25,244,155,this); // 宽高与图片一致，否则会变形

//        画字符串 ： 先给画笔设置颜色和字体
//        g.setColor(Color.red);
//        g.setFont(new Font("宋体", Font.BOLD, 20));
//        g.drawString("北京你好",100,100); // 对应左下角坐标

//        设置画笔颜色 setColor()
//        设置画笔字体 setFont(Font font)
```

通过键盘来控制图像 ：

​	使画笔类实现一个接口 ：KeyListener  （一个监听器，监听键盘事件） （alt + enter 快速实现方法重写）

```
// 有字符输出时，该方法将会触发
    @Override
    public void keyTyped(KeyEvent e) {

    }

//    当某个键按下时，该方法会触发
    @Override
    public void keyPressed(KeyEvent e) {

    }

//    当某个键按下后释放了，该方法将会触发
    @Override
    public void keyReleased(KeyEvent e) {
		//        System.out.println((char)e.getKeyCode() + "被按了");
        //        System.out.println(e.getKeyChar()); // 小写
        //        根据用户按下不同的键，来处理小球的移动
                switch (e.getKeyChar()) {
                    case 'w' :  y -= 10; break;
                    case 's' :  y += 10; break;
                    case 'a' :  x -= 10; break;
                    case 'd' :  x += 10; break;

                }
        //        还需要重绘一次画板
                this.repaint();
    }
```

但是要注意的时，添加后还需要再main类的构造器中增加一个  addKeyListener(panel)， 里面参数就是 ： KeyListener 实现类对象

Java事件处理机制

​	采取 “ 委派事件模型” 。当事件发生时，产生事件的对象，会把此 “信息” 传递给 “事件的监听者” 处理，这里的 信息 就是指 java.awt.event 事件类库里某个类所创建的对象，并将它称为 “事件的对象” 

​	事件源 ： 一个产生事件的对象

​	事件 ： 承载事件源状态改变时的对象



## 线程（基础）

​	进程是指运行中的程序，是程序的一次执行过程或者正在运行的一个程序，是动态的过程，有本身的产生，存在与消亡的过程

​	线程由进程创建，是进程的一个实体，线程也可以通过另一个线程创建

​	一个进程可以拥有多个线程

​	单线程 ：同一时刻，只允许执行一个线程

​	多线程 ： 同一时刻，可以执行多个线程

​	并发 ： 同一时刻，多个线程（）交替执行  单核CPU 执行多个任务就是并发

​	并行 ： 同一时刻，多个线程（任务）同时执行 多核 CPU 执行多个任务就是 并行

​	并发与并行可以同时存在

### 基本使用

#### 	实现方式

​		继承 Thread 类，重写 run 方法

​		实现 Runnable 接口， 重写 run 方法

##### 	继承 Thread 类

​		当一个类继承了 Thread 类 ，该类就可以当作线程类来使用

​		重写 run 方法，写上自己的业务逻辑， run 方法是 Thread 实现了 Runnable 接口的 run 方法

​		当一个程序开始执行时，会将 main 方法作为一个线程（main 线程）执行，main方法中调用 start 方法将会开辟出一个新的线程

​		当 main 线程使用 start 启动一个子线程时,main 线程并不会等待子线程执行完毕才执行,会继续执行, 当主线程一旦结束，如果还有子线程还在执行，则整个程序并不会停止，而是直到子线程结束（当线程全部执行完毕后，进程才会结束）

​		当主线程与子线程一起执行时，根据CPU数量来决定是并发还是并行

​		一个子线程可以继续开辟另一个子线程

##### 	实现 Runnable 接口

​		当一个类继承了其他类时，此时由于 java 单继承的机制，无法继承 Thread 类，此时可以通过实现 Runnable 接口

​		由于 Runnable 接口中只有一个 run 方法，因此无法直接调用 start 方法进行实现开辟一个子线程

​		此时想要通过有参构造器（接受一个实现了 Runnable 接口的类的对象）来创建一个 Thread 对象，并通过这个 Thread 对象来调用 start 方法

​		这种创建子线程方式是一种设计模式 ： 代理模式，分静态代理和动态代理，这里就是静态代理

#### Thread 与 Runnable 的区别

​	设计角度上，没有区别，本质还是调用 start() 方法来调用 start0 本地方法

​	但是实现 Runable接口 方式更加适合多线程共享一个资源的情况，并且避免了单继承的限制 建议使用 Runnable

### 线程终止

​	线程完成任务后，会自动退出

​	通过使用变量来控制run方法退出来停止线程，即通知方式 （持有该线程的对象，修改该线程的相关属性来退出）

### 线程方法

​	setName : 设置线程名称 为参数

​	getName：返回该线程的名称

​	start ： 使线程开始执行，Java 虚拟机底层调用 start0 方法

​	run ： 调用线程对象的 run 方法

​	setPriority ： 更改线程优先级

​	getPriority ： 获取线程优先级

​	sleep ： 在指定毫秒数内让当前正在执行的线程休眠，暂停执行，静态方法

​	interrupt ： 中断线程，并不会真正结束线程，一般用于中断正在休眠的线程，将正在休眠的线程唤醒

​	细节

​		start 底层会创建一个线程，在调用 run 方法 ，而 run 方法就是一个普通方法，无法创建线程

​		线程优先级范围 ： 10（MAX_PRIORITY）， 5（NORM_PRIORITY）， 1（MIN_PRIORITY）

​	yield ： 线程的礼让，退出CPU，让其他线程来被执行，但礼让时间不一定，因此不一定礼让成功（如果 CPU 资源并不紧急，CPU 会认为我忙的过来，不需要你礼让，我安排就行；如果资源非常紧张，礼让成功几率更大） 静态方法

​	join ： 线程的插队，如果线程插队执行成功，则CPU 一定会先执行完插队线程的所有任务

用户线程 ：也称工作线程，当线程的任务执行完毕或者被通知方式结束的线程称为用户线程

守护线程 ： 一般为工作线程服务，当所有的用户线程全部执行完毕，守护线程将自动结束 （常见守护线程为垃圾回收机制）

将线程设置为守护线程  ：setDaemon(true)；要在线程启动之前设置为守护线程，否则抛出异常

### 线程生命周期

​	文档提供 6 种状态 ：new、runnable、blockable、waiting、timed_waiting、terminated

​	但是 runnable 可以细分为 ready 、running

### 线程同步机制

​	在多线程编程中，有一些敏感的数据不允许被多个线程同时访问，此时就使用同步访问技术，保证数据在任何同一时刻，最多有一个线程访问，以保证数据的完整性

​	就是当一个线程在对内存进行操作时，其他线程无法对该内存地址进行操作，唯有等到该线程操作完毕后，其他线程才能对该内存地址进行操作

#### 同步具体方法

​	synchronized 修饰代码块

​	synchronized 修饰方法	

​	synchronized 是非公平锁，谁抢到就是谁的

### 互斥锁 

​	Java 语言中引入互斥锁的概念，来保证共享数据操作的完整性	

​	每个对象都对应与一个可称为 “互斥锁” 的标记，这个标记用于保证在任一时刻，只能有一个线程访问改对象（拿到了就进去运行，否则就等着）

​	关键字 synchronized 来与对象的互斥锁联系，当某个对象使用 synchronized 来修饰是，表明该对象在任一时刻只能由一个线程访问

​	局限性 ： 导致程序的执行效率要降低

​	非静态同步方法 ：锁可以是 this ，也可以是其他对象，但要求是同一个对象，否则锁就失效了

​	静态同步方法 ：锁为当前类本身 	

​	细节

​		同步方法没有 static 修饰时，默认锁对象为 this（当前对象）

​		如果有 static 修饰 ，默认锁对象 ：当前类名 . class

​	步骤 ：

​		分析上锁代码

​		选择同步代码块还是同步方法，同步代码越少效率越高，因此同步代码快比同步方法效率高

​		要求多个线程的锁对象是同一个，不然锁不住

### 线程死锁

​	多个线程占用对方的锁资源，但不肯相让，导致死锁，各线程相互等待		

### 释放锁 

​	线程的同步代码方法和同步代码块执行完毕

​	线程的同步代码方法和同步代码块遇到 return 和 break

​	线程的同步代码方法和同步代码块出现了未处理的错误或异常，导致异常结束

​	线程的同步代码方法和同步代码块执行了线程对象的 wait  方法，当前线程暂停，释放锁

下面操作并不会释放锁

​	线程的同步代码方法和同步代码块执行时，调用了 sleep 和 yield 方法时，暂停代码执行并不会释放锁

​	线程执行同步代码块时，其他线程调用了该线程的 suspend 方法将该线程挂起时，线程不释放锁（挂起进入就绪态，并不会释放）（suspend 和 resume 已被弃用）



写并发程序，一定要考虑线程应该在什么时候结束，除非是守护，或者想一直循环

## I/O 流

### 文件流

​	文件在程序中以流的形式来操作，

​	流 ： 数据在数据源（文件）和程序之间经历的路径，数据搬运工

​	输入流 ： 数据从数据源（文件）到程序的路径 

​	输出流 ： 数据从程序到数据源的路径

​	文件是否存在 ： exists()

​	delete() ： 删除

​	mkdir() ：创建单级目录

​	mkdirs() ：创建多级文件夹

### 创建文件的方法

​	new File(String Path) ：根据路径来构建

​	new File(File parent, String child) ： 根据父目录文件 + 子路径构建

​	new File(String parent,String child) ： 根据父目录文件路径 + 子路径构成

### I/O 流

​	用于数据传输

​	Java 程序中，对数据的输入输出操作以 “流” 的方式进行

​	java.io 包提供了各种“流”类和接口，用以获取不同种类的数据，并通过方法输入或输出数据

### 流的分类

​	操作数据单位 ：

​		字节流 ： 可以用于操作二进制文件（图片、音乐、视频、doc、pdf..），不会引发文件损失

​		字符流 ： 多用于操作文本文件

​	流向分类 ： 输入流，输出流

​	流的角色分 ： 节点流，处理流（包装流）

### 常用类

​	InputStream : 抽象类，所有类字节输入流的超类

​		常用子类

​			FileInputStream : 文件输入流

​				read ： 一个一个**字节**读，读完返回 -1

​				read(byte[] b) : 一次性读取 b 长度的字节，并返回本次读取的字节数，读完返回 -1（new String(byte[] b) 快速形成字符串）

​			BufferedInputStream ： 缓冲字节输入流

​			ObjectInputStream ： 对象字节输入流



FileOutputStream : 往指定文件写入数据，如果文件不存在，将主动创建该文件

​	write ：写入数据，多个方法重载，

​	构造器 ： new FileOutputStream(File f) ：会使每次程序写入时覆盖程序执行前的原有内容

​	不想覆盖采用这个构造器，使写入内容在末尾 ：public FileOutputStream ([String name, boolean append（赋 true）)



FileReader

​	是 InputStreamReader 的子类

​	相关方法

​		new FileReader(String / File)

​		read : 读取单个**字符**，末尾返回-1

​		read（char[] a） : 一次读取 数组a 的长度的字符，

FileWriter

​	是 OutputStreamWriter 的子类（如果文件不存在，先创建文件）

​	相关方法

​		new FileWriter(File / String ) : 覆盖模式， 流指针在首端

​		new FileWriter(File / String , true) : 追加模式，流指针在尾端

​		write(int/ char[] / String,)

​	相关 API ： String : toCharArray : 将 String 转为 Char[] 

​	注意 ： 使用 FileWriter 后（内容还在内存中，只有到关闭和刷新后才写入文件），必须关闭 close （等价于 flash + 关闭） 或 刷新 flash ，否则无法写入指定的文件

完成读取或写入操作后，要关闭！！close

拷贝文件时，采取：读取源文件后立马写入指定文件

节点流 与 处理流

### 节点流 

​	针对一个特定的数据源（存放数据的地方）读取数据，如：FileReader、FileWrite （固定读取）

### 处理流（包装流）

​	是 “连接” 在已经存在的流（节点、处理）之上（包装以下流），为程序提供强大的读写功能，更加灵活如：BufferReader、BufferWriter...

​	BufferReader 存在属性 Reader ，其可以封装成一个节点流（但是必须是 Reader 的子类，表明什么，可以一下代替好多其他类了）

区别

​	节点流是底层流/低级流，直接跟数据源相接

​	处理流 包装节点流，既可以消除不同节点流的实现差异，也提供更方便的方法来完成输入输出

​	处理流 对节点流进行包装，使用了修饰器设计模式，不会直接与数据源相连接

处理流的体现

​	性能提高：主要以增加缓冲的方式来提高输入输出的效率

​	操作便捷：提供了一系列便捷的方法来一次输入大批量的数据，使用更加灵活方便

BufferedReader 与 BufferedWriter

​	属于字符流，按照字符读取数据；关闭处理流时，只需要关闭外层流（处理流）即可（底层调用关闭内层流 ：节点流的方法）

BufferedReader 

​	readLine : 按行读取数据，当返回 null 表示读完

BufferedWriter 

​	插入多行内容时使用 newLine :插入一个换行符，和系统相关的换行



BufferedInputStream 与 BufferedOutputStream

​	属于字节流，可以用于处理二进制文件(文本文件也是可以的，但推荐一次读1024个字节)

### 对象流

ObjectInputStream 和 ObjectOutputStream （处理流）

​	提供基本数据类型与对象类型的序列化和反序列化方法

#### 序列化与反序列化

​	序列化 ： 保存数据时，保存数据的值与数据类型

​	反序列化 ： 恢复数据时，恢复数据的值与数据类型

​	需要某个对象支持序列化机制，必须使其类是可序列化的，因此必须实现下列接口之一 ： Serializable(推荐，这是一个标记接口，没有方法)	Externalizable

ObjectInputStream 

​	提供反序列化功能

​	读取（反序列化）的顺序需要和你保存（序列化）的顺序一致，否则抛出异常

​	当反序列化读取一个对象时，其获取的对象编译类型为 Object ，运行类型为 序列化保存的对象，当想调用该对象方法时，先将该对象类的定义放在可以引用的位置，再进行向下转型

ObjectOutputStream 

​	提供序列化功能 ， 序列化后，保存的文件格式，并不是纯文本，而是按照他的格式来进行保存

​	write+类型() : writeInt..... 

​	保存一个 字符串 ： writeUTF 

注意事项

​	读写顺序一定要一致

​	实现序列化和反序列化对象，其类必须实现一个接口 ： Serializable 或 Externalizable

​	序列化的类建议添加属性 ： SerialVersionUID（private static final ），提高版本兼容性（再为类增加属性时，并不会将其看成新的类）

​	序列化对象时，默认将对象中的所有属性进行序列化，除了使用 static 和 transient 修饰

​	序列化对象时，要求进行序列化的属性的类型也实现了序列化接口（未实现将抛错）

​	序列化具有继承性，当某个类实现了序列化，其所有子类将默认实现序列化

### 标准输入输出流

​	System.in ：标准输入 默认设备 ： 键盘	 编译类型 ：InputStream , 运行类型 ：BufferedInputStream

​	System.out ： 标准输出 默认设备 ：显示器  类型 ：PrintStream

### 转换流

​	字节流(可以指定编码模式) 转换为字符流 (又可以将这个转换流转成处理流，更加方便操作)

​	读取文件时。默认是按照 utf-8(utf8) 来读取内容，如果文件不是该编码，就会产出乱码

​	InputStreamReader

​		Reader 的子类，可以将字节流（InputStream） 包装成（转换）字符流(Reader)

​		可以在构造器中指定一个编码模式，将字节流按照编码转换为字符流

​	OutputStreamWriter

​		Writer 的子类，可以将 OutputStream 包装成 Writer	

处理纯文本数据时，使用字符流效率更高，并可以有效解决中文问题，因此建议将字节流转为字符流

可以在使用时指定编码格式

### 打印流

​	只有输出流，没有输入流  (打印到指定文件位置)

​	PrintStream 

​		字节打印流

​		接受 标准输出流，调用 print 方法（因为 print 方法底层是 write，因此也可以直接调用 write，在显示屏上输出）

​		使用 System.setOut(new PrintStream(路径))来指定打印流输出的位置、设备

​	PrintWriter

​		字符打印流

### Properties 类

​	专门用于读写配置文件的集合类，

​	要求配置文件格式为：

​		键=值
​		键=值

​	键值对不需要有空格，值不需要用引号括起来，默认类型为 String

​	常见方法

​		load ： 加载配置文件的键值对到 Properties 对象

​		list ：将数据显示到指定设备/文件/流

​		getProperty(key) ：根据键获取值 

​		setProperty(key,value) ： 将 key键的值修改为 value ，如果key不存在，就是创建键值对

​		store ： 将 Properties 中的键值对存储到配置文件，没有文件创建文件，有文件就覆盖 （Idea中，如保存信息中有中文（字节流输出），将采用 unicode 码进行存储）（两个参数，最后一个参数是注释）

## 网络编程

### 网络通信

​	两台设备之间通过网络实现数据传输

​	网络通信 ： 将数据通过网络从一台设备传输到另一台设备

​	java.net 包下提供了一系列的类和接口，供程序员使用，完成网络通信

### 网络 

​	两台或多台设备通过一定的物理设备连接起来构成了网络

​	覆盖范围分类

​		局域网、城域网、广域网

### ip地址

​	用于唯一标识网络中的每台计算机（查看 ip 地址：ipconfig）

​	ip地址表现形式 ： 点分十进制 xx.xx.xx.xx(ipv4 : 4个字节表示，十进制显示)

​	ip地址的组成 ： 网络地址 + 主机地址

​	IPv4存在于网络地址资源有限的问题，于是引入 IPv6来解决网络地址资源有限以及多种接入设备连入互联网的障碍（替代IPv4 的IP协议）

​	IPv6 ： 使用128位表示，16个字节，冒分十六进制

![image-20251030164809094](C:\Users\Administrator\AppData\Roaming\Typora\typora-user-images\image-20251030164809094.png)

### 域名

​	将IP地址映射成域名（HTTP协议），方便记忆

### 端口号

​	用于标识计算机上某个特定的网络程序(该程序要监听该端口)

​	以整数形式表示，范围 ：0~65535 （两个字节）

​	0 ~ 1024 端口已被占用

​	常见网络程序端口号 ：

​		tomcat ： 8080

​		mysql ：3306

​		oracle： 1521

​		sqlserver : 1433	

### 网络通信协议

​	在网络编程中，协议就是一个数据的组织形式

​	TCP/IP 协议 ：传输控制协议/因特网互联协议，网络通讯协议

​	OSI 模型 是一个理论上的模型

### TCP协议和UDP协议

​	![image-20251031080834141](C:\Users\Administrator\AppData\Roaming\Typora\typora-user-images\image-20251031080834141.png)



### InetAddress 类

​	获取本机的信息（主机名和 ip ）；通过域名获取远程服务器的 IP

​	常用方法（静态） ： 

​		getLocalHost() :获取本机的 InetAddress 对象

​		getByName() ：根据指定的主机名或域名或 IP（字符串），获取 InetAddress 对象

​		getHostAddress() ：根据一个 InetAddress 对象，获取对应对象的 IP 地址

​		getHostName() ：通过一个 InetAddress 对象， 获取对应对象的主机名或域名

### Socket

​	套接字 开发网络应用程序被广泛采用，以至于称为事实上的标准

​	通信的两端都要又 Socket，是两台机器间通信的端点

​	网络通信就是 Socket 间的通信

​	Socket 允许 程序把网络连接成一个流，数据在两个 Socket 间通过 IO 传输

​	一般主动发起通信的应用程序属客户端，等得通信请求的为服务端

两种编程方式

#### TCP 编程

![image-20251031085544975](C:\Users\Administrator\AppData\Roaming\Typora\typora-user-images\image-20251031085544975.png)

​		Socket 每次完成后要关闭，因为是有限的

​		分字节编码与字符编码

​		整体思路 ：

​			与上图类似

​			服务端 ： 

​				监听一个端口号（要求没有其他服务占用该端口）；

​				accept 获取一个 Socket 对象

​				通过getOutputStream 和 InputStream 获取字节流（如果想要使用字符流，可以通过转换流实现转换，推荐最后生成一个处理流来进行处理）

​			客户端 ：

​				创建一个 Socket 对象，端口号与 IP 与 服务端一致

​				通过getOutputStream 和 InputStream 获取字节流（如果想要使用字符流，可以通过转换流实现转换，推荐最后生成一个处理流来进行处理）

​			注意使用字符流进行写入数据时一定要刷新一下，不然白写入了，建议刷新与写入紧贴在一起

​			遵循服务端监听，客户端发送数据和设置结束标识，服务端读取数据和结束标识后停止读取，在有服务端开始传递响应数据和结束标志，客户端进行读取，发现结束标志后停止读完，完成两端的相互沟通

​			最后要关闭所有的输入输出流（处理流只需关闭外层流就行）以及 socket

​			结束标志 ：

​				socket.shutdownOutput();（底层的）（不单这一个，可以多种，但是要求双方遵守同一套规则）

​			当没有结束标志时，客户端/服务端会一直等待服务端/客户端输入数据(不会判断)，直到客户端/服务端执行了结束标志，使对方知道，输入完了，你可以继续了。

​		注意点 ：

​			当关闭流时，会间接关闭了 socket 从而导致出现 Socket closed 问题，建议都放在后面统一关闭

​			关闭资源采取先使用后关闭

​		实现文件拷贝

![image-20251031154003523](C:\Users\Administrator\AppData\Roaming\Typora\typora-user-images\image-20251031154003523.png)

对于二进制文件，绝对不可以转换成 String 作为中间态 进行传输！！！！

```
while((len = inputStream.read(buf1)) != -1) {
1. // 会直接损坏照片(破坏 二进制结构)
          read = new String(buf1,0,len);// 二进制字节 → 字符串（错误！）
          os.write(read.getBytes());// 字符串 → 字节（二次转换导致数据丢失）
2. // 直接读或写就行
            os.write(buf1,0,len);
        }
```





netstat指令

​	netstat -an ： 查看当前主机网络情况，包括端口监听情况和网络连接情况

​	netstat -an | more ： 可以分页显示内容，空格查看

​	Listening 表示某个端口在监听

​	如果有一个外部程序连接到该端口时，就会显示一条连接信息

TCP网络通讯

​	当客户端连接到服务端后，实际上客户端也是通过一个端口和服务端进行通讯的，这个端口是 TCP/IP 来分配的（随机）	

#### UDP 编程

​		类 DatagramSocket 和 DatagramPacket (数据包/数据报) 实现了基于 UDP 协议网络程序

​		UDP 数据报 通过数据报套接字 DatagramSocket 发送和接受，系统不保证 UDP 数据报 一定能够安全送到目的地，也不确定什么时候抵达

​		DatagramPacket 对象封装了 UDP 数据报，包含了发送端的 IP 地址 和 端口号以及接受端的 IP 地址和端口号

​		UDP 协议种每个数据报都给出了完整的地址信息，无须建立发送发和接受方的连接

​	流程

​		核心的两个类/对象 ： DatagramSocket , DatagramPacket

​		建立发送端，接受端 (没有客户端与服务端，采用发送端和接受端来代替，并根据情况发送变更)

​		建立数据包/报（数据被封装到 DatagramPacket 对象中）

​		调用 DatagramSocket 的 发送 （send）与接受方法 （receive）

​		关闭 DatagramSocket

​		装包 ： 数据被封装到 DatagramPacket 对象中

​		拆包 ：将数据从 DatagramPacket 对象中拿出来

​		DatagramSocket 可以指定在哪个端口进行接受数据

​	具体实现

```
// 接收端
public class UDPReceiverA {
    public static void main(String[] args) throws Exception {
//        创建 DatagramSocket 对象，准备在 端口号9999 接受数据
        DatagramSocket datagramSocket = new DatagramSocket(9999);
//        准备创建 DatagramPacket 对象接受数据报
        byte[] buffer = new byte[1024];
        DatagramPacket datagramPacket = new DatagramPacket(buffer, buffer.length);
//        调用接受方法接受发送端发送过来的 datagramPacket,并将其填充到 datagramPacket对象中
        // 当有数据包被发送到 本机的 9999 端口，则会接受到数据
        // 如果没有数据包被发送到 本机的 9999 端口，将会发生阻塞等待接受
        System.out.println("A 等待接受数据");
        datagramSocket.receive(datagramPacket);

//        进行拆包,取出数据并显示
        int length = datagramPacket.getLength(); // 获取数据的完整长度
        byte[] data = datagramPacket.getData(); // 这里就获取了包中的数据
        String datas = new String(data,0,length);
        System.out.println(datas);

//        准备向 B 发送数据
        String message = "好的，明天见";
        byte[] sendData = message.getBytes();
        datagramPacket = new DatagramPacket(sendData,sendData.length,
                InetAddress.getByName("10.100.1.112"),9998);
        datagramSocket.send(datagramPacket);

//        关闭资源
        datagramSocket.close();

        System.out.println("A端退出");

    }
}




public class UDPSenderB {
    public static void main(String[] args) throws Exception {
//        创建 DatagramSocket 对象,准备在 9998 端口接收数据 ? 因为发送端和接收端可能随时改变
//        后面指定发向的主机和端口号就行
        DatagramSocket datagramSocket = new DatagramSocket(9998);

//        创建 DatagramPacket 对象,存放待发送数据以及指定接受主机的IP和接受端口号
        String message = "hello  明天一起吃火锅~";
        byte[] sendData = message.getBytes();
//        DatagramPacket datagramPacket = new DatagramPacket(sendData,sendData.length,
//                InetAddress.getLocalHost(),9999);
//        建议发IP
//        封装内容 ： 字节数组(数据),长度,主机(知道IP),主机端口号
        DatagramPacket datagramPacket = new DatagramPacket(sendData,sendData.length,
                InetAddress.getByName("10.100.1.112"),9999);

//        发送数据
        datagramSocket.send(datagramPacket);

        System.out.println("B 等待接受数据");
        byte[] buffer = new byte[1024];
        DatagramPacket packet = new DatagramPacket(buffer,buffer.length);
        datagramSocket.receive(packet);

//        拆包
        byte[] data = packet.getData();
        int length = packet.getLength();
        String s = new String(data,0,length);
        System.out.println(s);


        datagramSocket.close();
        System.out.println("B端退出");
    }

}
```

​			

## 反射reflection

​	OCP 原则 ：即通过外部文件配置，不修改源代码的基础上，来控制程序（开闭原则：不修改源码，扩展功能）

### 反射机制

​	反射机制允许程序在执行期间借助 Reflection API 取得任何类的内部信息（成员变量/方法、构造器），并能够操作对象的属性及方法，在设计模式和框架底层都会用到

​	加载完类后，将会在堆中产生一个 Class 类型的对象（一个类只有一个 Class 对象），这个对象包含了类的完整结构信息。通过这个对象得到类的结构（像一面镜子，通过这面镜子可以看到类的结构）

### 三个阶段

![image-20251104140406744](C:\Users\Administrator\AppData\Roaming\Typora\typora-user-images\image-20251104140406744.png)

​	当类被加载时，会将类的字节码二进制数据（元数据）加载到方法区，以及在堆中创建一个 class 类对象（数据结构）

反射机制可以实现：

​	在运行时判断任意一个对象所属的类、构造任意一个类的对象、得到任意一个类所具有的成员变量和方法、调用任意一个对象的成员变量和方法、生成动态代理

### 主要类

​	java.lang.Class ：代表一个类，Class 对象表示某个类加载后在堆中的对象 

​	java.lang.reflect.Method ：代表类的方法，其对象表示某个类的方法

​		获取 ：class 对象.getMethod("方法名")

​		调用 ：方法.invoke(对象)   传统就是 对象.方法名() 

​	java.lang.reflect.Field ： 代表类的成员变量，其对象表示某个类的成员变量

​		获取 ： class 对象. getField("成员变量名")  无法获取 私有的成员变量

​		输出变量数据 ： 成员变量对象.get(对象)   对象.成员变量名() 

​	java.lang.reflect.Constructor ： 代表类的构造器，其对象表示某个类的构造方法

​		获取 ： getConstructor() : () 内容可以指定构造器的参数类型，指定特定的构造器，即无参就获取无参构造器，有参获取有参

​				参数传入加上 .class  String.class(String 类的 Class 对象)....

### 优点

​	可以动态的创建和使用对象（框架底层的核心），使用灵活；没有反射，框架技术就失去了底层支撑

### 缺点

​	基本是解释执行，对执行速度有影响

### 调用优化 

​	Method Field Constructor 都有方法： setAccessible() 方法 （启用或禁用访问安全检查开关） (一定程度上提升)

​	参数为 true ，使用时取消访问检查，提升反射效率；为false，执行访问检查

### Class 类

​	Class也是一个类，也继承了 Object

​	Class 类对象不是 new 出来的，而是通过系统创建出来的（即类加载器的loadClass 方法 ）

​	对于某个类的 class 对象，在内存中只会有一个，类的加载只会有一次

​	每个类的实例对象都会记住自己是由哪个 Class 实例 生成的	

​	通过一系列的 API ，可以通过 Class 实例可以获取某个类的完整结构

​	Class 对象是存放子啊堆中的

​	类的字节码二进制数据，是存放在方法区的，也称为类的元数据（方法代码、变量名、方法名、访问权限等）	

### Class 常用方法

```
String fullPath = "com.lbw.reflection.Car";
// 1.获取 Car 类对应的 Class 对象
// ? : 表示不确定的 java 类型，可以省略
Class<?> cls = Class.forName(fullPath);
//  2.输出 cls
System.out.println(cls); // 显示 cls 对象，指的 哪个类的 Class 对象
System.out.println(cls.getClass());// 显示 cls 对象的运行类型 java.lang.Class

// 3.得到包名
System.out.println(cls.getPackage().getName());

// 4.得到全类名
System.out.println(cls.getName());

// 5. 通过 cls 创建对象
Car car =(Car)cls.getDeclaredConstructor().newInstance();
System.out.println(car);

// 6. 通过反射获取某个属性(私有属性暂时无法获取)
Field brand = cls.getField("brand");
System.out.println(brand.get(car));
brand.set(car,"奔驰");
System.out.println(brand.get(car));

// 7. 获取所有属性
Field[] fields = cls.getFields();
for (Field field : fields) {
    System.out.println(field.getName() + " : " + field.get(car));
}
```

### 获取 Class 对象	

```
//1. Class 类的静态方法 forName() 获取 (编译阶段)
String fullPath = "com.lbw.reflection.Car"; // 常通过读取配置文件获取
Class<?> cls1 = Class.forName(fullPath);
System.out.println(cls1);

//2. 类名.class 多用于参数传递
Class<Car> cls2 = Car.class;
System.out.println(cls2);

//3. 对象.getClass()  已经存在对象实例
Car car = new Car();
Class cls3 = car.getClass();
System.out.println(cls3);

//4.通过类加载器(4种)来获取类的Class 对象
ClassLoader classLoader = car.getClass().getClassLoader();// 获取类加载器
Class<?> cls4 = classLoader.loadClass(fullPath); // 通过类加载器的 localClass 方法获取
System.out.println(cls4);

// 上面的 cls1，2，3，4 都是同一个

//5.基本数据类型可以通过 .class 获取 Class 对象
Class<Integer> integerClass = int.class;
System.out.println(integerClass);

//6.基本数据类型的包装类，可以通过 .TYPE 获取 Class 对象
Class<Integer> type = Integer.TYPE;
Class<Character> type1 = Character.TYPE;

System.out.println(type);
System.out.println(type1);

System.out.println(integerClass.hashCode());
System.out.println(type.hashCode());
```

### 哪些具有 Class 对象

​	内外部类 、 接口 、 数组 、 枚举 、 注解 、 基本数据类型 、 void

### 类加载

​	通过反射来实现类的动态加载

#### 	静态加载

​		在编译时，加载相关类（即使其中某个类可能不会被使用），如果没有这个类，将会报错，依赖性很强

#### 	动态加载	

​		运行时加载需要的类，运行时不使用该类时，即使该类不存在也不会报错，如果使用到，并没有该类时，才会报错；降低了依赖性

#### 	加载时机 

​		静态加载 ：new 创建对象， 子类对象被创建， 调用静态方法

​		动态加载 ：通过反射创建

### 类加载过程

![image-20251105082110537](C:\Users\Administrator\AppData\Roaming\Typora\typora-user-images\image-20251105082110537.png)

#### 	加载

​		JVM 在该阶段主要的目的是将字节码从不同的数据源（class 文件,jar 包，网络...）转化为二进制字节流加载到内存中，并生成一个代表该类的 java.lang.Class 对象

#### 	连接

##### 		验证

​			目的 ： 确保 Class 文件的字节流中包含的信息符合当前虚拟机的要求，并不会危害虚拟机自身的安全

​			包括 文件格式验证（是否以魔数开头）、元数据验证、字节码验证和符号引用验证

​			可以考虑使用 -Xverify:none 参数来关闭大部分的类验证措施，缩短虚拟机加载时间

##### 		准备

​			JVM在该阶段会对静态变量分配内存并进行默认初始化，这些变量所使用的内存都将在方法区中进行分配

​			使用 final 修饰的 静态变量，将会在此阶段一次性赋值完成，不会负默认值，因为一旦复制后将不可更改

##### 		解释

​			JVM 将常量池中的符号引用替换为 直接引用的过程

#### 	初始化

​		该阶段才真正开始执行类中定义的 Java 程序代码，是执行 <clinit> () 方法的过程

​		 <clinit> () 方法由编译器按照语句在源文件中出现的顺序，依次自动收集类中的所有静态变量的赋值动作和静态代码块中的语句，并进行合并

​		虚拟机将会保证一个类的 <clinit> () 方法在多线程的环境中被正确地加锁，同步，如果多个线程同时去初始化一个类，那么只会由一个线程去执行这个类的 <clinit> ()方法，其他线程都需要阻塞等待，知道活动线程执行 <clinit> ()方法完毕		

### 获取类的结构信息

```
@Test // java.lang.Class
public void api_01() throws Exception {
    Class<?> cls = Class.forName("com.lbw.reflection.Person");
    // getName : 获取全类名
    System.out.println(cls.getName()); // com.lbw.reflection.Person
    // getSimpleName : 获取简单类名
    System.out.println(cls.getSimpleName()); // Person
    // getFields : 获取所有public所修饰的属性，包括本类和父类
    Field[] fields = cls.getFields();
    for (Field field : fields) {
        System.out.println(field.getName());
    }
    // getDeclaredFields : 获取本类中所有的属性
    Field[] declaredFields = cls.getDeclaredFields();
    for (Field field : declaredFields) {
        System.out.println(field.getName());
    }
    // getMethods : 获取所有 public 修饰的方法，包括本类和父类
    Method[] methods = cls.getMethods();
    for (Method method : methods) {
        System.out.println(method.getName());
    }
    // getDeclaredMethods : 获取本类中所有的方法
    Method[] declaredMethods = cls.getDeclaredMethods();
    for (Method method : declaredMethods) {
        System.out.println(method.getName());
    }
    // getConstructors : 获取本类所有 public 修饰的构造器，
    Constructor<?>[] constructors = cls.getConstructors();
    for (Constructor<?> constructor : constructors) {
        System.out.println("本类的构造器" + constructor.getName());
    }
    // getDeclaredConstructors : 获取本类所有的构造器
    Constructor<?>[] declaredConstructors = cls.getDeclaredConstructors();
    for (Constructor<?> constructor : declaredConstructors) {
        System.out.println(constructor.getName());
    }
    // getPackage : 以 Package 形式返回 包信息
    Package aPackage = cls.getPackage();
    System.out.println(aPackage.getName());
    // getSuperclass : 以 Class 形式返回父类信息(父类的 class 对象)
    Class<?> superclass = cls.getSuperclass();
    System.out.println(superclass.getName());
    // getInterfaces : 以class[] 形式返回接口信息
    Class<?>[] interfaces = cls.getInterfaces();
    for (Class<?> anInterface : interfaces) {
        System.out.println(anInterface.getName());
    }
    // getAnnotation : 以 Annotation[] 形式返回注解信息
    Annotation[] annotations = cls.getAnnotations();
    for (Annotation annotation : annotations) {
        System.out.println(annotation.annotationType());
    }

}
```

```
java.lang.reflect.Field
getModifiers : 以 int 的形式返回属性修饰符
	默认：0  public ：1  private ：2 protected ：4  static ：8 final ： 16 （多个修饰符采取叠加措施）
	
getType: 返回该属性对应的那个类(数据类型)的class 对象
getName :返回属性名

java.lang.reflect.Method
getModifiers : 类似
getReturnType : 以class 形式获取返回值的类型
getName : 方法名
getParameterTypes : 以 class[] 形式返回参数类型数组

java.lang.reflect.Constructor
getModifiers : 类似，public 和 默认
getName
getParameterTypes
```

### 反射创建对象

​	调用类的public 修饰的无参构造器

​	调用类的指定有参构造器

​	Class类相关方法

​		newInstance() 无参构造器，但是已经弃用（java 9+）

​		getConstructor(class... parameter) : 根据参数列表，获取指定 public 类型的构造器

​		getDeclaredConstructor(class... parameter) : 根据参数列表，获取指定的构造器

​	Constructor类相关方法

​		setAccessible : 暴破 使反射可以访问 private 修饰的构造器(参数设置为 true)

​		newInstance(Object... obj) : 调用构造器

### 反射访问类的成员

​	当访问私有时，先爆破，在访问

​	访问静态成员时，可以使用 null 代替

​	属性

​		getField  getDeclaredField 方法获取对象的具体属性对象

​		属性对象.set(Object,value) ： 为指定对象 Object 的具体属性设置为 value， 当这个属性被 static 修饰时，可以使用 null 代替 Object

​		属性对象.get(Object) ： 获取一个对象的属性 （静态也可以使用 null）

​	方法 

​		getMethod getDeclaredField （填入方法名字符串后，后面加上方法参数列表的参数类型的class）

​		调用 ： 方法对象.invoke(Object) ：Object 指你要调用哪个对象的方法

​		在反射中，如果方法有返回值，将统一返回 Object 类型，但运行类型还是 String



# MySQL

MySQL 是一个服务，会监听一个端口

安装过程 ：

​	注意 ： 如果在安装过程中发生错误或者想重新安装，请执行 sc delete mysql  删除已经安装好的 mysql 服务，这里要慎重，一定要确定没有其他重要数据啥的，错了就一定要删除相关文件以及清楚mysql服务



![image-20251108153352766](C:\Users\Administrator\AppData\Roaming\Typora\typora-user-images\image-20251108153352766.png)

终端命令

![image-20251108153818640](C:\Users\Administrator\AppData\Roaming\Typora\typora-user-images\image-20251108153818640.png)



### 连接到Mysql服务（Mysql数据库）的指令

​	mysql -h 主机IP -P 端口 -u 用户名 -p密码

​	注意点

​		-p密码之间没有空格

​		-p后不加密码时，回车要求输入密码

​		登录前必须要保证mysql服务已经启动 

​		当不写 -h 和 -P 时，全部默认为本地主机的 3306 端口 （实际开发中，端口号往往会被修改！）

### 图形化管理

​	navicat

​	SQLyog

### 数据库三层结构

​	安装 MySQL 数据库，就是在主机上安装一个数据库管理系统（DBMS datebase manage system）这个管理程序可以管理多个数据库

​	一个数据库可以拥有多张表（不单只有一张表，MySQL数据库中，普通表的本质就是一个文件）

![image-20251108170646850](C:\Users\Administrator\AppData\Roaming\Typora\typora-user-images\image-20251108170646850.png)

表的一行称之为一条记录，在 java 中一条记录常对应着一个对象

### SQL语句分类

​	DDL : 数据定义语句 （表、数据库.....）

​	DML ：数据操作语句 （增加，修改，删除）

​	DQL ：数据查询语句 （查询）

​	DCL ：数据控制语句 （管理数据库，用户权限：grant revoke）

### 创建数据库

​	格式 ：CREATE DATABASE [IF NOT EXISTS] db_name [create_ specification[,create_specification]...]

​	creat_specification : 

​		CHARACTER SET : 设置相关字符集 ，默认 utf8

​		COLLATE :  设置校对规则 默认 utf8_general_ci (不区分大小写)    utf8_ni : 区分大小写

​	if not exitst ： 可以避免当表已经存在时，进行添加引发的报错	

​	CREATE DATABASE hsp_db03 CHARACTER SET utf8 COLLATE utf8_bin;

​	在一个数据库中创建一个表时，如果没有对字符集与校对规则进行设置，则默认按照数据库的字符集和校对规则处理

查看数据库 ： SHOW DATABASES

查看数据库创建语句 ：SHOW CREATE DATABASE db_name

数据库删除语句（一定慎用）：DROP DATABASE[IF EXISTS] db_name

在创建数据库、表时，如果想采用关键字作为名称，可以使用 ``反引号来规避关键字

### 数据库的备份和恢复

​	备份 ：将数据库保存在文件中

​	恢复 ：将数据库从文件中恢复出来

​	备份数据库 ：重点使用 DOS执行命令

​		mysqldump -u 用户名 -p（选加密码，不加则在回车时要求添加） -B 数据库1 数据库2 数据库n > 文件名(可以是路径).sql

​		当想备份某个数据库中的表时采取命令为

​		mysqldump -u 用户名 -p（选加密码，不加则在回车时要求添加）  数据库 表1 表2 > 文件名(可以是路径).sql

​	恢复数据库 ：（进入 Mysql 命令行再执行）

​		Source 文件名.sql

​		第二种： 将备份好的数据从文件中拷贝出来放入查询编辑器中执行一遍

​		当恢复某个数据库的表时，要注意**必须**先切换到具体数据库 （use ...）

### 表的操作

#### 创建

​	![image-20251109110702415](C:\Users\Administrator\AppData\Roaming\Typora\typora-user-images\image-20251109110702415.png)

character set 可以简写为 charset

#### 修改

​	![image-20251109161109325](C:\Users\Administrator\AppData\Roaming\Typora\typora-user-images\image-20251109161109325.png)

​	添加，修改，删除列都不要括号	

​	修改列名 ： alter table tablename  change oldname  newname datatype  ....

#### 删除	

​	drop table tablename

### Mysql常用数据类型（列类型）

![image-20251109112040176](C:\Users\Administrator\AppData\Roaming\Typora\typora-user-images\image-20251109112040176.png)



常用  ：int  double decimal char varchar text datetime timestamp

#### 整数类型

​	使用规范 在能够满足需求的情况下，尽量选择占用空间小的类型

​	bit 类型细节

​		bit 字段进行显示时， 按照 位的方式进行显示（二进制）

​		进行查询时，仍然可以通过添加的数值进行查找

​		如果一个值只有0，1；可以考虑使用 bit（1），节约空间

​		bit （M） ： M 指定位数，默认为1，范围 ： 1~64

​		添加数据范围就是按照你的位数确定

#### 小数类型 

​	decimal[M,D]

​		支持更加精确的小数位，精度高后者范围很大，都可以采用 decimal

​		M 最大 65位， D 最大 30位，D被省略为0，M被省略为10 (小数位不够补 0 ) 

#### 字符串的基本使用

​	char （size）： 固定长度字符串，最大 255 字符

​	varchar （size）：可变长度字符串， size表示字符数，其总共字节范围为：0 ~ 65535， 最大为 65532**字节**！（1~3 个字节用于预留存储字符串长度和行元数据的字节空间，减3） 根据编码不同，其单个字符所占字节不同，即字符数转换后不能超过 65535 字节

​		编码是 utf8 时，最大字符： 65535 / 3 - 1 =21844 字符 （一个字符三个字节）

​		编码是 gbk 时， 最大字符 ： 65535 - 3 / 2 = 32766  字符

​	细节 ：

​		size 表示的永远都是字符数		

​		char （4） 是定长，即使放入一个 ’aa‘ 的内容也会开辟出一个 4 个字符的空间存放

​		varchar (4) 是变长，放入的多少内容开辟多少空间存放（还需要1~3 字节记录存放内容长度）

​		数据定长用 char， 长度不确定用 varchar，查询速度 ： char > varchar

​		存放文本时，可以使用 Text 数据类型 （作为 varchar，varchar 不够用，mediumtext，longtext），没有默认值

#### 日期的使用

​	timestamp 自动更新设置：后面加上  NOT NULL DEFAULT CURRENT_TIMESTAMP ON UPDATE CURRENT_TIMESTAMP



### 数据库CRUD 语句

#### insert 

​	为表添加数据

​		![image-20251109165545411](C:\Users\Administrator\AppData\Roaming\Typora\typora-user-images\image-20251109165545411.png)

​	

​	细节 ：

​		1.插入的数据应与字段的数据类型相同

​		2. 数据的长度应该在列的规定范围之内 (不能将一个12字符的数据放入10字符的列)

​		3. 在values 中列出的数据必须与被加入列的位置相对应

​		4. 字符和日期类型的数据应该使用单引号括起来

​		5. 列可以插入空值（前提该列、字段允许为空！）

​		6. values 可以添加多个数据

​		7. 如果是为所有字段添加数据，可以不用写前面的字段名称，但要求添加数据数与字段书匹配

​		8.默认值的使用，当不为某个字段添加数据时，如果有默认值就会添加，否则报错；

​			如果某个字段没有 not null 修饰，当没有为其添加值时，默认指定null

​			如果想指定某个列的默认值，可以在创建表时使用 default + 默认值

#### update 

​	修改表中数据

​	![image-20251110095354791](C:\Users\Administrator\AppData\Roaming\Typora\typora-user-images\image-20251110095354791.png)

可以是数据，也可以是表达式	

在 mysql 中，字符串拼接无法使用 + 完成（会将其作为数值进行计算），使用 concat（str1,str2）进行拼接

​	细节

​		update 语法 可以用新值更新原有表行中的各列

​		set 子句指示要修改那些列和要给予哪些值

​		where 子句指定要更新哪些行，当 where 不写时，则对整个列进行修改（因此要慎重！）

​		修改多个字段，可以使用 set 字段1 = 值1，....

#### delete 

​	删除表中数据	

​	![image-20251110102720675](C:\Users\Administrator\AppData\Roaming\Typora\typora-user-images\image-20251110102720675.png)

删除某个指定列为空的一条记录 ： where  列 IS NULL  （非空    where 列 IS NOT NULL）	

细节 

​	不加 where 时，将会把表中的数据全部删除

​	Delete不能删除某一列的值（可以使用 update 来将数据改为 null 或 ‘ ’）

​	delete 语句仅能删除记录，不能删除表本身，删除表采用 ：drop table 语句（drop table 表名）

#### select

​	涉及单表和多表

​	![image-20251110111518183](C:\Users\Administrator\AppData\Roaming\Typora\typora-user-images\image-20251110111518183.png)

去重 ：查询的记录，只有每个字段都相同，才会去重

别名问题  ： 可以用 as ，也可以省略；但是别名中间不能出现空格隔开（有就引号括起）

​	![image-20251110120735828](C:\Users\Administrator\AppData\Roaming\Typora\typora-user-images\image-20251110120735828.png)

### where 子句运算符

![image-20251110120842184](C:\Users\Administrator\AppData\Roaming\Typora\typora-user-images\image-20251110120842184.png)

不等于 ：<> , !=

between... and ...  是一个闭区间，包含

![image-20251110135949736](C:\Users\Administrator\AppData\Roaming\Typora\typora-user-images\image-20251110135949736.png)



### 合计/统计函数 

count

![image-20251110142048552](C:\Users\Administrator\AppData\Roaming\Typora\typora-user-images\image-20251110142048552.png)

​	count(*) : 返回满足条件的记录的行数

​	count(column) ： 返回满足条件非空的某列的个数，会主动排除空 null

 sum

​	![image-20251110143725970](C:\Users\Administrator\AppData\Roaming\Typora\typora-user-images\image-20251110143725970.png)

仅对数值起作用；对多列求和，使用 ， 隔开

avg

​	![image-20251110144827711](C:\Users\Administrator\AppData\Roaming\Typora\typora-user-images\image-20251110144827711.png)

max/min

​	![image-20251110145142511](C:\Users\Administrator\AppData\Roaming\Typora\typora-user-images\image-20251110145142511.png)

group by 和 having 子句

​	![image-20251110145940878](C:\Users\Administrator\AppData\Roaming\Typora\typora-user-images\image-20251110145940878.png)

​	常一起使用，先通过 group by 获取不同的小组数据，再通过 having 这个子句对不同的小组数据进行过滤

### 字符串相关函数

​	![image-20251110161810218](C:\Users\Administrator\AppData\Roaming\Typora\typora-user-images\image-20251110161810218.png)

dual 是系统的虚拟表(亚元表)，可以作为测试表使

strcmp 函数   相同为0 ；1 小 2 为 负-1 ；1 大 2 为 正1

ifnull(t1,t2) ：如果t1 为空，返回 t2,不为空返回 t1

### 数学函数

​	![image-20251111075212871](C:\Users\Administrator\AppData\Roaming\Typora\typora-user-images\image-20251111075212871.png)

greatest ：与 least 相反，求最大值

rand : 如果在参数中增加一个种子 seed 只要seed 不变，其返回的随机值不变，范围不变



### 日期时间函数

![image-20251111081859189](C:\Users\Administrator\AppData\Roaming\Typora\typora-user-images\image-20251111081859189.png)

date_add() 、date_sub() 中的 interval 后可以是 year minuter second day

datediff(date1, date2) 获取天数（date1 - date2），因此可能为负

date ~ datediff 中的日期类型可以是 date、datetime、timestamp 

unix_timestamp() : 返回1970-1-1 到现在的秒数

from_unixtime() : 可以将一个 unix_timestamp的秒数转换为指定格式的日期（格式固定）

​	意义 ：可以存放一个整数，表示时间，通过 from_unixtime 进行转换

​	使用 int 保存一个unix时间戳，然后通过 from 进行转换

last_day（日起） ：返回当前日期月份的最后一天

### 加密和系统函数

​	user() : 查询当前使用数据库用户(登入mysql的那些用户和ip号)

​	database() : 查询当前正在使用什么数据库

​	MD5(str)  为字符串计算出一个MD5 32 的字符串，常用于加密(用户密码) （不建议这样加密）

​	password ：mysql 7.6+ 已经被弃用； mysql 8完全移除，

### 流程控制函数

​	if(exp1,exp2,exp3)  如果exp1 为真，返回 exp2 的值 否则返回exp3的值

​	ifnull(exp1, exp2) 如果 exp1 为空，返回exp2 的值，否则返回exp1

​	case when exp1 then expe2 whem exp3 then exp4 ... else expn end

​		多重分支， when then 就是一个if，when 真执行then的表达式,都不真，执行 else 后的表达式 ]

### 查询增强 

​	在 mysql 中，日期类型可以直接比较，需要注意格式

#### 	模糊查询（like操作符）

​		% ： 0~n 字符； _  ： 1字符	

#### 	分页查询

​		基本语法

​			select .... limit start，rows  (写在最后，显示从 start + 1 开始，页会显示的rows 行)

​			start 和 rows 公式 ： 每页显示记录数 *（当前页数 - 1） 每页显示记录数（不能是表达式）

### 书写顺序

​	![image-20251113090716430](C:\Users\Administrator\AppData\Roaming\Typora\typora-user-images\image-20251113090716430.png)

### 多表查询

​	基于两张或者两张以上的表的查询

​	当对两个表进行查询时，默认将第一张表的每一行与第二张表的每列进行组合返回（列是 两表列和，行是 两表行相乘）（该返回结构称为笛卡尔集）

因此解决该问题的最关键是正确的过滤条件

​	当进行多表查询的条件不能少于 表的个数 -1，否则会出现笛卡尔集

#### 	自连接

​		在同一张表的链接查询，即将同一张表看成两张表

​		两张表在查询时要为表取别名，好区分（表名  列名）（如果列名不好区分，也取别名）

#### 	子查询，嵌套查询

​		查询语句嵌套在其他查询语句中，

##### 		单行子查询  

​			子查询返回一行的查询，直接使用等号连接

##### 		多行子查询

​			子查询返回多行的查询，使用 in 关键字链连接子查询

​			子查询作为临时表！！ 解决较多复杂问题

​			all 操作符 所有子查询

​			any 子查询的任意一个

##### 		多列子查询 

​			（字段1，字段2...） = （select 字段1，字段2...from...）

​	多表进行查询时 表名.* 表示该表的所有列，可以简化sql语句，当多个表的列不重复时，才能直接写列名

### 表复制

​	自我复制数据、蠕虫复制

​	对某个sql语句进行效率测试时，需要海量数据，此时就可以使用表复制

​	怎么复制 ：就是将表的原数据再插入（即插入 select * from 表名）

#### 	表的去重

​		创建一张临时表（结构与去重表一致），使用 distinct 将要去重的表中数据加入临时表，删除去重表的数据，然后将临时表的数据加入去重表后删除临时表即可去重

### 合并查询

#### mysql 表外连接

​	左外连接 ：左侧表完全显示，即使左侧表没有与右侧表匹配的，也可以显示左侧表未匹配的内容

​		语法 ：

​			select ... from 表1 left join 表2 on 连接条件 （表1 为左表，表2 为右表）

​	右外连接 ：右侧表完全显示

​		语法 ：

​			select ... from 表1 right join 表2 on 条件 （表1 为左表，表2 为右表）

​	在实际开发过程中，大多数使用情况是多表连接，左右外连接使用不多

### mysql 约束

#### 	primary key ：主键

​		用于唯一的标识表行的数据，当定义主键约束后，该类不能重复

​		细节 ：

​			主键修饰的列存放的数据不能为空或者重复

​			一个表最多只能有一个主键，但可以是复合主键（可以约束多列数据）

​			主键创建方式 ： 直接在字段后面增加 primary key ； 直接在定义表的最后增加 primary key（列，可以是多个列构成复合主键）

​			desc 查看表中主键情况，当看到多个主键是要意识到这是一个复合主键，并不是多个主键

​		实际开发中，往往每个表都会设计一个主键，用来唯一标识

#### 	not null

​		在列上定义了 not null ，在插入数据时必须为该列提供数据

#### 	unique

​		当定义了唯一约束时，该列值是不能重复的

​		细节 ：

​			如果没有指定 not null，则unique字段可以有多个null

​			一个表中可以有多个unique字段

#### 	foreign key ：外键

​		用于定义主表与从表之间的关系 ： 外键约束定义在从表上，主键必须要有主键约束或者unique 约束，当定义外键约束后，要求外键约束的列数据必须在主表的主键列存在或者为null

​		语法 ： foreign key (本表字段)  references 主表名（约束字段）

​		细节 

​			外键指向的表的字段要求时 primary key  或者时 unique

​			表的类型要是 innodb（引擎），这才支持外键

​			外键字段的类型要和主键字段的类型一致，长度可以不同

​			外键字段的值，必须在主键字段中出现过，或者为空，当然前提是外键字段允许为空

​			一旦建立主外键等关系，数据就不能随意删除了



#### 	check

​		用于强制行数据必须满足的条件，当行数据不满足是就会提示出错

​		oracle 和 sql server 均支持 check 但是mysql5.7目前不支持 check，只做语法校验，但不会生效、



### 自增长

​	使某个字段在我们添加数据时自己主动自增添加

​	语法 ： 字段名 字段类型 ... auto_increment

​	添加数据方式 ：

​		insert into 表(字段1，字段2....) values (null,数据,....)

​		insert into 表(字段2,....) values (数据....)

​		insert into 表 values (null,数据,....)

​	细节 ：

​		一般来说，自增长和 主键配合使用

​		自增长也可以单独使用，但需要配合y一个 unique

​		自增长修饰的字段为整数型，可以是小数，但是很少这样使用

​		自增长默认从1开始，但是可以通过alter table 表名 auto_increment = z 来指定自增长

​		如果在添加数据时为自增长的字段添加了数据，将以添加数据为准，如果该添加到数值为目前最大的值，则后续增长值在最大值上+1



### mysql索引

​	提高数据库性能

​	要占用磁盘空间，单独创建一个索引后改变查询条件还是无法做到有效提升

​	索引原理

​		没有索引时，进行全表扫描

​		有索引时，会形成一个索引结构，比如二叉树	

​	代价

​		磁盘占用

​		对于插入，删除和添加时，会对索引进行维护（去了一个节点，又要重新修改一下），造成了效率影响

​		（select 在项目中使用占比远高于 插入、删除、添加）

#### 	类型

​		主键索引 ：主键自动成为主索引，是主键，也是索引

​			创建表时指定字段为 primary key即可创建主键索引

​			创建完表后 执行 alter table 表名 add primary key (要增加主键索引的列)

​		唯一索引 (unique)：

​			create unique index 索引名 on 表名 （列名） 

​		普通索引 （index）：使用最多

​			create index 索引名 on 表名 （列名） 

​			alter table 表名 add index 索引名 （列）

​		全文索引 (fulltext) ：一般开发不适用 mysql 自带的全文索引 ， 开发中主要考虑使用 搜索框架： 全文搜索 Solr 和 ES（ElasticSearch）

​	如何选择 普通和唯一索引 ： 当你能保证能要加索引的字段后面不会重复时，则优先考虑唯一索引，如果会重复，普通索引



#### 	删除索引 

​		普通 ： drop index 索引名 on 表

​		主键索引 ： alter table 表名 drop primary key 

#### 	修改索引 

​		 先删除 再修改

#### 	查询索引

​		show index from 表名 

​		show indexes from 表名

​		show keys from 表名

​		desc 表名 （MUL 就表示一个索引）

#### 小结 

​	哪些列应该加上索引

​		较频繁的作为查询条件字段应该创建索引

​		唯一性太差的字段不适合单独创建索引，即使频繁使用该字段作为查询条件

​		更新非常频繁的字段不适合创建索引

​		不会出现在 where子句中的字段不该创建索引

### mysql事务

​	保证数据一致性，由一组dml语句组成

​	dml(增删改语句)，将一组增删改语句作为一个整体，这个整体要么全部成功，要么全部失败，不能出现有成功有失败，因此引入事务来解决这种需求

#### 	事务与锁

​		当执行事务操作时，msql会在表上增加锁，防止其他用户改变表的数据，对用户来讲十分重要

#### 	控制台事务的几种操作

​		start transaction  ： 开始事务

​		savepoint 保存点名 ： 增加一个保存点

​		rollback 保存点名 ： 回滚到保存点时的状态

​		rollback ： 回滚到开始事务时的状态

​		commit ： 提交事务，提交后所有dml 命令全部生效，无法再进行回滚

​	示意图 ：

​		![事务操作示意图](C:\Users\Administrator\Desktop\JavaSE\image\事务操作示意图.png)

​	回退事务执行回滚到某个保存点a时，无法再回滚到a之后创建的保存点（删除之后创建的保存点），

​	回退事务

​		保存点：savepoint ，用于取消部分事物，当事务结束时（提交），会自动删除该事务所定义的所有保存点。当执行回退事务时，通过指定保存点可以回退到指定的点

​	提交事务

​		使用 commit 语句可以提交事物，当执行了commit语句后，会确认事务的变化、结束事物、删除保存点、释放锁，数据生效。当使用 commit 语句结束事务后，其他会话（其他连接）将可以查看到事务变化后的新数据（所有数据正式生效）

#### 	事务隔离级别

​		多个连接开启各自事务操作数据库中数据时，数据库系统要负责隔离操作，以保证各个连接在获取数据时的准确性

​		当不考虑隔离性时，会引发 ： 脏读，不可重复读，幻读

![事务隔离级别](C:\Users\Administrator\Desktop\JavaSE\image\事务隔离级别.png)

​		脏读 ：当一个事物读取另一个事务还未提交的修改时，产生脏读

​		不可重复读 ：同一查询在同一事务中多次进行，由于其他提交提交事物所做的修改或删除，每次返回不同的结果集，发生不可重复读

​		幻读 ：同一查询在同一事务中多次进行，由于其他提交事务所做的插入操作，每次返回不同的结果集，发生幻读

#### 	相关指令操作

	-- 1.查看当前会话的隔离级别
	SELECT @@tx_isolation;
	
	-- 2.查看系统当前的隔离级别
	SELECT @@global.tx_isolation;
	
	-- 3.设置当前会话的隔离级别
	-- set session transaction isolation level 隔离级别
	
	-- 4.设置当前系统的隔离级别
	-- set global transaction isolation level 隔离级别
	
	-- 5. mysql 的默认隔离级别就是 repeatable read ，一般情况下，没有特殊需求，都不用进行修改，可以满足大部分项目需求；
	-- 如果要修改，在配置文件 my.ini 加上 ： transaction-isolation = 指定隔离级别
#### 	事务的acid特性

​		原子性 Atomicity

​			指事务是一个不可分割的工作单位，事务中的操作要么全部发生，要么都不发生

​		一致性 Consistency

​			事务必须使数据库从一个一致性状态变换到另一个一致性状态

​		隔离性 Isolation

​			多个用户并发访问数据库时，数据库为每个用户开启的事物，不能被其他事物的操作数据所干扰，多个并发十五之间要有相互隔离	

​		持久性 Durability

​			一个事物一旦被提交，他对数据库中数据的改变就是永久性的，接下来即使数据库发生故障也不应该对其有任何影响	

### mysql表类型和存储引擎

​	MySQL 的表类型有存储引擎决定，主要包括 MyISAM、innoDB、Memory等

​	主要支持六中类型 ：

​		CSV、Memory、ARCHIVE、MRG_MYISAM、MYISAM、InnoDB

​		分两类：

​		事物安全型 ：InnoDB

​		非事物安全型 ：mysiam、memory

主要存储引擎特点

![主要存储引擎特点](C:\Users\Administrator\Desktop\JavaSE\image\主要存储引擎特点.png)

​	![image-20251118104211422](C:\Users\Administrator\AppData\Roaming\Typora\typora-user-images\image-20251118104211422.png)

memory 更加适合临时表

存储引擎选择

![image-20251118110150605](C:\Users\Administrator\AppData\Roaming\Typora\typora-user-images\image-20251118110150605.png)



修改存储引擎 ： alter table  表名 engine = 引擎



### 视图

​	是一个虚拟表，其内容由查询定义，同真实的表一样，视图包含列，其数据来源于对应的真实表（基表）

​	视图是根据基表（一个或多个）创建的，视图是虚拟的表

​	通过9 修改视图可以来修改基表的数据，也可以通过基表的修改来修改视图的数据

#### 	基本使用

​		create view 视图名 as select语句

​		alter view 视图名 as select语句  ：更新生成新的视图

​		show create view 视图名

​		drop view 视图名1，视图名2...

#### 	细节 

​		创建视图后，到数据库去看，对应视图只有一个视图结构文件（视图文件名.frm）

​		视图与基表数据相互关联（映射），修改其中一个则会导致另一个的修改

​		可以再视图中再使用视图	

​	实践

​	![image-20251118144330497](C:\Users\Administrator\AppData\Roaming\Typora\typora-user-images\image-20251118144330497.png)

### mysql 用户管理

​	mysql中的用户，都存储在系统数据库mysql 中的user 表中



​	不同的数据库用户，操作的库和表不相同

​	user表重要字段：

​		host ：运行登录的位置，localhost 表示该用户只允许本机登录，也可以指定ip地址

​		user ： 用户名

​		authentication_string ：密码，通过mysql的password函数加密后的密码

#### 	创建用户

​		create user '用户名'@‘运行登录的位置’ identified by '密码'

​			创建用户，同时指定登录密码

#### 	删除用户

​		drop user '用户名'@‘运行登录的位置’

#### 	用户修改密码

​		修改自己 ： set password = password('密码');

​		修改其他人的密码 ： set password for '用户名'@‘登录地址’ = password（‘密码’） （需要权限）

#### 	用户权限管理

##### 		给用户授权 

​			 grant 权限列表 on 库.对象 to '用户名'@'登录地址' 【identified by '密码'】

​			权限列表 ： 多个权限用 ，隔开，授予全部权限 ： all [privileges]

​			 库.对象 : 

​				\*.\* : 代表本系统中的所有数据库的所有对象（表、视图、存储过程）

​				库.\* : 某个数据库中的所有数据对象

​			identified by '密码' ： 写上时，如果用户存在，表示授权时同时修改密码；如果不存在，表示创建用户并授权

##### 		回收用户权限

​			revoke 权限列表/ all on 库.对象 from '用户名'@'登录地址'

​		权限刷新指令

​			flush privileges  

#### 	细节

​		创建用户时，如果不指定 Host ，则默认分配 % ，表示所有ip都有连接权限

​		创建用户时，host值可以指定为ip地址，可以是用 % 来表示某一段网络来登录 mysql

​		删除用户时，如果host 值不是 %，则需要明确指定 '用户'@'host'

## JDBC和数据库连接池

​	JDBC 为访问不同的数据库提供了统一的接口，为使用者屏蔽一些细节问题

​	Java 程序员使用 JDBC，可以连接任何提供了JDBC 驱动程序的数据库系统，从而完成对数据库的各种操作

JDBC原理示意图：

​	![image-20251120143019204](C:\Users\Administrator\AppData\Roaming\Typora\typora-user-images\image-20251120143019204.png)

好处

​	JDBC 是 java 提供的一套用于数据库操作的接口 API ，java程序员只需要面对这套接口编程就行（接口编程思想），不同数据库厂商，需要针对这套接口提供不同的实现

JDBC API

 	相关类和接口在 java.sql 和 javax.sql

### JDBC 程序编写步骤

​	注册驱动 ：加载 Driver 类

​	获取连接 ： 得到 Connection

​	执行增删改查 ： 发送 SQL 语句 给数据库执行

​	释放资源 ： 关闭相关连接

```
简单实例 dml 语句
public static void main(String[] args) throws SQLException {
    // 前置工作 ： 在项目下创建一个文件夹
    // 将 mysql.jar 拷贝到该目录下，点击添加为库 添加到项目中
    //1. 注册驱动 因为 jar 是 8.0 的推荐 Driver 是com.mysql.cj.jdbc.Driver，避免类过时报错
    Driver driver = new Driver();
    //2. 获取连接
    /*
    * jdbc:mysql://localhost:3306/hsp_db02
    * jdbc:mysql:// 一个协议,固定写法
    * localhost:3306 数据库登录 ip 和 端口号
    * hsp_db02 : 使用哪个数据库
    * */
    String url = "jdbc:mysql://localhost:3306/hsp_db02";
    Properties properties = new Properties(); // 存放用户名与密码
    properties.setProperty("user", "root");
    properties.setProperty("password", "lbw");
    // 使用 driver 的connect 方法获取到一个连接，
    // 方法两个参数 ： 一个就是描述连接哪个数据库的字符串，
    // 另一个就是存放了用户名与密码的 Properties 集合
    Connection connect = driver.connect(url, properties);// 根据给定url连接数据库
    //3. 执行sql
    // 通过 statement 对象的 executeUpdate 方法执行sql语句（针对于 dml 语句）
    // statement 的 Query 方法执行sql查询语句
    // 返回执行后影响的行数，
    Statement statement = connect.createStatement();
    String sql = "insert into actor value(null,'李四','男','2010-10-10','123')";
    int row = statement.executeUpdate(sql);
    System.out.println( row > 0 ? "成功" : "失败");
    //4. 释放资源

    statement.close();
    connect.close();
}
```



### 获取数据库连接的方式

​	创建 Driver 对象， 通过其方法 connect 获取连接

​		静态加载，灵活性差，依赖性强

​	反射获取 Driver 对象

​		动态加载，更加灵活，减少依赖

​	使用 DriverManager 替代 Driver 进行统一管理

​		还是反射获取 Driver 对象，DriverManager.registerDriver() 注册 Driver 驱动， 再通过DriverManager.getConnection 方法获取 connection

​	使用 Class.forName 自动完成注册驱动，简化代码 （推荐，使用最多）

```
static { 在 Class.forName 加载 Driver 时，自动完成来 注册 Driver 驱动
    try {
        DriverManager.registerDriver(new Driver());
    } catch (SQLException var1) {
        throw new RuntimeException("Can't register driver!");
    }
}
```

​		甚至在高版本（mysql 驱动 5.1.6）不需要使用 Class.forName 加载类信息就可以获取 连接

​			jdk1.5以后使用 jdbc4，不需要显示调用 Class.forName() 注册驱动而是自动调用驱动jar包下的 META-INF\services\java.sql.Driver 文本的类名称注册，但是还是建议写上，更加明确

​	使用配置文件，避免写死（在4的方式上进行改进）

​		properties 读取配置文件，

​		然后加载类信息，创建连接



### ResultSet

​	表示数据库结果集的数据表，通常由执行查询数据库的语句生成

​	ResultSet 对象保持一个光标指向其当前的数据行。最初该光标位于第一行之前

​	next 方法会将光标移动到下一行，并且由于在ResultSet 对象中没有更多行时返回 false，可以使用while循环中循环遍历结果集（集合迭代器）

​	ResultSet 是一个接口

​	真实存放数据结构图

![image-20251121135923446](C:\Users\Administrator\AppData\Roaming\Typora\typora-user-images\image-20251121135923446.png)

#### 关于 ResultSet 结果集的 getDate 方法细节

​	getDate 方法将会返回 java.sql.Date 类型的日期，可以直接通过 java.util.Date 直接接收，

​	如果想使用 LoacalDateTime 类型进行接受时，会抛出无法进行类型转换的错误，此时可以先通过 java.sql.Date 类型接受getDate

​	然后调用 Date 类型的 ： toLocalDate().atStartOfDay() 方法进行转换	

一个示例

```
LocalDateTime birthday = resultSet.getDate(4).toLocalDate().atStartOfDay();
// 直接解决通过 ResultSet 的get方法实现java.sql.Date 类型装换为 java.time.LocalDateTime
```

数据库的DATETIME/TIMESTAMP 类型的日期数据默认映射成java.time.LocalDateTime数据，无法赋值给 Date 类型数据，因此要注重数据库与 类之间数据类型的一致避免类型不一致导致的赋值失败



### Statement

​	Statement 对象（实现了该接口的类） 用于执行静态SQL语句并返回其生成的结果的对象

​	在建立连接后，需要对数据库进行访问，执行 命名或SQL语句，可以通过

​		Statement  ： 存在 SQL 注入的问题

​		PreparedStatement ：预处理

​		CallableStatement ： 存储过程

#### 	SQL 注入 

​		利用某些系统没有对用户输入的数据进行充分的检查，而在用户输入数据中注入非法的 SQL 语句端或命令，恶意攻击数据库

​	防范 SQL 注入，采用 PreparedStatement 取代 Statement 



### PreparedStatement		

​	PreparedStatement 执行的 SQL 语句中的参数用问号 ？（一个占位符） 进行标识，调用 PreparedStatement 对象的 setXxx（） 方法来设置这些参数。

​	set 方法有两个参数，第一个参数是要设置的SQL 语句的参数的索引（1 开始），第二个是设置的 SQL 语句的参数值

​	executeQuery 和 executeUpdate 两个方法与 Statement  用法类似，但不再需要添加 参数

```
String query = "select `name`, pwd from manager where `name` = ? and pwd = ?";
PreparedStatement preparedStatement = connection.prepareStatement(query);
preparedStatement.setString(1,user1);
preparedStatement.setString(2,pwd);
ResultSet resultSet = preparedStatement.executeQuery();
```

​	好处

​		不再使用 + 拼接 sql 语句，减少语法错误

​		有效的解决 sql 注入问题

​		大大减少了编译次数，效率较高

### JDBC API

​	![image-20251121170206918](C:\Users\Administrator\AppData\Roaming\Typora\typora-user-images\image-20251121170206918.png)

![image-20251123084509945](C:\Users\Administrator\AppData\Roaming\Typora\typora-user-images\image-20251123084509945.png)

### 封装JDBCUtils 

​	将连接、关闭连接封装进一个工具类，调用该类的方法进行获取和关闭连接

​	对于处理编译异常问题，一般情况下将其转换为运行异常，这时调用者可以根据需求来选择捕获该异常，也可以进行默认处理该异常

### 事务

​	JDBC 程序中，创建的 Connection 对象 时，默认是自动提交事务，即每执行一个sql语句时，如果执行成功就自动向数据库提交，不能进行回滚

​	JDBC 程序为使多个 sql 语句作为一个整体执行，就需要使用事务

​	调用 Connection 的 setAutoCommit(false) 方法来取消自动提交事务

​	在所有 sql 语句全部执行成功后，执行Connection 的 commit（） 方法来提交事务

​	如果某个操作失败或出现了异常 ，执行 Connection 的 rollback （） 方法来回滚事务

### 批处理

​	当需要成批插入或者更新记录时，可以采用java 的批量更新机制，允许多条语句一次性提交到数据库批量处理，通常情况下比单独提交处理更有效率

#### 批处理语句

​	addBatch() ：添加需要批量处理的sql语句或参数

​	executeBatch() ： 执行批量处理语句

​	clearBatch() ：清空批处理包中的语句

​	JDBC 连接 MySQL 时，如果要使用批处理功能，要在 url 中 写入 **?rewriteBatchedStatements=true**

​	批处理往往与 PreparedStatement 一起搭配使用，减少编译次数、运行次数，提高效率

```
public void batch() throws SQLException {
    Connection connection = JDBCUtils.getConnection();
    String sql = "insert into admin2 values(null,?,?)";
    PreparedStatement preparedStatement = connection.prepareStatement(sql);
    long start = System.currentTimeMillis();
    for(int i = 0; i < 5000; i++) {
        preparedStatement.setString(1,"jack" + i);
        preparedStatement.setString(2,"666");
        preparedStatement.addBatch();
        /* 
        public void addBatch() throws SQLException {
            try {
                synchronized(this.checkClosed().getConnectionMutex()) {
                    QueryBindings queryBindings = ((PreparedQuery)this.query).getQueryBindings();
                    queryBindings.checkAllParametersSet(); // 检查 添加的占位符
                    this.query.addBatch(queryBindings.clone()); 
                    // 存放sql语句 到 query 的 batchArgs(一个 ArrayList 集合) 中
                }
            } catch (CJException var6) {
                throw SQLExceptionsMapping.translateException(var6, ((StatementImpl)this).getExceptionInterceptor());
            }
        }

        
         */
        
        if((i + 1) % 1000 == 0) {
            preparedStatement.executeBatch();
            preparedStatement.clearBatch();
        }
    }
    long end = System.currentTimeMillis();
    System.out.println("总耗时 " + (end - start)); // 101
    JDBCUtils.close(null,preparedStatement,connection);
}
```



### 数据库连接池

​	传统连接方式的问题

![image-20251123121926082](C:\Users\Administrator\AppData\Roaming\Typora\typora-user-images\image-20251123121926082.png)

#### 	基本介绍

​		预先在连接池中放入一定数量的连接，当需要建立数据库连接时，从连接池中取出一个，使用完毕后**放入**连接池（放入，不是关闭）

​		数据库连接池负责分配、管理和释放数据库的连接，允许一个应用程序重复使用一个数据库连接，而不是重新建立一个数据库连接

​		当应用程序申请的连接数大于连接池中的连接数时，多余的连接数据库请求会被加入到等待队列中

#### 	种类

​		JDBC 的数据库连接池使用 javax.sql.DataSource 来表示，DataSource 是一个接口，该接口由第三方来进行实现

​		**C3P0** 数据库连接池，速度相对较慢（只是比起其他连接池，比原本的JDBC的创建快），稳定性不错 （hibernate、spring 底层采用该连接池）

​		DBCP 数据库连接池，速度相对于 C3P0快，但不稳定

​		Proxool 数据库连接池，由监控连接池状态的功能，稳定性较 C3P0 差一点

​		BoneCP 数据库连接池，速度快	

​		**Druid**（德鲁伊） 阿里提供的数据库连接池，集DBCP、C3P0、Proxool 优点于一身的数据库连接池



### C3P0 数据库连接池

​	配置 ： 引入c3p0相关jar包（在0.9.2 版本后还需要引入mchange-commons-java包作为依赖），然后添加为库文件

```
// 方式一 ： 相关参数在程序中指定 user 、url、password
    @Test
    public void c3p0() throws IOException, PropertyVetoException, SQLException {

        // 获取 数据源对象
        ComboPooledDataSource comboPooledDataSource = new ComboPooledDataSource();

        // 读取配置文件
        Properties properties = new Properties();
        properties.load(new FileInputStream("src\\mysql.properties"));
        String user = properties.getProperty("user");
        String password = properties.getProperty("password");
        String url = properties.getProperty("url");
        String driver = properties.getProperty("class");

        // 给数据源 comboPoolDataSource 设置相关参数

        comboPooledDataSource.setJdbcUrl(url);
        comboPooledDataSource.setUser(user);
        comboPooledDataSource.setPassword(password);
        comboPooledDataSource.setDriverClass(driver);

        // 设置初始化连接数
        comboPooledDataSource.setInitialPoolSize(10); // 表明程序运行开始时，就有10个数据库连接

        // 设置最大连接数 表示当连接池中的连接数少于最大连接数时，会自动扩容，直到达到最大连接数时，多余进入等待队列
        comboPooledDataSource.setMaxPoolSize(50);


		Connection connection = comboPooledDataSource.getConnection();

        System.out.println("连接成功!");
        connection.close();

     

    }

    // 第二种方式 使用配置文件模板完成
    // 将 c3p0 提供的  c3p0-config.xml(一定要这个名字) 文件拷贝到src目录下
    // 该文件指定了连接数据库和连接池 的相关参数
    @Test
    public void c3p0_2() throws SQLException {
//        将配置文件中的配置名写入构造器
        ComboPooledDataSource comboPooledDataSource = new ComboPooledDataSource("mysql");
        Connection connection = comboPooledDataSource.getConnection();

        System.out.println("连接成功");
        JDBCUtils.close(null,null,connection);
       
    }
```

​	配置文件 模板：c3p0-config.xml

```
<?xml version="1.0" encoding="UTF-8"?>
<c3p0-config>
    <!-- 默认配置（若不指定命名配置则使用此配置） -->
    <default-config>
        <!-- 数据库驱动（使用 8.0 系列的新驱动类） -->
        <property name="driverClass">com.mysql.cj.jdbc.Driver</property>
        <!-- 数据库连接地址（替换为你的数据库名，如 hsp_db02） -->
        <property name="jdbcUrl">jdbc:mysql://localhost:3306/hsp_db02</property>
        <!-- 数据库用户名 -->
        <property name="user">root</property>
        <!-- 数据库密码 -->
        <property name="password">lbw</property>
        <!-- 每次增长的连接数 -->
        <property name="acquireIncrement">5</property>
        <!-- 初始化连接数 -->
        <property name="initialPoolSize">5</property>
        <!-- 最小连接数 -->
        <property name="minPoolSize">5</property>
        <!-- 最大连接数 -->
        <property name="maxPoolSize">20</property>
        <!-- 最大空闲时间（秒，0 表示永不回收） -->
        <property name="maxIdleTime">30</property>
    </default-config>

    <!-- 命名配置（可自定义名称，） -->
    <named-config name="mysql">
        <property name="driverClass">com.mysql.cj.jdbc.Driver</property>
        <property name="jdbcUrl">jdbc:mysql://localhost:3306/hsp_db02?serverTimezone=Asia/Shanghai&amp;useSSL=false</property>
        <property name="user">root</property>
        <property name="password">lbw</property>
        <property name="initialPoolSize">10</property>
        <property name="acquireIncrement">5</property>
        <property name="minPoolSize">5</property>
        <property name="maxPoolSize">30</property>
        <!-- 可连接的最多的命令对象数 -->
        <property name="maxStatements">5</property>
        <!-- 每个连接对象可连接的最多的命令对象数 -->
        <property name="maxStatementsPerConnection">2</property>
    </named-config>
</c3p0-config>
```



### Druid(德鲁伊) 数据库连接池

​	配置 ： 加载 Druid jar 包；拷贝配置文件到 src 目录下，名字随意（druid.properties）

​	创建Properties对象，读取配置文件

​	DruidDataSourceFactory.createDataSource(properties) 创建数据源，数据源获取数据库连接

```
Properties properties = new Properties();
properties.load(new FileInputStream("src\\druid.properties"));

//4. 创建数据库连接池
DataSource dataSource = DruidDataSourceFactory.createDataSource(properties);
Connection connection = dataSource.getConnection();

System.out.println("连接成功！");
connection.close();
```



### Apache-DBUtils

​	commons-dbutils 是 Apache 组织提供的一个开源 JDBC 工具类库，对JDBC的封装，使用dbutils能极大简化jdbc编码的工作量

DButils 类

​	QueryRunner 类 ： 

​		该类封装了SQL的执行，是线程安全的，可以实现增删改查批处理

​		使用QueryRunner 类实现查询

​	ResultSetHandler接口 ： 用于处理 java.sql.ResultSet，将数据按要求转换成另一种形式

![image-20251203084031711](C:\Users\Administrator\AppData\Roaming\Typora\typora-user-images\image-20251203084031711.png)	

​	关闭 connection 后，resultSet 结果集（与 connection 相关联）无法使用，难以确定关闭连接时机

​	resultSet 不利于数据管理，使用返回信息不方便

原来实现 ：创建一个类（也称 javaBean,POJO,Domain），与查询数据相关联（有什么数据创建什么属性），创建一个 ArrayList 集合存放该类的对象

```
简单实现
public void testQuery() throws SQLException {
    // 获取连接
    Connection connection = JDBCUtilsByDruid.getConnection();
    // 引入 BDUtils 相关的 jar 包 : commons-dbutils-1.8.1.jar，添加配置文件
    // 创建 QueryRunner 对象
    QueryRunner queryRunner = new QueryRunner();
    // 通过 QueryRunner 对象执行相关方法获取 ArrayList 结果集
    String sql = "select * from actor where id = ?";
    List<Actor> list = queryRunner.query(connection, sql, new BeanListHandler<>(Actor.class),1);
    // 解读 ：
    // query 会在执行sql语句后，将查询到的 ResultSet 结果集 封装到 ArrayList 集合中，并返回该集合
    // 参数 ： connection ： 数据库的连接， sql ： 执行的sql语句
    // new BeanListHandler<>(Actor.class) : 将 ResultSet 转变成 Actor 然后封装到 ArrayList中，其中
    //  Actor.class 是底层通过反射机制了解 Actor 到底有哪些属性，然后进行封装
    // 后面的参数是会传递到 sql 语句的 ？ 号, 如果sql语句没有 ？ 则不要设置参数
    // 底层获取的 ResultSet 方法将会在query 方法中关闭，还会关闭 PreparedStatement (底层还是会创建这个查询的)

    System.out.println(list);

    JDBCUtilsByDruid.close(null,null,connection);
}
```

```
query 源码
public <T> T query(Connection conn, String sql, ResultSetHandler<T> rsh, Object... params) throws SQLException {
    if (conn == null) {
        throw new SQLException("Null connection");
    } else if (sql == null) {
        throw new SQLException("Null SQL statement");
    } else if (rsh == null) {
        throw new SQLException("Null ResultSetHandler");
    } else {
        Statement stmt = null;
        ResultSet resultSet = null;
        T result = null;

        try {
            if (params != null && params.length > 0) {
                PreparedStatement ps = this.prepareStatement(conn, sql);
                stmt = ps;
                this.fillStatement(ps, params); // 填充 sql 语句中的 占位符
                resultSet = this.wrap(ps.executeQuery()); // 执行sql 语句并获取结果集
            } else {
                stmt = conn.createStatement();
                resultSet = this.wrap(stmt.executeQuery(sql));
            }

            result = (T)rsh.handle(resultSet); // 会返回一个存放 T 类型的 集合
        } catch (SQLException e) {
            this.rethrow(e, sql, params);
        } finally {
            this.closeQuietly(resultSet);
            this.closeQuietly(stmt);
        }

        return result;
    }
}
```

​	返回多行查询结果 ：query方法  ： BeanListHandler<>(Actor.class)

​	单行查询 ： query方法  BeanHandler<>(Actor.class)

​	单行单列 ：query方法  ScalarHandler()

​	执行 DML 语句 ： update

数据表与 JavaBean 的类型映射

​	![image-20251125143226984](C:\Users\Administrator\AppData\Roaming\Typora\typora-user-images\image-20251125143226984.png)



### BasicDao

​	基础的DAO（数据访问对象），完成通用的增删改查通用方法

引出不足 （apache-dbutils + Druid）

​	SQL 语句固定，不能通过参数传入，通用性不好，需要进行改进，更方便执行增删改查

​	对于 select 操作，如果有返回值，其返回类型不能固定，需要使用泛型

​	未来数据库的表很多，业务需求复杂，不可能只靠一个java类搞定

基本说明 ： 

​	DAO ： data access object 数据访问对象

​	这样的通用类，称为 BasicDao，专门和数据库交互的，即完成对数据库（表）的 crud操作

​	在 BasicDao 基础上，实现一张表对应一个Dao，更好的完成功能

![image-20251126083536303](C:\Users\Administrator\AppData\Roaming\Typora\typora-user-images\image-20251126083536303.png)



简单划分 ：

​	 	![image-20251125210703731](C:\Users\Administrator\AppData\Roaming\Typora\typora-user-images\image-20251125210703731.png) 

分四个部分 ： dao（实现crud，每个表一个dao，父类BasicDAO，实现相同操作)，domain（javaBean)，test（测试)和utils（存放工具)



账单号生成 ： UUID （UUID.randomUUID.toString() 生成一个随机账单号）



多表联合查询时，JavaBean 的属性名因与表的列明保持一致（规范），当属性名冲突时，可以通过为数据库表的列名取别名（与javaBean的属性名一致）



## 正则表达式（regular expression  RegExp）

​	专门用于处理文本问题，正则表达式技术是对字符串执行模式匹配的技术

```
public static void main(String[] args) {

        String content = "1998年12月8日，第二代Java平台的企业版J2EE发布。" +
                "1999年6月，Sun公司发布了第二代Java平台（简称为Java2）的3个版本：" +
                "J2ME（Java2 Micro Edition，Java2平台的微型版），应用于移动、无线及有限资源的环境；" +
                "J2SE（Java 2 Standard Edition，Java 2平台的标准版），应用于桌面环境；" +
                "J2EE（Java 2Enterprise Edition，Java 2平台的企业版），应用于基于Java的应用服务器。" +
                "Java 2平台的发布，是Java发展过程中最重要的一个里程碑，标志着Java的应用开始普及。";

        // \\d 表示匹配任意数字(前面 \ 为转义)
//        String regex = "\\d\\d\\d\\d";
        String regex = "(\\d\\d)(\\d\\d)";
        // 分组 : 当匹配规则中有 () 时，一个()表示一个分组，第一个() 就是第一组.....
        // 创建模式对象(正则表达式对象)
        Pattern pattern = Pattern.compile(regex);

        // 创建匹配器
        // 创建一个匹配器，按照模式对象的匹配规则，从 content 中查找相关的字符串
        Matcher matcher = pattern.matcher(content);

        // 循环匹配
        /*
          matcher.find() 完成的任务
          1. 根据匹配规则，找到满足规则的子字符串
          2. 找到子字符串后，将 子字符串的开始的索引记录到 matcher 的 group 数组中(int)
                2.1 将 group[0] 设置为 子字符串的开始位置，将子字符串的结束索引 +1 放入 group[1]中
                2.2 根据分组情况，将第一组匹配达到的字符串记录到 group[2] 和 group[3],记录索引与上相同
                2.3 将第二组匹配达到的字符串记录到 group[4] 和 group[5] ....
          3. 同时记录oldLast 的值为 子字符串的结束索引 +1,使下次执行find时，从oldLast开始匹配

          matcher.group(0) :
            源码：
            public String group(int group) {
                if (first < 0)
                    throw new IllegalStateException("No match found");
                if (group < 0 || group > groupCount())
                    throw new IndexOutOfBoundsException("No group " + group);
                if ((groups[group*2] == -1) || (groups[group*2+1] == -1))
                    return null;
                return getSubSequence(groups[group * 2], groups[group * 2 + 1]).toString();
            }
            根据你传递的 group 参数，从 content 中截取 [groups[group * 2], groups[group * 2 + 1]) 即
            截取 [0,4) 的子字符串

            再次执行 find 方法时，将会按照上面的规则从 oldLast 开始重新再来一遍，并将group[0] 和 group[1] 覆盖

         */

        while(matcher.find()) {
            // 如果正则表达式有 () 分组
            // 取出的匹配子字符串规则如下：
            // group(0) : 表示匹配到的子字符串
            // group(1) : 表示匹配到的子字符串的第一组
            // group(2) : 表示匹配到的子字符串的第2组 .....
            // 分组的数不能越界

            System.out.println(matcher.group(0));
            System.out.println(matcher.group(1));
            System.out.println(matcher.group(2));
        }
    }
```

### 正则表达式语法

元字符 划分（功能）

​	限定符、选择匹配符、分组组合和反向引用符、特殊字符、字符匹配符、定位符		 

#### 元字符-转义号 ：\\\\

​	\\\\ ：当使用正则表达式去检索某些特殊字符时，需要使用到转义符号，否则可能检索不到结果，甚至报错

​	java 中 转义字符是 \\\ ,其他语言为 \\

​	![image-20251130094941433](C:\Users\Administrator\AppData\Roaming\Typora\typora-user-images\image-20251130094941433.png)

#### 字符匹配符	

![image-20251130100147398](C:\Users\Administrator\AppData\Roaming\Typora\typora-user-images\image-20251130100147398.png)

![image-20251130100334743](C:\Users\Administrator\AppData\Roaming\Typora\typora-user-images\image-20251130100334743.png)

\\\\w ： 也包括了下划线！

\\\\s ：匹配任何空白字符（空格、制表符）

\\\S ： 匹配任何非空白字符

匹配 . ：\\\\. 

默认情况下，正则表达式区分大小写，如果想让其不区分大小写，有以下方法

​	（?i）：

​	创建正则表达式对象(Pattern)时，添加一个参数 ： CASE_INSENSITIVE



#### 选择匹配符

​	匹配某个字符串时是选择性的，即既可以是这个，也可以是那个

​	| ： 匹配 “|” 之前或之后的表达式



#### 限定符

![image-20251130133220342](C:\Users\Administrator\AppData\Roaming\Typora\typora-user-images\image-20251130133220342.png)

![image-20251130133526067](C:\Users\Administrator\AppData\Roaming\Typora\typora-user-images\image-20251130133526067.png)

 	java匹配时是贪婪匹配，会尽可能匹配最多的



#### 定位符

​	规定要匹配的字符串出现的位置

​	![image-20251130135239140](C:\Users\Administrator\AppData\Roaming\Typora\typora-user-images\image-20251130135239140.png)



### 分组

#### 捕获分组

​	![image-20251130141359823](C:\Users\Administrator\AppData\Roaming\Typora\typora-user-images\image-20251130141359823.png)

​	命名捕获 ：相当于别名，group方法存在重载，写入别名时返回指定分组内容

#### 非捕获分组 

​	![image-20251130152037216](C:\Users\Administrator\AppData\Roaming\Typora\typora-user-images\image-20251130152037216.png)



非贪婪匹配

​	后接 ？，使其尽可能少的匹配字符



匹配汉字 ：^[\\\\u4E00-\\\\u9FA5]+$

当 ？ . 写入中括号时，表示匹配该符号本身，即写入[] 中的符号都表示自身符号



### 正则表达式三个常用类

 	java.util.regex 包 

#### Pattern

​	对象是一个正则表达式对象。Pattern没有公共的构造方法，要创建对象则通过公共静态方法来返回 Pattern 对象，该方法接受一个正则表达式作为他的第一个参数

​	常用方法 

​		matches 方法 ：从整体角度上进行比较，用于验证输入的字符串是否符合使用条件

​				底层还是 Matcher 的matches方法执行，就单纯封装了一下

#### Matcher

​	Matcher 对象是对输入字符串进行解释和匹配的引擎，也没有公共的构造方法，通过调用 Pattern 对象的 matcher方法h获取Matcher对象

​	常用方法 

![image-20251130171156699](C:\Users\Administrator\AppData\Roaming\Typora\typora-user-images\image-20251130171156699.png)

![image-20251130182916471](C:\Users\Administrator\AppData\Roaming\Typora\typora-user-images\image-20251130182916471.png)		

​	find 方法 ： 从局部来进行匹配，局部有符合子串就可以

​	replaceAll ：返回新的字符串（将符合正则表达式的字串替换为 参数，不会影响原字符串）

​		

#### PatternSyntaxException

​	非强制异常类，表示正则表达式中的语法错误



### 反向引用

​	![image-20251130183240053](C:\Users\Administrator\AppData\Roaming\Typora\typora-user-images\image-20251130183240053.png)



当正则表达式发生变化或者关联的内容发生变化，都应该对 matcher对象进行重置



String 类使用正则表达式 ： 

​	  replaceAll(regex, replacement) ： 替换满足 regex 的字符串

​	  matches(regex) ：判断字符串是否满足regex，整体匹配！

​          split

​	底层还是使用到了 Pattern 和 Matcher







# Web后端 

## Maven基础

​	管理和构建 Java 项目的工具，是 apache 旗下的一个开源项目

### 	作用

​		依赖管理

​			方便快捷的管理项目依赖的资源（即 jar 包 ）

​			在 pom.xml 中添加下面格式来快速添加依赖 (前提是基于 Maven 构建)

```
<dependencies>
        <dependency>
            <groupId>你想要引入的jar包</groupId>
            <artifactId>你想要引入的jar包</artifactId>
            <version>jar 包版本</version>
        </dependency>
    </dependencies>
```

​		项目构建

​			统一的、标准化的项目构建流程

​		统一项目结构

​			提供标准、统一的项目结构

![image-20251204125841834](C:\Users\Administrator\AppData\Roaming\Typora\typora-user-images\image-20251204125841834.png)

仓库 ： 用于 存储资源，管理各种 jar 包

​	本地仓库 ： 自己计算机上的 一个 目录

​	中央仓库 ： 由 Maven 团队 维护的 全球唯一的，仓库地址 ：https://repo1.maven.org/maven2/

​	远程仓库（私服） ： 一般由公司团队搭建的私有仓库

当引入 jar 包时，会首先在本地仓库进行查找，如果没有找到，将会连接中央仓库下载对应 jar 包并放入本地仓库后进行引入

存在远程仓库时，如果本地仓库没有找到，会首先在远程仓库进行查找，找不到再由远程仓库去中央仓库查找下载，存放到远程仓库，再从远程仓库下到本地仓库



## 安装 Maven 

![image-20251204131349818](C:\Users\Administrator\AppData\Roaming\Typora\typora-user-images\image-20251204131349818.png)



## Maven 坐标

​	Maven 坐标 指 资源（jar） 的唯一标识，通过该坐标可以唯一定位到资源位置

​	使用 坐标来定义项目或 指定引入项目中需要的依赖

​	主要组成 ：

​		groupId ：定义当前 Maven 项目隶属组织名称 （通常为域名反写）

​		artifactId ：定义当前 Maven 项目名称

​		version ：定义当前项目的 版本号

​				SNAPSHOT ： 功能不稳定，尚处在开发中的版本，即快照版本

​				RELEASE ：功能趋于稳定、当前更新停止，可以用于发行的版本

## 导入 Maven 项目 

​	将要导入的maven 项目拷贝到你的项目目录下

​	开始导入 maven 项目的 pox.xml 文件

​		文件 ，项目结构， 模块，+ ，导入 模块，选择maven项目中的pom.xml；

​		maven面板（m字符）， + ，选择maven项目中的pom.xml

## 依赖管理

### 依赖配置

​	依赖 ：指当前项目运行所需要的jar包，一个项目中可以引入多个依赖

​	步骤 ：

​	在 pom.xml 中编写 <dependencies> 标签

​	在<dependencies> 中使用 <dependency> 引入坐标

​	定义坐标的 groupId，artifactId、version

​	点击刷新按钮，引入最新加入坐标 

​	Maven 引入依赖网站 ： [Maven Repository: Search/Browse/Explore](https://mvnrepository.com/)

依赖传递 ： 当我们要引入一个依赖时，如果该依赖使用了其他依赖，将会同时引入其他依赖

### 排除依赖 

​	主动断开依赖资源，被排除的资源无需指定版本

```
语法 ：
<dependency>
	....
	
	<exclusions>
		<exclusion>
			<groupId>...</groupId>
			<artifactId>...</artifacId>
		</exclusion>\
		....
	</exclusions>
</dependency>
即，写在 dependency中！
```



注意事项 ：

​	一旦依赖配置变更，记得重新加载

​	引入的依赖如果本地仓库不存在，要联网



## Maven生命周期

​	对 所有 maven 项目构建过程进行抽象和统一

3套相互独立的生命周期 ：

​	clean ：清理工作

​	default ： 核心工作：编译、测试、打包、安装、部署....

​	site ：生成报告、发布站点

每一套生命周期都包含一些阶段，阶段是有顺序的，后面的阶段依赖于前面的阶段

![image-20251205102011942](C:\Users\Administrator\AppData\Roaming\Typora\typora-user-images\image-20251205102011942.png)

重点关注 ：

​	clean ：移除上一次构建生成的文件（字节码文件...）即删除 target 文件夹

​	compile ：编译项目源代码

​	test ：使用合适的单元测试框架运行测试（Junit）

​	package ：将编译后的文件打包，在 target 文件夹中 生成一个 jar 包，

​	install ： 将项目安装到本地仓库中。

```
<groupId>com.itlbw</groupId> 安装位置 ： 本地仓库的 com 文件夹下 的 itlbw 文件夹
<artifactId>maven-project01</artifactId> 
<version>1.0-SNAPSHOT</version>
```

在**同一套**生命周期中，当运行后面的阶段时，前面的阶段都会运行



执行

​	idea ： 右侧 maven 工具栏，点击对应生命周期即可执行

​	终端 ： mvn 要执行的生命周期

​	生命周期 的 执行都是由相关插件来完成操作



## 单元测试

测试 

​	一种用来促进鉴定软件的正确性、完整性、安全性和质量的过程

阶段划分 ： 单元测试、继承测试、系统测试、验收测试

![image-20251205105357191](C:\Users\Administrator\AppData\Roaming\Typora\typora-user-images\image-20251205105357191.png)

测试方法  ：白盒测试、黑盒测试、灰盒测试

​	![image-20251205105603641](C:\Users\Administrator\AppData\Roaming\Typora\typora-user-images\image-20251205105603641.png)

![image-20251205105614919](C:\Users\Administrator\AppData\Roaming\Typora\typora-user-images\image-20251205105614919.png)



### 单元测试

​	针对最小功能单元（方法），编写测试代码对其正确性进行测试

JUnit ：最流行的 Java 测试框架

main方法与JUnit单元测试比较

![image-20251205112354062](C:\Users\Administrator\AppData\Roaming\Typora\typora-user-images\image-20251205112354062.png)

### 使用 

​	在 pox.xml中引入 JUnit 依赖

​	在 test/java目录中，创建测试类，编写对应测试方法，并在方法声明上加上 @Test注解，（单机测试类的运行箭头，将会运行测试类的所有测试方法）

​	运行单元测试（绿通过，宏失败）

注意 ： JUnit 单元测试类命名规范 ： XxxTest；JUnit 单元测试方法必须声明为 public void （规定）

### 断言

​	单元测试运行不报错，并不代表代码逻辑没有问题！

JUnit 提供了一些辅助方法，用来帮我们确定被测试的方法是否按照预期效果正常运行，该方式成为断言

![image-20251205121417846](C:\Users\Administrator\AppData\Roaming\Typora\typora-user-images\image-20251205121417846.png)

​	形参的msg参数，表示错误提示信息，可以不用专门指定

### 常见注解

​	![image-20251205121503328](C:\Users\Administrator\AppData\Roaming\Typora\typora-user-images\image-20251205121503328.png)

参数化测试 ： @parameterizedTest 和 @ValueSource

### 单元测试规范 

​	原则 ： 编写测试方法时，要尽可能的覆盖业务方法中所有可能的情况，尤其是边界值

​	借用 idea 的测试覆盖率实现

​	ai 实现 单元测试，安装通义灵码登录就行



### 依赖范围

存在问题 ： 

​	在 Maven 项目中，test 目录存放单元测试的代码，但也可以在main 目录中编写test 单元测试（但不规范）

​	依赖的 jar 包，默认情况下，可以在任何地方使用，可以通过在dependency 中 添加 scope 标签来设置作用范围

​	作用范围 ：

​		主程序范围有效 （main 目录下）

​		测试程序有效 （test 目录）

​		是否参与打包运行 （package指令范围内）



​	scope 取值

​	![image-20251205213317697](C:\Users\Administrator\AppData\Roaming\Typora\typora-user-images\image-20251205213317697.png)

在 Maven 生命周期中，执行 test 命令将会对项目中的所有**规范**（...Test 类）的单元测试进行测试，如果执行package 和 install 等命令时，又不想执行测试（已经测试），可以点击跳过测试按钮



### Maven 常见问题 

​	依赖爆红

​	产生原因 ： 网络原因，依赖没有下载完整导致，在 Maven 仓库中生产了 xxx.lastUpfdate 文件，该文件不删除，将不会重新下载依赖

​	解决 ： 删除 该文件 执行 ： del /s *.lastUpdated

​	如果重新下载还继续爆红，请重启 idea



## Web基础知识

静态资源 ：服务器上存储的不会改变的数据，通常不会根据用户的请求而变化（HTML、CSS、JS、图片、视频等页面展示）

动态资源 ：服务器端根据用户请求和其他数据动态生成的，内容可能会在每次请求时都发生变化（Servlet、JSP、Spring 框架等逻辑处理）

B /S 架构 ： Browser/Server，浏览器/服务器架构模式，客户端只需要浏览器，应用程序的逻辑和数据都存放在服务器端。维护方便，体验一般（网络不好）

C/S 架构 ：Client/Server，客户端/服务器架构模式，需要单独开发维护客户端，体验不错，开发维护麻烦

### SpringBoot Web 入门

#### Spring

​	提供若干个子项目，每个项目用于完成特定的功能，并都基于 Sprint Framework 

​	官网 ： spring.io

Spring Boot 可以帮助我们快速构建应用程序，简化开发，提高效率 	

```
简单案例
@RestController // 标识当前类为请求处理类
public class HelloController {

    @RequestMapping("/hello") // 表示请求路劲
    public String hello(String name) {
        System.out.println("name = " + name);
        return "Hello " + name + "~";
    }

}

// 启动类
@SpringBootApplication
public class SprintbootWebQuickstartApplication {

	public static void main(String[] args) {

		SpringApplication.run(SprintbootWebQuickstartApplication.class, args);
	}

}

```

 	构建 ： 如果官网无法够建，推荐使用阿里云进行构建 ：https://start.aliyun.com

为什么一个 main 方法就启动了 web 应用 ：

​	引入了两个起步依赖 ： 

​		spring-boot-starter-web ： 包含了 web 应用开发所需的常见依赖

​		spring-boot-starter-test ： 包含了 单元测试所需的常见依赖

​		Maven 依赖 又具有依赖传递

### HTTP协议

​	超文本传输协议（Hyper Text Transfer Protocol），规定了浏览器和服务器之间的数据传输规则

#### 特点 

​	基于 TCP 协议：面向连接，安全

​	基于请求-响应模型 ：一次请求对应一次响应

​	HTTP协议是五状态的协议 ：对于事物处理没有记忆能力，每次请求-响应都是独立的缺点 ： 多次请求间不能共享数据

优点 ：速度快	



### HTTP 请求协议

#### 请求数据格式 

​	请求行 ： 请求数据的第一行 ，包含 请求方式，资源路径，协议

​	请求头 ： 第二行开始的，以 key ：value 格式的数据

​	请求体 ： POST 请求方式独有，请求头和请求体空行隔开

GET ：请求参数在请求行中，没有请求体，请求大小在浏览器中是有限制的

POST：请求参数在请求体中，POST 请求大小没有限制

常见请求头数据信息

![image-20251206102333953](C:\Users\Administrator\AppData\Roaming\Typora\typora-user-images\image-20251206102333953.png)

#### 请求数据获取

​	web 服务器对 HTTP 协议的请求数据进行分析，并封装装进 HttpServletRequest 对象

通过 调用 该对象的方法来获取所有请求信息

```
   public String request(HttpServletRequest request) {
//        获取请求方式
        String method = request.getMethod();
        System.out.println("请求方式：" + method);
//        获取请求路径
        String allPath = request.getRequestURL().toString();
        String path = request.getRequestURI();
        System.out.println("请求url地址:" + allPath);
        System.out.println("请求uri地址:" + path);

//         获取请求协议
        String protocol = request.getProtocol();
        System.out.println("请求协议:" + protocol);

//        获取请求参数
        String name = request.getParameter("name");
        System.out.println("请求参数:" + name);

//        获取指定请求头
        String header = request.getHeader("User-Agent");
        System.out.println("User-Agent:" + header);

        return "OK";
    }
```

### HTTP 响应协议

#### 响应数据格式

​	组成 ：

​		响应行 ：响应数据的第一行：协议，状态码，描述

​		响应头 ：第二行开始 ，以 key:value格式的数据

​		响应体 ： 最后一部分，存放响应数据，与响应头空行隔开

状态码

![image-20251206111741102](C:\Users\Administrator\AppData\Roaming\Typora\typora-user-images\image-20251206111741102.png)

 	200 ： 成功 	404 ：请求资源不存在	500 服务器错误

响应头类型

![image-20251206111823643](C:\Users\Administrator\AppData\Roaming\Typora\typora-user-images\image-20251206111823643.png)

#### 响应数据设置

​	将响应数据封装进 HttpServletResponce 对象

​	

```
两种方式 ：
/**
 * 响应数据,基于 HttpServletResponse
 */
@RequestMapping("/response")
public void response(HttpServletResponse response) throws IOException {
    // 1. 设置状态码
    response.setStatus(401);
    // 2. 添加响应头
    response.setHeader("name","lbw");
    // 3. 设置响应体
    response.getWriter().write("<h1>lbw's response</h1>");
}

/**
 * 响应数据,基于 ResponseEntity
 */
@RequestMapping("/response2")
public ResponseEntity<String> response2() {
// 链式调用
    return ResponseEntity
            .status(401)
            .header("name","lbw")
            .body("<h1>lbw's response</h1>");
}
```

注意 ：

​	HTTP 响应数据不需要程序员手动设置，web服务器对 HTTP 响应数据进行了封装（HttpServletResponse）

​	通常情况下，也无需手动指定响应状态码和响应头，服务器会根据逻辑自动设置



### SpringBoot Web 案例

静态资源文件存放位置 ：

​	resources/static	

返回集合为什么可以直接转换为 JSON 格式

​	@ResponseBody ：将 controller 返回值直接作为相应提的数据直接响应。即返回值是对象/集合 -> json -> 响应

​	而 @RestController 注解 包含了 @ResponseBody 和 @Controller注解



### 分层解耦



#### 三层架构

​	为什么对代码进行拆分 ：

​		遵循单一职责原则，便于复用，后期维护

​	三层架构 ：

​		controller ：控制层，接受前段发送请求，对请求进行处理，并响应数据

​		service ：业务逻辑层，处理具体业务逻辑

​		dao ：数据访问层（持久层），负责数据访问操作，包括增删改查

#### 分层解偶

​	耦合 ： 衡量软件中各层各模块的依赖关联程度

​	内聚 ：软件中各个功能模块内部的功能联系

​	软件设计原则 ：高内聚低耦合

​	思路

​		将项目中的类交给IOC 容器管理，应用程序需要什么对象，直接依赖容器提供	

​	控制反转（IOC Inversion Of Control）

​		对象的创建控制权由程序本身转移到外部（IOC容器）

​	依赖注入(DI Dependency Injection)

​		容器为应用程序提供运行时，所依赖的资源

​	Bean 对象 ：IOC容器中创建并管理的对象

#### IOC&DI入门

​	将类交给 IOC 容器 管理 ： @Component

​		将被该注解修饰的类的对象放入 IOC 容器中

​	从 IOC 容器 中找到对应的 Bean 对象，并完成依赖注入 ：@Autowired

​		将从IOC容器中查找到对应的 Bean 对象，并将该Bean 对象赋值给被该注解修饰的成员变量

#### IOC详解

相关注解

![image-20251208091934564](C:\Users\Administrator\AppData\Roaming\Typora\typora-user-images\image-20251208091934564.png)

​	衍生注解 ： 即基于 Component 注解的注解

​	bean 对象 默认名称为 类名首字母小写

指定bean 对象名称 ：

​	通过注解的value属性设置bean 对象的名称  ： @注解("指定名称") （一般使用默认）

声明注解后，想要生效，必须被组件扫描注解 ： @ComponentScan 扫描

启动类声明的注解 ：@SpringBootApplication 中，包含了组件扫描注解，但默认扫描范围是启动类所在的包及其子包

注意事项 ：

​	在 Springboot 集成web 开发中，声明控制器bean只能用 @Controller 但是 RestController 包含了 该注解

#### DI详解

基于 @ Autowired 进行依赖注入的常见方式 ：

​	属性注入 ：

​		优点 ： 代码简洁、方便快速开发

​		缺点 ： 隐藏了类之间的依赖关系、可能会破坏类的封装性

​	构造器注入 ： 如果当前类中只存在一个构造函数，那么 注解可以被省略

​		优点：能清晰看到类的依赖关系，提高代码的安全性

​		缺点：代码繁琐，如果构造参数过多，可能造成构造函数臃肿

​	setter 方法注入 ：程序运行时自动生成类对象，并自动调用setter方法 

​		优点：保持了类的封装性，依赖关系更清晰

​		缺点 ：想要额外编写setter 方法，增加了代码量

注意事项 ：

​	@Autowired 注解，默认是按照类型进行注入的，如果存在多个相同类型的bean，将会报错

​	解决方案 ：

​		在指定类上加上 @Primary ，注入时优先注入该注解修饰的类对象

​		配合 @Autowired使用 ： @Qualifier("bean 的名称")

​		使用 @Resource（name = "bean 名称"）

​	Resource 与 Autowired 的区别 ：出处和默认处理不同

​		Resource 是 javaee 提供的规范注解，Autowired 是 Spring框架提供

​		Autowired 默认按照类型注入，Resource 默认按照名称注入

​			

## Java 操作数据库

### Mybatis

​	一款优秀的 持久层框架，用于 简化 JDBC 开发

​	是 Apache 的一个开源项目itbatis，2010年迁移到 google code 改名 ：MyBatis，2013年11月 迁移到 Github

官网 ： https://mybatis.org/mybatis-3/zh_CN/index.html

#### 入门程序

##### 	准备工作 

​		创建 SpringBoot 工程，引入Mybatis相关依赖

​		准备数据库表 user、实体类 User

​		配置Mybatis （application.properties 写入数据库连接信息）

```
spring.datasource.url=jdbc:mysql://localhost:3306/web01
spring.datasource.driver-class-name=com.mysql.cj.jdbc.Driver
spring.datasource.username=root
spring.datasource.password=密码	
```

##### 	编写 Mybatis 程序 

​		即编写Mybatis 的持久层接口，定义 SQL（注解/XML）	

​		定义 Mapper 接口（@Mapper），编写SQL

@Mapper 注解 ：项目运行时，会动态的自动生成该接口实现类的对象(代理对象)，并且将该对象交给 IOC 容器管理

Mybatis 持久层接口规范 ： XxxMapper ，也称 Mapper 接口 

@SpringBootTest ： SpringBoot 单元测试类注解

​	启动该测试类的方法时，会启动 SpringBoot 整个项目，包括 IOC容器

​	需要注意的是 ： 测试类所在包要与引导类所在包名相同或在其子包下

### JDBC VS Mybatis

​	Mybatis 辅助 配置 ：

​	默认情况下，在Mybatis 中配置SQL语句是无法识别的，通过选中 sql语句，选择显示上下文操作，选择语言注入设置，修改为 MySQL即可

​	此时会针对 SQL 语句中表进行报错，产生原因为 ：idea 没有与数据库建立连接，无法识别表信息，此时可以在 idea 中配置 MySQL的连接

​	日志输入 ： 在 application.properties文件中增加配置 ：

```
# 配置 Mybatis 日志输出信息
mybatis.configuration.log-impl=org.apache.ibatis.logging.stdout.StdOutImpl
```

### 数据库连接池

​	避免数据库连接遗漏 ： 防止 没有释放连接而引发的连接池中连接数越来越少的情况

​	都需要实现 DataSource 接口

​	常用数据库连接池 ：C3P0、DBCP

​				Druid  Hilari（SpringBott 项目默认连接池）

#### 	切换数据库连接池 	

​		引入数据库依赖；

​		修改 apllication.properties 文件，指定数据库连接池	

```
spring.datasource.type=全类名（com.alibaba.druid.pool.DruidDataSource）
```

### 增删改查操作

#### 	Mybatis 中的 # 和 $	![image-20251211115842743](C:\Users\Administrator\AppData\Roaming\Typora\typora-user-images\image-20251211115842743.png)

​	#{id} 作为占位符，底层会转换为 ？

删除 ： @Delete 注解，有返回值，返回影响行数

修改 ： @ Update注解 多个参放对象

添加 ： @ Insert 注解，传递多个参数时，可以将参数封装进一个对象中，再通过#{对象属性名}取出相关数据

查询 ：@Select 注解

​	@Param 注解 ：为接口的方法形参起名字（方法形参不会被保留到字节码文件，调用时无法知道形参对应哪个实参）

​	适用于两个及两个以上的 多个参数

​	如果基于官方骨架创建的springboot项目，接口编译时会保留方法形参名，因此@Param注解可以省略

```
<parent> 有 父工程
        <groupId>org.springframework.boot</groupId>
        <artifactId>spring-boot-starter-parent</artifactId>
        <version>3.5.8</version>
        <relativePath/> <!-- lookup parent from repository -->
    </parent>
父工程中有：
<plugin>
  <groupId>org.apache.maven.plugins</groupId>
  <artifactId>maven-compiler-plugin</artifactId>
  <configuration>
    <parameters>true</parameters> 记录了参数
  </configuration>
</plugin>
```

### XML映射配置

​	在 Mybatis 中，既可以通过注解配置SQL 语句，也可以通过XML配置文件配置SQL语句

#### 默认规则 

​	XML 映射文件的名称与 Mapper 接口名称一致，并且 XML 映射文件和 Mapper 接口放置在相同包下（同包同名，在resource下构建相同结构的目录）

​	XML 映射文件的 namespace 属性为 Mapper 接口的全类名（全限定名）一致

​	XML 映射文件中的 sql 语句的 id 与 Mapper 接口中的方法名一致，并保证返回类型：resultType 与单条记录封装类型一致（全类名）

#### XML 映射文件模板

```xml
<?xml version="1.0" encoding="UTF-8" ?>
<!DOCTYPE mapper
  PUBLIC "-//mybatis.org//DTD Mapper 3.0//EN"
  "https://mybatis.org/dtd/mybatis-3-mapper.dtd">
<mapper namespace="Mapper全类名">
  <select id="方法名" resultType="单条记录封装类型">
    select * from Blog where id = #{id}
  </select>
</mapper>
```

通过 Mybatis 完成简单的增删改查功能，实现复制的 SQL 功能时，建议使用 XML 来配置映射语句

#### 辅助配置

当没有按照严格规定来进行存放 xml映射配置文件，可以在 application.properties 中增加配置信息 ：

```
mybatis.mapper-locations=classpath:mapper/*.xml
```

插件推荐 ： MybatisX ，根据项目快速在 Mapper 代码与 XML文件间进行对应跳转



## SpringBoot配置文件

配置文件 ：

​	application.properties

​	application.yaml / yml

yml 配置文件

​	特点 ： 简洁、以数据为中心

​	格式：

​		数值前必须有空格作为分隔符

​		使用缩进表示层级关系，缩进时，不允许使用 tab 键，只能使用空格（idea可以自动转换tab成空格）

​		缩进空格数不重要，只要相同层级的元素左侧对齐

​		表示注释，从该字符一直到行尾，都会被解析器忽略

在yml 格式的配置文件中，如果配置项的值以 0 开头，需要使用 **单引号**引起，否则默认作为8禁止表示的数据

```
# 定义对象 和 Map 集合
user:
  name: 张三
  age: 18
  gender: man

# 定义数组/list/set
list:
  - 20
  - 30
  - 40

spring:
  application:
    name: mybatis-quickstart
  # 配置数据库连接
  datasource:
    type: com.alibaba.druid.pool.DruidDataSource
    url: jdbc:mysql://localhost:3306/web01
    driver-class-name: com.mysql.cj.jdbc.Driver
    username: root
    password: lbw

mybatis:
  #配置 Mybatis 日志输出信息
  configuration:
    log-impl: org.apache.ibatis.logging.stdout.StdOutImpl
  mapper-locations: classpath:mapper/*.xml
```
