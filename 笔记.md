# Java基础

## java概述

​	程序 ：计算机完成某个操作或解决某个问题而编写的一段有序的指令集合

1995年，sun公司发布第一个版本的java ; Java 之父是**詹姆斯・高斯林（James Gosling）**

​	技术体系平台 ：
​		Java SE ：标准版

​		Java EE ： 企业版 SE的扩展 

​		Java ME ：小型版

### 	特点  

​		面向对象

​		健壮性（强类型机制、异常处理，垃圾自动回收....）

​		跨平台性 ： 编译好的文件可以在多个系统上运行(JVM来帮助解释执行)

​		解释性语言 ：经过编译后产生的文件，还需要解释器才能执行 （HTML、JavaScript、Java）

​			编译性语言 ：C 、C++

### 	JVM

​		Java虚拟机，一个虚拟计算机，包含在JDK中。

### 	JDK

​		Java开发工具包，包含JRE 和Java开发工具（javac 、java ....）

### 	JRE 

​		Java运行环境，包含JVM和Java核心类库,如果只是使用一个开发好的java程序，只需要JRE

### 环境变量path配置及其作用

​	为了在dos的任意目录下都能使用java和javac命令

​	1.在环境变量中增加一个JAVA_HOME,值为JDK安装的主目录

​	2.然后在path变量中新增一个%JAVA_HOME%\bin

### 	Java运行机制 

​		先编写java文件（源文件） ，通过javac  xxx.java来编译生成一个.class文件（字节码文件）, 再通过java xxx(不要带后缀名！！)来解释  

​		编译 ： 通过编译工具（javac.exe）生成能够被JVM识别的字节码文件(即.class文件),（有错误则报错，无错直接生成字节码文件）

​		运行 ： 通过运行工具（java.exe）将字节码文件装载到JVM机执行

​		需要注意的是

​			当编写的代码中存在中文，即便是注释里面的，应该将文件安装GBK的编码形式来重新保存，否则终端不认可（默认GBK）

​			新保存的java文件，应该重新编译形成新的class文件来保持执行的是新的java文件

### 	Java开发注意事项 

​		Java源文件以 ".java"为扩展名，其基本组成部分为类

​		Java应用程序执行的程序入口是main()方法，有固定格式 : public static void main(String[] args) { ... };

​		Java 严格区分大小写

​		Java方法的有语句组成，每条语句必须要有 ； 结尾

​		Java中每个{}都是成对出现，缺一不可

​		源文件中有且只有一个Public类，其他类个数不限制 ，对于源文件中出现的所有类，会生成相对应的class文件；可以将main方法写在非public类中，再调用运行非public类时，入口方法就是非public类的main方法

​		如果一个源文件中有一个public类，则文件名必须要与public类名一致

### 	转义字符

​		\t  : 一个制表符  \n :换行   \\"  一个双引号      \\' : 一个单引号      \r : 一个回车（并不是换行，而是计算机在读取该字符时，光标转到该行最前，然后进行读取覆盖）

### 	易犯错误 ：（语法错误）

​		找不到文件 ： 文件不存在或写错，路径错误

​		公共类名与文件夹名不一致

​		缺少分号

​		最难的是 ： 业务错误（逻辑上错了），环境错误

### 	注释 

​		单行注释 ： //

​		多行注释 ： /* .... */	不允许嵌套

​		被注释的内容不会被JVM识别和执行	

​		文档注释 ： javadoc -d 文件夹位置 -xx -yy... xxxx.java

### 	Java规范 

​		类和方法的注释采用 javadoc的方式来写

​		对于单行多行注释，是用来解释为什么这么写，怎么改，有什么影响

​		tab ： 整体左移，shift + tab ：整体右移

​		源文件应该采用utf-8

​		运算符、= 左右各空一格

​		单行不超80字符

​		代码编写行尾风格和次尾风格

## DOS 

​	磁盘操作系统

​	Dos系统 ： 接受指令（获取到一个指令），解析指令（分析要做什么），执行指令（在系统上执行这条指令）

​	相对路径 ：从当前目录开始定位，从而形成的路径

​	绝对路径 ：从根目录开始定位形成的路径

### 	常见Dos命令 

​		查看当前目录内容 ： dir

​		切换 ：cd   (切C盘 ： cd /D c:    上一级目录 ： cd  ..   切换跟目录 ： cd /)

​		查看下级的所有文件夹 ： tree 

​		清屏 ： cls

​		退出 ：ｅｘｉｔ

​		创建目录  ：md

​		删除目录  ：rd

​		复制文件 ： copy 

​		移动文件 ：remove

​		删除文件 ： del  ....

## 变量

​	变量是程序的基本组成部分

​	三要数 ： 类型 名称 变量值

​	变量是一块内存的数据存储空间的表示，通过变量名可以访问到变量值

​	不同变量类型不同，不同类型占用空间也不同，int ： 4字节  char ： 1字节  double ： 8字节  float ： 4字节

​	必须先声明，后使用 

​	一个变量的存储区域，该区域由自己的名称和类型 ，其存放的数据可以在同一类型范围内变化

​	在同作用域中，变量名不能重名

### 	\+ 的使用

​		当\+ 的旁边是数值类型时，做加法运算； 如果是一方有一个字符串，做拼串操作（运算从左到右）

### 	数据类型

#### 		基本数据类型 

​			数值  

​				整型 ： byte（字节 ，1）  ： -128 ~127

​					short （2） ： -(2^15) ~ 2^15-1  -32768 ~ 32767

​					int （4） ： -(2^31) ~ 2^31  - 1 

​					long （8） ： -(2^63) ~ 2^63  -  1 

​					整型的长度是固定的，与操作系统无关

​					Java整型常量默认为int类型声明long类型时，必须在常量后加 l 或L

​					整型变量一般使用int来存放，除非太大超出了，可以用long

​					当将一个具体的数值赋值给一个byte时，会先进行判断，这个数值是否在byte范围，是就赋值

​					bit（比特） ：计算机中最小存储单元 ，byte计算机的基本存储单元，1byte = 8 bit

​				浮点型  ： float （4）、double（8）

​					存放形式 ： 符号位 + 指数位 +尾数位 尾数位存在可能丢失的情况，从而造成精度丢失，小数都是近视值

​					长度是固定的，与操作系统无关

​					Java浮点型常量默认为double（double类型可以带 ：d后缀   即8d 表示一个double类型的8），因此声明float常量时，要加 f 或 F

​					小数表现形式 ： 

​						十进制 ： .123  等价于0.12

​						科学计数法 ： 2.12e3 (2.12 * 10^3)  2.21E-2(2.21*10^-2)

​					通常情况下，应该使用double类型，double类型精度高于float

​					当我们对运算结果是小数的进行比较时，应该注意小数可能是近似的（即计算机无法表示该小数），可能理论上相等，但实际上计算机不可能相等应该通过两个值的差的绝对值，在某个精度上来判断是否相等，小就等于；当然直接查询到的或者直接赋值的自然可以比较

​			字符类型  ： char(2)。存放单个字符,可以存放数字

​					必须使用单引号引起（双引号为字符串）

​					运行转义字符

​					在Java中，char本质是一个整数，输出是按照unicode编码输出，因此char可以是整数

​					char可以进行运算，本质是一个整数

​				字符型本质 ：
​					字符型数据存放到计算机时，需要先找出对应的码值，再将码值存放到计算机中

​					字符与码值的对应关系是通过字符编码表决定的

​			字符编码表 ： （不同的编码会对文件大小产生影响）

​				ASCII ： 一个字节 ，128个字符，虽然一个字节可以表示256个字符，但这里只使用了128个字符（因为最前面的比特位默认为0）

​					缺点 ： 不能表现所有字符

​				Unicode ： 两个固定字节（2^16），表示字母和汉字，易浪费空间（缺点），兼容ASCII

​				utf-8 ： 大小可变的编码方式，1-6 个字节来表示一个字符；  字母使用一个字节，汉字使用三个字节,使用最广

​				gbk ： 可以表示汉字，范围更加广泛 ，字母一个字节，汉字两个字节

​				gb2312 ： 表汉字，但gb2312 < gbk

​				big5 码 ： 繁体中文

​			布尔类型 ：boolean（1），存放 ：true false（两个值，不能为空）

​					用于逻辑运算

​					java中，不能使用0和非0来代替boolean类型的真假

#### 		引用数据类型

​			类（class）(string 属于类)

​			接口 （interface）

​			数组 （[]）		

### 自动类型转换 

​	当Java进行赋值或运算时，精度小的类型会自动转换为精度大的类型

​	char - int - long -float - double

​	byte - short - int - long - float - double

​	 当多种类型数据进行运算时，会自动转换为数据类型容量最大再运算

​	当把精度大（容量大）的数据转换为精度小（容量小）会报错，反之自动转换

​	byte和short 不能与char发生类型转换

​	byte short 与 char 进行运算时，只要出现，就会首先转换为int类型

​	boolean不参与自动转换

​	自动提升原则 ： 表达式结果的类型将会自动提升为操作数中最大的类型

### 强制类型转换 

​	自动转换的逆过程，使用强制转换符 ： （类型） ，可能会造成精度损失或溢出，因此要明确知道会这样，才去转

​	数据从大 --> 小，使用强制转换

​	强转符号只会针对最近的操作数有效，对于整个表达式来讲，需要（）提升优先级

​	char类型可以保存int常量值，但是无法保存变量值，需强转

### 基本数据类型与String类型相互转换

​	基本 ——> String :  + " "拼串

​	String ——> 基本：  使用基本数据类型对应的包装类的相应方法来实现转换

​	int :  Integer.parseInt() ;  short : Short,parseShort();  byte : Byte.parseByte() ; long : Long.parseLong()

​	boolean : Boolean.parseBoolean()(针对于"true","false"); 

​	float : Float.parseFloat(); double : Double.parseDouble 

​	字符串 转 字符 ： 通常将字符串的第一个字符拿出来存放

​			字符串.charAt(索引) ： 返回一个字符串的索引上的字符

​	但将String转换为基本类型数据时，应该保证String可转换为一个有效数据，如果不能转换成一个有效数据，会抛出错误，程序终止

## 运算符	 

​	一种特殊的符号，用于表示数据的运算，赋值和比较

### 算数运算符 

​	% 的本质为 ： a % b == a - a / b * b;

​		a % b 时，a 是小数时， 本质为 a - （int）a / b * b

​	++ 使用 ： (底层存在一共强制类型转换)
 		作为独立语句使用  前后 ++ 完全等价于 +1

​			前加本质 ： 会创建一个临时变量temp = i；然后执行 i = i + 1,最后执行 i = temp （i = i++）

​			后加本质 ： 创建一个临时变量temp，先执行i = i + 1; 在执行 temp = i，最后就是 i =temp

### 关系运算符（比较运算符） 

​	结果只会是true和false

​	关系运算符构成的表达式为关系表达式

### 逻辑运算符 

​	用于链接多个条件（多个关系表达式），最终结果还是boolean

​	与 ： 就是有假为假，全真为真 ； 或  ： 全假为假，有真为真

​	取反：真就是假，假就是真 ；异或 ： 相同为假，不同才真

​	短路与 && （常用） 和 逻辑与 &

​	对于&&，第一个条件为false，后面的条件不会被执行和判断； 而&无论如何将会全部执行判断真假 

​	短路或 ||（常用）  和 逻辑或 |

​	对于||，第一个条件为true，后面的条件不会被执行和判断； 而 | 无论如何将会全部执行判断真假 

### 赋值运算符 

​	将运算后的值赋值给指定变量

​	基本 ： =   ； 复合 ： +=， -=， *= ， /= ,%= 。(a +=b == a = a + b ....)

​	特点 ： 	

​		运算顺序为从右向左

​		左边只能是变量，右边可以说常量，变量，表达式

​		复合赋值运算会自动进行类型转换  a += b 等价于  a = (a的类型)(a + b)

### 三元运算符 

​	条件表达式 ： 表达式1 ？ 表达式2 （表达式1和表达式2看成一个整体，并在执行前进行自动转换！！！）

​	条件表达式为真，执行表达式1；为假，执行表达式2

​	表达式 1，2 应该是可以赋值给接受变量的类型（或者可以自动转转换）(不匹配或无法自转，要求强转)

​	三元表达式可以转换为if-else语句

### 运算符优先级 

​	整体上可以通过（）来转换成你想要的运算顺序

​	单目运算（单个操作数），赋值运算符 ： 从右向左，其余从左向右

### 标识符规则和规范

​	标识符 ：对各种变量，方法和类命名的字符就是标识符（就自己命名的东西）

​	规则 ：

​		26个字母（大小写），数字，_，$组成

​		不能以数字开头

​		不能使用关键字和保留字 ，但能包含关键字和保留字（就是含有） 

​		严格大小写，长度无限制

​		标识符中，不能包含空格

​	规范 ：（更加专业）

​		包名 ：多个单词组成时，采用小写字母  . 隔开

​		类名 ：多单词构成时，首字母大写（大驼峰法）

​		变量名，方法名 ： 多单词构成，首单词小写后续单词首字母大写（小驼峰法，简称驼峰法）

​		常量 ： 字母大写，多单词下划线隔开

​	关键字 ： 被Java语言赋予了特殊的含义，用做专门用途的字符串（全是小写）

​	保留字 ： 现有版本尚未使用，但后续版本可能作为关键字使用

### 键盘输入 

​	接受用户输入数据

​	需要一个扫描器对象 ：Scanner

​	步骤 ：
​		导入该类的所在包 ： java.util.   导入形式 ： import java.包名.类名 （import java.util.Scanner）

​		创建该类对象（声明变量） ： new创建一个实例对象 new Scanner(System.in)  : System.in 接受键盘输入 

​		调用内部功能 ： next() : 字符串，nextInt() : 整形   nextDouble() ： double类型 .... ； char : next().charAt(0)

​		当执行到next方法时，程序会一直等待用户输入的信息

### 进制 

​	对于一个整数，有四种表现形式

​	二进制 0，1  0b 或0B开头

​	十进制 0~9

​	八进制 0~7  0开头

​	十六进制 0~9A~F（不分大小写）   0x 或0X 开头

### 原码、反码、补码 

​	有符号数：

​	最高位为符号位，0正1负

​	正数原反补一致

​	负数反码 = 原码符号位不变，其他位取反， 补码 = 反码 + 1；0的反码补码都是0；

​	Java中没有无符号位，即java中的数都是有符号数

​	计算机运算时，**以补码形式来进行运算**，但是运算结果是以原码出现

### 位移运算符  

​	& ：按位与  ：全1为1， 其余为0

​	| ：按位或  ： 全0 为0， 其余为 1

​	^  ： 按位异或  ： 相同为0，相异为1 

​		了解两个公式 ： a ^ 0 = a ; b ^ b = 0;两个实现数据交换

​	~ ：按位取反  ： 1是0 ， 0 是1

​	>> ：算数右移 ，低位溢出，高位补符号位 本质就是除以几个2

​	<< ： 算数左移，符号位不变，低位补0   本质就是乘几个2

​	>>> ： 逻辑右移， 低位溢出，高位补0  

​	注意 ： 没有逻辑左移

## 程序控制结构

### 	顺序控制

​		程序从上到下一步一步执行，中间没有任何判断和跳转

​		定义变量时，使用**前向引用**（先定义后引用）

### 	分支控制

​		让程序有选择的执行

#### 	if - else 分支

##### 		单分支

​			if(条件表达式) { 执行代码块 }（当执行代码块中只有一个语句，可以不用{}，但建议写上）
​			当条件表达式为真，执行{}中的执行代码块，为假，则不执行{}内的执行代码块

##### 		双分支

​			if(条件表达式1) { 代码块1}

​			else{代码块2}

​			条件表达式1 为真，执行代码块1，为假执行代码块2；				

##### 		多分支

​			if(条件表达式1) {代码块1}

​			else if(条件表达式2) {代码块2}

​			....

​			else {代码块n}

​			条件表达式1 为真，执行代码块1，为假判断条件表达式2；真执行代码块2，假继续判断....知道全部为假，执行代码块n

​			整体上最多只允许有一个执行入口，可以没有执行入口（即没有else，且条件表达式都不成立）

##### 		嵌套分支

​			在一个分支结构中，嵌套一个完整的分支结构，里面分支为内层分支，外面的分支为外层分支；

​			规范 ： 不建议超过三层，可读性不好

#### 	switch分支	

```
switch(表达式) { java中，只要有值可以返回，就是一个表达式
	case 常量1 ： 代码块1
		break;
	case 常量2 ： 代码块2
		break;
	case 常量3 ： 代码块3
		break;
		....
	default :  代码块n
		break;
} 
```

​		switch是一个关键字，表示switch分支

​		表达式对应一个具体的值

​		case 常量1 表示 ： 当表达式的值等于常量1，则执行语句块1，然后break退出switch

​		和case 常量1匹配，执行语句块1，不匹配就开始匹配case 常量2 ......

​		如果一个都没有匹配，执行default中的代码块

​		注意事项 ：

​			表达式的数据类型应该和case常量的数据类型一致，或者可以自动转换为可以相互比较的类型

​			表达式返回的数据类型只能是 ： byte，short ，int，enum（枚举）， char ，String

​			case 子句中的值必须是常量或者是常量表达式，不能是变量

​			default 是可选的，没有default，且没有匹配到任何case子句，将会啥也不干

​			break用来在执行完一个case子句的代码块，跳出switch，如果没有break，会按照顺序执行下面的case子句代码，知道下面的全部执行或遇到break

​	switch 和 if

​		如果判断的数据类型不多，且符合 byte，short ，int，enum（枚举）， char ，String，建议使用switch

​		对区间判断，对结果为boolean类型判断时，使用if分支更加合适

​	

### 	循环控制

#### 	for循环

​		for(循环变量初始化 ； 循环条件 ； 循环变量迭代) { 循环操作 }

​		for ：关键字，表示循环控制

​		四要素 ：循环变量初始化 循环条件 循环操作 循环变量迭代

​		循环操作 ：可多条语句，单语句（{} 可省，但不要省）

​		循环条件是一个返回布尔值类型的表达式

​		for循环中的初始化循环变量和循环变量迭代可以写在别的地方，但分号不能省略 (for(;;) 表示一个死循环)

​		循环变量的初始化可以有多条语句，但要类型相同；循环变量的迭代可以有多条语句；多条语句都由逗号隔开

#### 	while循环 

​		循环变量初始化；while（循环条件） { 循环操作 ； 循环变量迭代 }

​		四要素，位置不同

​		循环条件还是一个返回布尔类型的表达式，先判断，后执行

#### 	do-while循环

​		循环变量初始化； do { 循环操作；循环变量迭代； }while（循环条件）；

​		先执行，再判断，一定会执行一次； **最后一定要有一个 ；号**

#### 	多重循环

​		当一个循环中有另一个循环，将会构成循环嵌套，一般建议两层循环，最多不要超过三层

​		循环嵌套是将内层循环作为外层循环的循环体，只有内层循环结束后才会结束外层的一次循环

​		当外层循环要执行m次，内层循环执行n次，则内层循环体将会执行m * n 次

## 编程思想 

​	化繁为简

​		将复杂需求拆解为简单需求，逐步完成

​	先死后活

​		先考虑固定值，然后转成可以灵活变化的值

### 跳转控制语句

#### 	break

​	用于终止某个语句块的执行，常用于switch和循环 

​	break 语句出现在多层嵌套的语句块中，可以通过标签指明要结束哪一层语句块

#### 	标签语法 

```
label1(只是一个标识符) ： {
	label2 ： {
		label3 ： {
			break label2;//结束 label2 的语句块
		}
	}
}
```

​		break 语句可以指定退出哪一层

​		label 是标签，名字由程序员确定

​		break后指定到哪个标签，就退出到哪里

​		并不推荐使用标签

​		break没有指定时，默认跳出最近的循环体

#### 	continue 

​		结束本次循环，继续执行下一行循环，也可以根据标签跳过指定循环

#### 	return

​		使用在方法中，表示跳出该方法；return写入main方法时，执行将会结束程序

## 数组、排序、查找

### 数组 

​	存放多个同一类型的数据；是一个引用类型的数据类型；数组就是一组数据

#### 	定义 

#### 		动态分配方式

​			数据类型[]   数组名([] 可以写在数组名后) = new 数据类型[元素个数]；

​			先声明：数据类型[] 数组名  或 数据类型 数组名[] （此时为空） ，再创建 ： 数组名 = new 数据类型[元素个数]

#### 		静态初始化 

​			数组类型[] 数组名 = {元素1，元素2....}  (知道由多少个数据使用静态方式)

​			等价于 ： 数组类型[] 数组名 = new 数据类型[个数]， 数组名[0] = 元素1....

​	数据类型[] 数组名 = new  数据类型[] { .... } 可以创建一个数组，但应该注意的是 ： new 数据类型[] 中的[] 不能填写数字，而是由计算机去读取后面的元素来确定数组长度

#### 	引用/使用 

​		数组名[下标/索引]

​		数组下标从0开始 

​	注意 ：

​		数组是多个相同数据类型的组合，用于实现对这些数据的同一管理

​		数组中的元素可以是任何数据类型，基本类型和引用类型都可以

​		数组被创建后，如果没有赋值，将会赋值默认值 ： 

​			//  int byte short long : 0; float double : 0.0 boolean : false String: null char :\u0000(0字符，u表示十六进制)

​		使用数组 ： 声明开辟数组，赋值，使用

​		下标从0开始

​		数组下标必须在指定范围内去使用，否则数组下标越界异常，编译可以通过，但是执行将会抛出异常

​		数组属于引用类型数据，数组型数据是对象（数组本事就是一个对象）

#### 	数组赋值机制 

​		基本数据类型赋值 ,赋值方式是值拷贝 ： 一个变量的变化不会影响到其他与其关联的变量

​		数组赋值，默认情况下是引用传递/地址拷贝，赋值方式是引用赋值，赋值的是地址

## 	值传递和引用传递的区别

​		前提 ： 在JVM中，内存分为三个部分 ： 栈 、 堆 、 方法区

​		对于基本数据类型，会直接存放在栈区中（变量名和变量存放的数据）

​		而对于数组来讲，数组名将会存放在栈区中，而具体存放内容将会放在堆区中，栈中的数组名将会存放一个地址，指向了存放在堆区中的数据

​	当基本数据类型进行值传递时，会将一个变量存放的数据拷贝一份放入另一个变量，两个变量存放的数据并无关系，只是一样，

​	当数组进行引用传递时，会将一个数组名存放的地址拷贝一份放入另一个数组名，但是由于地址一样，导致新数组名可以根据地址信息找到存放在堆区的数据内容，此时发生更改将会影响其他指向该数据内容的数组。

#### 	数组的拷贝

​		要求数据空间相互独立

​		创建一个新的数组，使其大小一致，再遍历赋值，创建出两个相互独立的数组

#### 	数组的扩容

​		定义一个新的数组，使其长度为原数组长度 +1，依次将原数组元素赋值给新数组，并为新数组赋值一个新元素，使用引用拷贝替换原数组内容

## 	排序 

​		将多个数据，按照指定顺序进行排序的过程

### 		内部排序

​			将所有的数据全部加入内存进行排序

### 		外部排序

​			数据量过大，无法全部加载到内存中，需要借助外存来进行排序 

### 		冒泡排序 

​			通过对待排序序列从后向前，依次比较相邻元素的值，发现逆序就交换，使值较大的元素逐渐从前移向后部

​			注意点 ：

​				比较时应该注意是否越界，对于已经排列到最后的最大数时，不需要再比较（内层循环的条件应该小于数组长度　－　１　－　ｉ）；

​				拍到最后就剩一个数时，也不需要再排序（ｎ个数只需要ｎ－１次外层循环）

## 	查找

​		顺序查找　：遍历一边查找

​		二分查找 ：针对于一组有序数组，先查中间，看大小关系，大后找，小前找

## 	二维数组 

​		一个数组的元素又是一个数组，则这个数组称为二位数组

​		二位数组的元素个数 ： 数组名.length

​		如果需要得到二位数组中一位数组的元素，需要再遍历一个二位数组的元素

​		访问第i个一维数组的第j个元素 ： 数组名\[i -1][j - 1];

​		动态初始化 ：
​			类型\[][]  数组名 = new 类型\[][] (第一个[] 表示有几个一维数组，第二个[]表示一个一维数组有几个元素)

​			类型\[][] 数组名 ； 数组名 = new \[][]; 先声明，再创建

​			列数不确定，java中允许一维数组的个数不确定 ： 

​				先开辟出二维数组个数（int\[][] arr = new int\[3][]; 确定了二位数组空间，但是一位并没有赋空间），后面根据情况开辟一维数组元素个数(arr[i] = new int[i + 1];)

​		静态初始化 ：int\[][] arr = new int\[][] ;  int\[][] arr =  {{},{},{}}

​		声明 ：类型\[][]  数组名 ；类型  数组名\[][] ； 类型[] 数组名[]

## 面向对象

引入 ： 

​	以前知识（单独变量，数组）存在不利于数据管理和效率低

​	java设计者引入类与对象(OOP),就是为了解决现有技术无法完美的解决现有需求（不利于管理和效率低）

一个程序就是一个世界，有很多的事物（可以通过对象来表示）(对象[属性，行为])

### 类与对象的关系 

​	类 ： 就是一个由程序员创建的数据类型，（将一种事物的属性和行为提前出来形成一个类）

​	对象 ： 可以通过一个类，创建一个具体的事物（具体的实例对象）

​	从类到一个对象 可以称为 ： 创建一个对象；实例化一个对象；把类实例化

​	类是抽象的，概念的，代表一类事物 （是一个数据类型）

​	对象是具体的，实际的，代表一个具体的事物 （是一个实例）

​	类是对象的模板，对象是类的一个个体，对应一个实例

### 对象内存布局 

​	对于属性的存放 ： 如果是基本数据类型，将会存放到堆区，而String将会放入方法区的常量池（存放常量）中 

​	在创建一个对象时，会先在方法区中加载类的信息，在堆中开辟一块区域存放类的属性（默认值）

​	cat只是指向一个对象，称为对象引用或对象名，真正的对象是 ： new Cat（）

### 属性/成员变量

​	属性 = 成员变量 = field(字段)

​	属性是一个类的基本组成部分，可以是基本类型，也可以是引用类型

### 注意事项 

​	属性的定义语法 ： 访问修饰符  属性类型 属性名

​		访问修饰符 ：控制属性的访问范围； 四种 ： public , protected , 默认 , private

​	属性类型可以是基本类型，也可以是引用类型；

​	属性未被赋值时，取默认值，与数组规则一致

### 对象的创建 

​	先声明 ： 类  对象名 ； 对象名 =  new 类() 再创建对象

​	直接创建 ： 类 对象名 = new 类()；

### 访问对象属性

​	对象名.属性名

### 对象创建流程 

​	先加载相关类信息（属性和方法），只会加载一次；

​	在堆中分配空间，大小由类的属性个数决定，为属性赋默认值

​	将堆中对象的地址赋值给对象名

​	进行指定初始化

### 成员方法/方法

​	Java中，通过方法来描述一个具体事物的行为

	//方法的使用：
	// 方法写好后，不去调用（也称为使用），将会无法执行
	// 先创建一个对象，再调用方法
	Person p1 = new Person();
	p1.speak();//调用方法
	p1.cal02(5); //调用cal02方法，传递一个参数5，让n = 5
	// 调用getSum方法，传递两个参数，使num1 = 20, num2 = 10;
	// 并将返回值赋值给returnRes
	int returnRes = p1.getSum(20,10);


​	
​	// public 表示这个方法是公开的
​	// void 表示该方法没有返回值
​	// speak() : 表示该方法名称为speak，() : 形参列表，这里显示没有形参
​	// {} ： 方法体，里面放要执行的代码
​	public void speak() {}
​	// (int n) : 表示当前一个形参n，接受用户输入
​	public void cal02(int n) {}
​	
​	// int : 表示该方法执行后，会返回一个int类型的数据
​	// return result 表示将result的值返回
​	public int getSum(int num1, int num2) {
​	return result;}

### 方法调用机制 

​	方法执行完毕或执行到return时就退出栈空间

方法的好处 

​	提高代码的复用性

​	可以将实现细节封装起来，其他用户调用即可

### 成员方法的定义 

​	访问修饰符 数据类型 方法名(形参列表) {语句块（方法主体）； return 返回值}；

​		形参列表 ：表示成员方法接受的值（形参）

​		数据类型 ： 表示成员方法返回的数据类型，void表示无返回值

​		语句块 ： 实现某一功能

​		return语句不是必须的

​	思路 ： 

​		确定方法返回类型

​		确定方法名

​		确定方法形参（个数和类型）

​		确定方法体

### 方法注意事项和细节

​	 访问修饰符 ： 控制方法的使用范围， 四种 ： public , protected , 默认 , private

​	返回数据类型 ：

​		一个方法最多只能有一个返回值，当需要返回多值时，采用返回数组的形式返回（将返回值存放在数组）

​		返回值的类型可以是任意类型（基本和引用都行）

​		如果方法要求有返回数据类型，则方法最后执行的语句为 return 值（值可以是一个数据或着一个表达式），并且要求返回值的数据类型必须与return返回的数据类型一致或兼容

​		如果返回类型为void，可以不用写return 或者直接写return（不能再写表达式或值）

​	方法名 ：采用驼峰命名法，见名知意

​	形参列表 ：一个方法可以有0个形参或多个形参（逗号隔开）；可以是任意类型，

​		调用含形参方法时，一定对应着参数列表传入相同数据类型或类型兼容的参数

​		方法定义时，参数被称为形式参数（形参），方法调用时，参数被称为实际参数（实参），形参实参的类型，个数，顺序要求一致

​	方法体 ： 不能再定义方法（不能嵌套定义方法）

### 方法调用注意事项

​	同一类中的方法调用时 ，直接可以进行调用

​	跨类的方法调用时，通过创建对象实例，使用对象名来进行调用。对象名.方法名()

​	跨类方法的调用和方法的访问修饰符有关

Math.random() ：随机生成一个0~1之间的double类型的数据

字符串比较方法 ：

​	equals()  ：String类中的方法，参数为想要比较的字符串，相等为true，不等为false

		System.out.println(name.equals("张三"));
		System.out.println("张三".equals(name)); //推荐，避免空指针 

### 方法传参机制

​	基本数据类型传参机制	

​		对于基本数据类型，传递的是值（值拷贝），形参的变化并不会影响到实参的变化

​	引用类型传参机制 

​		引用类型数据传递的是地址（值是地址），因此对形参指向的内容进行修改时，会影响实参中的数据，如果对形参进行执行修改，将不会影响到实参的数据。需要注意的是，当传递的是一个不可变的的引用数据类型，传副本，跟基本类型一样，不影响原值

### 方法递归调用

​	方法自己调用自己，每次调用时传入不同的参数；用于解决复杂问题，并使代码比较简洁

​	规则 ：

​		每调用一次方法，会在栈中创建一个新的受保护的独立空间

​		方法的局部变量是独立的，不会相互影响

​		如果传递的参数是引用类型，将会共享该类型中的数据（都是指向堆区的同一个位置）

​		递归必须向退出递归的条件移动，否则将会出现无限递归，栈溢出（StackOverflowError）

​		当一个方法执行完毕或者遇到return，就会返回，遵循谁调用，返回给谁的原则，并且这个方法就执行完毕

### 方法重载（Overload）

​	java中允许同一个类中，多个同名方法存在，但是要求形参列表不一致

​	好处 ： 减轻了起名和记名的麻烦

​	注意事项 ：

​		方法名一定一样

​		方法的形参列表必须不同（类型，个数和顺序）

​		方法返回类型没有要求。（即如果两个方法名，形参列表一致，虽然返回类型不一样，但还是不构成方法重载，为方法重定义）

​		方法重载时，优先找匹配的形参列表，再找可以自动转换的，实在找不到报错

### 可变参数

​	Java中，允许将同一个类中的多个同名同功能但参数个数不同的方法封装成一个方法

​	基本语法 ：访问修饰符  返回类型 方法名（数据类型... 形参）

​	注意事项：

​		可变参数的实参可以是0~n个

​		可变参数的实参可以是一个数组

​		可变参数的本质就是一个数组

​		可变参数与普通类型的参数放在一个形参列表中，必须要保证可变参数是在最后面

​		一个形参列表中只允许出现一个可变参数

作用域

​	Java中，主要的变量为属性（成员变量）和局部变量

​	局部变量一般指定义在成员方法内的变量（定义在代码块的变量也是局部变量）

​	作用域分类 ：

​		全局变量 ：作用域为整个类

​		局部变量 ：除了属性变量之外的变量，作用域为所在的代码块中

​	全局变量可以不赋值直接使用（会赋默认值），局部变量必须赋值后才能使用，因为不会赋默认值

​	注意事项 ：
​		属性和局部变量可以重名，访问时遵循就近原则

​		同一个作用域中，不允许同名变量的出现

​		属性的生命周期较长，伴随着对象的创建而创建，伴随对象的销毁而销毁，局部变量的生命周期较短，伴随代码块的执行而创建，伴随着代码块的结束而销毁	

​		全局变量可以在本类中使用，也可以在其他类中使用（通过对象调用:跨类创建对象，或者方法接受一个类创见的实例作为参数）； 局部变量只能在本类的对应方法中使用

​		全局变量可以增加修饰（public、protected、private...），局部变量不能增加

构造方法/构造器（constructor）

​	是类的一种特殊方法，完成对**新对象的初始化** （对象已经存在，但其中的属性值由构造器完成赋值）

​	特点 ： 方法名与类名保持一致；没有返回值；在创建对象时系统自动调用该类的**构造器完成为对象的属性赋值**

​	基本语法 ：

​		[修饰符] 方法名(形参列表) {方法体}

​		修饰符可以是默认的，也可以是 ： public protected private

​		构造方法没有返回值

​		构造方法名必须与类名一致

​		形参列表要求与方法一致

​		构造器的调用由系统完成（new的时候就完成了）

​	注意事项 ：
​		一个类里面可以由多个构造器，实现构造器的重载

​		构造器与类名一致；没有返回值；在创建对象时，系统自动调用该类的构造器

​		构造器是完成对象的初始化，并不是创建对象；

​		如果没有定义构造器时，系统会自动生成一个默认无参构造方法（就是默认构造方法）

​		 **javap**  ： 反编译查看(不要加class后缀) （class -> java）

​		一旦定义了构造器，将会覆盖默认的构造器，无法再使用默认构造器，如果还是想使用，可以再定义一个无参构造器（显式定义，相当于构造器重载）

对象的创建 ：
		1.加载类信息（只会加载一次）

​		2.在堆中开辟一块空间，存放对象的属性，并赋默认值

​		3.根据类中对属性的赋值进行赋值（显式赋值）

​		4.再根据构造器进行赋值初始化

​		5.将堆中的对象的地址赋值给指定变量

### this关键字

​	Java虚拟机会为每个对象分配一个this，这个this代表着当前的对象

​	this可以看作为一个对象的隐藏属性，其存放的内容为当前对象的地址值（指向这个对象）

​	this ： 哪个对象调用，就指向哪个对象

​	注意事项 ： 

​		this关键字可以用来访问本类的属性（准确定位属性）、方法、构造器

​		this用于区分当前类的属性和局部变量

​		访问成员方法 ： this.方法名（参数列表）

​		访问构造器 ： this(参数列表)  ： 只能在构造器中使用，来访问另一个构造器（参数列表使用实参，要匹配你想要的构造器的形参列表），必须放在构造器的第一条语句中

​		this不能在类的外部使用，只能在类定义的方法中使用

​		方法中如果没有同名变量，则加不加this都是指向对象的属性

注意问题 ：

​	在处理一个数组类型的数据时，应该考虑到数组长度为0（为空），或者数组指向了一个空的问题

​	匿名对象 ：没有名字的对象  即new 类() 后并不会返回给一个对象应用，只能使用一次

​	对于复用构造器时，应该从构造器少的开始

​	hashCode（） ： 返回一个对象的int类型数据，该数据是通过对象在内存中的地址换算而来的，可以将其看成一个地址，但他本身并不是一个地址值（因为在JVM虚拟机上执行的，获取地址没用）

### 包

​	作用 ：

​		区分相同名字的类

​		当类的数量过多时，可以很好的管理类

​		控制访问范围

​	基本语法 ：

​		package 包名

​		package ： 关键字，表示打包

​	包的本质就是创建不同的文件夹来保存类

​	命名规则 ：

​		只包含数字、字母、下划线_、小圆点. 。不能以数字开头，不能为关键字和保留字

​	命名规范 ：

​		小写字母 + 小圆点  ： com.公司名.项目名.业务模块名

​	常用包 ：

​		java.lang : 基本包，直接用，不需要引用

​		java.util : 系统提供的工具包

​		java.net  ： 网络包

​		java.awt  ：界面开发

​	引入包 ：

​		引入一个包就是为了使用一个包中的某些类

​		引用方式可以有 ：

​			import 包名.具体的类  （推荐这种形式，需要什么就导入什么就行）

​			import 包名.* : 将包名中的所有类全部引进来

​	注意细节 ：

​		package 是声明当前类所在的包，要放在类或文件的最前面，一个类最多允许一个包	

​		import 指令放在package后面，类定义之前，可以有多条import，没有顺序要求

### 访问修饰符

​	Java提供四种访问修饰符号，用于控制方法和属性（成员变量）的访问权限（范围）

​	公开级别 ：public ， 对外公开

​	受保护级别 ：protected ，对子类和同一个包中的类公开

​	默认级别：没有修饰符，向同一个包中的类公开

​	私有级别：private ，只有类本身可以访问，不对外公开

​	使用注意事项 ：

​		访问修饰符可以修饰类中的属性、方法以及类

​		类只能由public和默认修饰，遵循访问限制

​		成员方法的

### 	封装

​		封装（encapsulation）就是把抽象出的数据[属性]和对数据的操作[方法]封装在一起，数据被保护在内部，程序的其它部分只有通过被授权的操作【方法]，才能对数据进行操作。

​		把细节封装起来，直接调用（用户用遥控器操作电视）

#### 	好处 

​		隐藏实现细节（调用者只需知道这个有什么用，怎么用）

​		可以对数据进行验证，保证安全合理

#### 	实现 

​		将一个属性进行私有化设置（private）

​		提供一个public的set方法，用来对属性判断并进行复制

​		提供一个public的get方法，用来获取这一个私有化属性的值

​	通常情况下，当调用构造器去设置一个对象的属性时，会直接赋值，并不会对数据进行验证，可以采用构造器 + set方法来实现验证

### 继承 

​	可以解决代码复用，使编程更加接近人类思维，将多个类中相同的属性和方法抽象出父类，在父类中定义这些属性和方法，之后所有的子类无需重新定义这些属性和方法，只需要通过extends来声明继承于父类 （建立一个查找关系）,

#### 	继承语法 

​		class 子类 extends 父类{}

​		子类自动拥有父类定义的属性和方法

#### 	好处 

​			代码的复用性、维护性和可扩展性提高

#### 	细节 

​		子类继承了父类所有的属性和方法，但是私有属性和方法不能被子类直接访问，可以通过公共方法（父类提供的公共方法）间接访问

​		子类在创建一个对象时，必须调用父类的构造器（默认隐藏super()默认调用父类无参构造器），完成对父类的初始化。

​		当子类在创建一个对象时，不管使用子类的哪个构造器，都会默认调用父类的无参构造器去完成对父类的初始化，当父类中没有无参构造器时，就必须在子类的构造器中使用super()来指定要调用父类的哪个构造器来完成父类初始化，否则编译无法通过

​		如果想要指定的父类构造器来实现父类的初始化，直接通过super(参数)显示调用

​		super()必须放在子类构造器的第一行，super也只能存在构造器中（先执行完了父类构造器，再执行子类构造器，即·现有父亲再有儿子）

​		super和this都只能放在构造器的第一行，因此一个构造器中只能存在其中的一个

​		Java中，所有的类都是Object的子类（Object 是所有类的基类）

​		父类构造器的调用限于直接父类，将会一直往上追溯到Object类(顶级父类)（找祖宗，完成祖宗的初始化才能有儿子）

​		子类最多只能继承于一个父类（直接继承），java中是单继承制（那如何实现一个a类继承于两个类b，c，使用两个类的属性和方法？ ： 直接先继承于其中一个类，再让这个类继承于另外一个类）

​		不能滥用继承，子类和父类必须满足 ：is a 的逻辑关系（猫是一个动物，人不是一首音乐）

#### 	继承的本质 

​	创建一个子类时，就建立了一个查找关系

​		查找关系

​			1.先查看子类是否有该属性，有并且可以访问，则返回信息

​			2.如果子类没有，查看父类中是否含有该属性，有并且可以访问时，返回信息

​			3.如果父类还没有，继续往上找，直到Object还未找到，直接报错

​		当再查找过程中，发现找到了指定的属性，但是这个属性是私有的，即使后面有可以访问的指定属性，但是由于先找到了私有的，将会停止查找，并在编译时报错

​		当一个类作为父类时，如果没有默认构造函数，将会在某个类要继承于该类时产生错误，因为子类继承父类时，默认通过无参构造器进行父类初始化，而此时父类的无参构造器已被覆盖，从而产生错误，为此，应该显示调用super使其匹配父类现有的构造器

#### 	super关键字

​		代表父类的引用，用于访问父类的属性，方法和构造器

​		访问属性 ：

​			super.属性名， 不能访问父类的私有属性

​		访问方法 ：

​			super.方法名(形参列表)，不能访问父类的私有方法

​		访问构造器 ：

​			super(参数列表)    只能放在子类的构造函数中；只能放在第一句，有且只有一条super()语句

##### 		细节 

​			调用父类构造器的好处 ： 分工明确，父类属性由父类构造器初始化，子类由子类初始化

​			当子类的属性和方法名与父类的属性与方法名重名时，访问父类的属性和方法，必须使用super来访问，如果没有重名，使用super、this和直接使用没有区别

​			super的访问不限于直父类，如果爷爷类中含有与本类重名的属性或方法，也可以通过super来访问到爷爷类的属性和方法（前提父类没有），如果多个上级类都有重名成员，采取就近原则，谁先找到就是谁，遵循查找规则（私有无法直接得到）

```
此时想要调用某个方法，于是乎，出现了下面的查找顺序 (方法就从方法区中逐步查找)
//        1.先查找本类中是否含有该方法，有就调用自身的cal方法
//        2.如果本类中没有，将会到父类中去查找，如果有，并且可以访问，则执行该方法，如果不能执行，会在编译时报错(没有权限访问)
//        3.如果没有，重复步骤2，3执直到查完Object还没有找到，将t提示方法不存在(无法解析)
   下面三种逻辑在子类没有重名方法时，是等价的
        cal();
        this.cal(); // this的逻辑与直接写的逻辑完全一样
        super.cal();//与上面的查找存在不同 ： 直接查找父类，不会查本类
        
//        访问属性规则 (就直接从堆中直接往上(就是根据父子关系)查)
//        与查找方法是一样的规则
//        this 和 直接引用是等价的，super直接从父类查起
```

#### 	this 与super的区别

#### 方法重写/覆盖（override）

​	子类有一个方法，与父类方法的名称，返回值，形参列表全部一致，称子类的方法覆盖了父类的方法（父子关系不一定是直接关系，可以是祖宗）

##### 	细节 

​		子类的方法名，参数要与父类的方法名，参数必须一样

​		子类方法的返回类型要与父类方法的返回类型一样，或者是子类方法的返回类型是父类方法的返回类型的子类。	

```
父类为 public Object say()  子类可以 ：public String say() 或者 ： public Object say()
```

​		子类方法不能缩小父类方法的访问权限，但是可以放大(根据public > protected > 默认 > private，从左往右缩小，右往左放大)

##### 	与方法重载区别

### 多态 

​	问题 ： 在喂食这个场景中，如果随着动物的种类增多，喂食的方法也会变多，使代码复用性不高，不利于代码维护（引入多态解决）

​	方法和对象具有多种形态，是面向对象的第三大特征，建立在封装和继承基础之上

#### 	方法的多态 

​		方法的重写和重载

#### 	对象的多态（核心，重点，难点）

​		一个对象的编译类型和运行类型可以不一致

​		编译类型在定义对象时，就已经确定了，不能改变

​		运行类型是可以变化的,可以通过getClass() 

​		编译类型 看定义时 = 的左边，运行类型看定义时 = 的右边

```
Animal animal  =  new Dog() :  编译类型是Animal，而运行类型却是Dog，因此可以不一致
animal = new Cat() : 此时运行类型变更为Cat，
```

#### 	细节 

​		多态前提 ： 两个对象（类）存在继承关系

​		向上转型  ： 父类的引用指向了子类的对象（可以是直接子类，也可以是间接子类）

​			语法 ： 父类类型  引用名  = new  子类类型 ()

​			特点 ：可以调用父类中的所有成员(要遵守访问权限) ， 但是无法调用子类的特有成员（编译阶段，能调用的成员由编译类型决定，调用子类特有成员时，编译器无法识别）

​				最终运行结果由运行类型的调用决定，**调用方法时，先找运行类型是否含有，再找父类**（规则与找方法一样）

​		向下转型 ：

​			语法 ： 子类类型  引用名 = （子类类型）父类引用

​			特点 ： 只能强转父类的引用，不能强转父类的对象，

​				在强转父类的引用时，要求原本父类的引用必须指向当前目标类型的对象（如果乱来，虽然编译器看不出来，但是运行一定报错）

​				向下转型后可以调用子类的所有成员

​		属性没有重写之说，**属性的值由编译类型决定**（查找方式与方法不同）

​		instanceOf 比较操作符  ： 判断对象的运行类型是xx类型或在xx类型的子类型，是返回true，否为false （aa instanceof AA）

#### 动态绑定机制（非常重要）

​		调用对象方法时。该方法将会与该对象的运行类型/内存地址相互绑定。调用该运行类型中的方法，当没有找到时，发挥继承机制，到父类查找....

​		当访问对象属性时，没有动态绑定机制，哪里声明哪里调用

#### 多态数组

​	数组定义类型为父类类型，里面保存的实际元素类型为子类类型

​	通过遍历这个数组，来完成访问所有子类，并且可以通过类型判断后再通过向下转型成具体子类调用子类特有方法

#### 多态参数

​	方法定义的形参类型为父类类型，实参类型允许为子类类型

### Object类详解

#### 	equals 方法 

​		==  ：

​			可以用来判断基本类型，又可以用来判断引用类型

​			当判断基本类型时，主要通过判断基本类型的值是不是相等

​			当判断引用类型时，主要通过判断地址是否相同，即两个是不是同一个对象

​			只要有基本类型进行判断，则会判断两者值是否相等

​		equals ：

​			只能判断引用类型

​			默认判断的是地址是否相同（Object直接比较地址），子类往往重写该方法，使其用来判断内容是否相等

​		重写 ：

​			先判断两个对象是不是同一个对象（是true,否false）

​			在判断是不是同一个类型（是，进行向下转型并比较，否false）

#### 	hashCode

​		返回一个对象的哈希码值

​		提高具有哈希结构容器的效率

​		两个引用，指向的对象一样时，其哈希值肯定一样；如果指向不同的对象，则哈希值是不一样的

​		哈希值主要根据地址转换成一个整数（哈希值），但不能与地址等价

​		集合中，hashCode需要的话，也会进行重写

#### 	toString

​		返回对象的字符串表示形式

​		返回字符串 ： 全类名（包名 + 类名） + @ + 十六进制的hashCode值 

​		重写toString方法来实现输出对象的属性值，当然可以定制输出情况

​		当直接输出一个对象时，toString方法会被默认调用 （system.out.println(一个对象)  ==  对象.toString()）

#### 	finalize

​		以及被弃用了，会在对象销毁前，调用finalize方法 （对象并不会在对象没有引用指向时就消亡，会根据相关算法进行消亡）

​		System.gc() : 启动垃圾回收机制

### 断点调试（debug）

​	排错！整个断点调试是运行状态，是以对象的运行类型来执行的

​	快捷键 ： 

​		f11 : 跳入方法  

​		f10 ： 逐行执行

​		shift + f11  ： 跳出方法  : 跳出单个方法

获取一个yyyy-mm-dd hh-mm-ss 格式的时间 ：

​	Date date = new Date();

​	simpleDateFormat sdf = new simpleDateFormat("yyyy-MM-dd HH-mm-ss")；

​	sdf.format(date) : 获取

建议一段代码完成一个功能，尽量不涉及多个功能；

找出错误的条件，然后给出提示（然后正确代码不需判断），如果先正确，需要给出另一个分支来提示错误信息

当一个方法是static时，就是一个静态方法，静态方法可以通过类名直接来进行调用

房屋出租项目分析 ：

​	分层设计 ： （界面 —— 业务——实体）

​		确定系统中有多少个类（创建多少个文件或包，实现不同类不同包管理）

​		确定类与类之间的调用关系

​	架构图 ：（分析从上到下，实现从下到上)

​	实现功能的三部曲 ： 明确完成功能、思路分析、代码实现

## Java 类的组织形式 

​	JDK中有很多包，每个包中含有多个接口、类、异常、枚举；其中类中又有多个字段，构造方法/器，成员方法/方法，

​	找： 先找包，再找类，最后找方法； 直接检索

## 面向对象（高级部分）

### 类变量和类方法

​	类变量引入 

​		对于前面来将，当我们声明一个变量来记录某个类的实例对象完成的某个操作时，往往会定义一个变量通过++来记录，但是有一个非常尴尬的事情，那就是这个变量是独立于该类的，实例对象访问这个变量是十分麻烦的，并且不能体现出OOP，为此引入类变量

​		就在一个类中定义一个变量，通过static修饰这个变量使其成为一个类变量(静态变量)，对于这个变量，类的所有对象实例都可以访问到这个变量

​	类变量的内存布局

​		共识 ：static变量 是同一个类所有对象共享的；在类加载时候static变量就生成了，即使没有创建对象实例也可以访问

​	类变量 ： 

​		也称静态变量/静态属性，是该类的所有对象共享的变量，任何一个该类的对象都可以访问到这个变量（同一个值），任何一个该类的对象对该类的修改都将会影响到其他对象对其的访问（值被修改）

​	定义方式 ：

​		访问修饰符 static 数据类型  变量名（推荐）

​		static 访问修饰符 数据类型 变量名

​	访问 ：

​		类名.类变量名   （推荐）

​		对象名.类变量名（静态变量的访问修饰符与普通属性一致）

​	使用细节 

​		什么时候使用 ： 需要所有对象共享一个变量时，就可以考虑将该变量作为类变量

​		类变量和实例变量的区别 ：类变量是该类的所有对象共享的，实例变量是每个对象独有的

​		加上static就是类变量和静态变量，否则就是实例变量、普通变量、非静态变量

​		类变量可以通过类名.类变量名，对象名.类变量名来进行访问（前提符合访问修饰符），推荐类名.类变量名（java设计者）

​		实例变量不能通过类名.实例变量名访问

​		类变量在类加载是就被创建，因此，即使没有创建对象实例，也可以通过类名访问类变量

​		类变量的生命周期是从类加载时开始，随着类的消亡而销毁（与对象实例没关系）

​	类方法/静态方法

​	定义

​		访问修饰符 static 返回值类型 方法名(形参列表){} (推荐)

​		static 访问修饰符 返回值类型 方法名(形参列表){} 

​	调用 

​		类名.类方法名()

​		对象名.类方法名()

​		前提 ：满足访问修饰符的访问权限和范围

​	经典使用场景 

​		当方法 中不涉及到任何对象或其成员时，则可以将其设置为静态方法，提高开发效率

​		不想创建一个实例，也可以调用某个方法时，非常合适

​	使用细节

​		类方法和普通方法都是随着类的加载而加载，都将结构信息存储在方法区，类方法没有this参数（不能使用this），普通函数隐含this参数

​		类方法可以通过类名和对象名来调用

​		普通方法和对象有关，需要通过对象名来进行调用，不可使用类名调用

​		静态方法中不运行使用和对象有关的关键字 ： this super，普通方法可以使用

​		静态方法只能访问静态变量和静态方法

​		普通方法可以访问普通变量和静态变量

​	静态方法只能访问静态成员，非静态方法可以访问静态和非静态成员（必须遵守访问修饰符的访问范围和限制）

### main方法的语法

​	main方法是Java虚拟机调用的

​	Java虚拟机需要调用main方法，所以该方法必须是public

​	Java虚拟机执行main方法时，不必创建对象，所以是static

​	该方法接受一个String 类型的数组参数，该数组保存执行Java命令时传递给所运行类的参数

​	Java 执行程序 参数1 参数2 参数3....

​	提示 ：main方法中，可以直接调用main方法所在类的静态成员，但不能访问非静态成员，必须先创建一个对象实例，通过这个对象实例来完成访问

### 代码块/初始化块

​	属于类中的成员，类似于方法，将逻辑语句封装在方法体中，通过{}包围起来

​	但与方法不同，没有方法名，参数，返回值，只有方法体，不能通过对象或类显示调用，而是加载类或创建实例对象时，隐式调用

​	基本语法 ：

​		[修饰符] {代码};

​		修饰符 是可选的，使用也只能写 staitc

​		分两种，使用static修饰的为静态代码块，没有static修饰的为普通代码块

​		逻辑语句可以写任何逻辑语句（方法可以怎么写，里面就可以怎么写）

​		；可以省略，但建议带上 

​	理解 ：

​		相当于另一种形式的构造器（构造器的补充机制），可以实现初始化操作

​		使用场景 ：当多个构造器含有多个重复语句时，可以抽取到初始化块中，提高代码重用性

​		代码块的调用顺序优先于构造器

​	细节 ：

​		static代码块 ： 静态代码块，作用：对类进行初始化，随着类的加载而执行，并且**只会执行一次**，如果是普通代码块，每创建一个对象就是执行一次

类什么时候被加载 ：

​	创建对象实例时

​	创建子类对象实例时，父类将会被加载

​	使用类的静态成员时

​		普通代码块将会在创建对象实例时，被隐式调用，创建一次，调用一次。当执行类的静态成员时，普通代码块将不会执行

​		创建一个对象时，在一个类的调用顺序 ：

​			调用静态代码块和静态属性初始化 ：两个优先级一致，若存在多个静态代码块和静态属性初始化，按照定义顺序来调用

​			调用普通代码块和普通属性初始化 ： 两个优先级一致，存在多个，按定义顺序执行

​			调用构造方法

​		构造器的最前面其实是隐含了super()和调用本类的普通代码块

​		创建一个子类实例对象时，静态代码块、静态属性初始化、普通代码块、普通属性初始化、构造函数调用顺序：

​			父类静态代码块、静态属性初始化（优先级一致，看定义顺序）

​			子类静态代码块、静态属性初始化（优先级一致，看定义顺序）

​			父类普通代码块，父类普通属性初始化（优先级一致，看定义顺序）

​			父类构造器

​			子类普通代码块，子类普通属性初始化（优先级一致，看定义顺序）

​			子类构造器

​		静态代码块只能调用静态成员，普通代码块能

### 设计模式 

​	静态成员的经典使用

​	是在大量的实践中总结和理论化之后优选的代码结构，编程风格以及解决问题的思考方式

​	单例模式 

​		采取一定方法保证在整个软件运行过程中，对于某个类，只存在一个对象实例，并且该类只能提供一个取得其对象实例的方法

​		方式 ： 饿汉式   懒汉式

​		饿汉式 ：

​			类一旦加载，对象就被创建了，就不管会不会使用这个对象实例，都会创建出来（在单例模式中，对象是重量级的，如果创建不使用会造成资源的浪费）

​			 构造器私有化

​			类内部创建对象(静态)

​			向外暴露一个静态的公共方法 ： getInstance 

​		懒汉式 ：

​			只会等到你要使用这个对象实例，他才会创建出来

​			 构造器私有化

​			类内部创建对象(静态)（不进行赋值操作，）

​			向外暴露一个静态的公共方法 ： getInstance（只有使用时才会创建一个对象）

​		区别 ：

​			创建对象时机不同 ：饿汉在加载类信息时创建对象，懒汉在使用对象时才会创建对象

​			饿汉没有线程安全问题，懒汉有

​			懒汉没有资源浪费问题，饿汉有

### final

​	修饰类、属性、方法、局部变量

​	防止类被继承、方法被重写、属性值和局部变量被修改

​	细节 

​		final修饰的属性又称为常量（可以作为函数形参），一般采用XX_XX_XX形式命名

​		final修饰的属性定义时必须赋值，可以在定义时赋值、构造器中赋值、代码块中赋值

​		如果final修饰的属性是静态的，只能在定义时赋值，静态代码块中赋值

​		final类不能继承，但可以实例化对象

​		如果类不是final，但含有final方法，虽然方法不能重写，但可以被继承

​		一般来讲，当一个类已经被final修饰，没有必要将方法也使用final修饰（可以，但没必要）

​		final不能修饰构造器

​		final 与static 搭配使用时，效率更高，不会引起类的加载，底层实现了优化处理

​		包装类： Integer 、Boolean 、String、Double...都是final类

### 抽象类

​	当父类的某些方法，需要声明时，但又不确定如何实现时，可以将其声明为抽象方法，则这个类就是抽象类

​	当一个类的方法无法确定时，可以使用abstract来修饰该方法，使其成为抽象方法，并使用abstract来修饰该类，使其成为抽象类，抽象类一般会被继承，抽象方法将会通过子类来实现

​	抽象方法 ： 就是通过abstract修饰的没有方法体的方法；访问修饰符 abstract 方法名（形参）；没有方法体！！

​	抽象类  ： 访问修饰符 abstract 类名 {}

​	抽象类更多再与设计，让子类继承并实现抽象类

​	细节 

​		抽象类不能进行实例化

​		抽象类不一定要包含abstract方法，抽象类可以没有abstract方法，还可以有实现的方法

​		一旦一个类有了抽象方法，则这个类必须使用abstract修饰

​		abstract只能修饰方法和类，不能修饰属性

​		抽象类可以有任意成员

​		一个类继承一个抽象类时，必须实现抽象类的所有抽象方法（有一个方法体就行，里面不加东西无所谓），除非这个类也是一个抽象类 

​		抽象方法不能使用private、final和static 所修饰（三者与重写相违背,static 与重写无关，且无法进行重写）

​	模板设计模式（抽象类使用场景）

​		在父类中定义方法来确定整个程序的执行流程，然后提供抽象方法，让子类来实现具体的操作步骤



### 接口（interface）

​	给出一些没有实现的方法，将其封装到一起，到某个类要使用时，再根据具体情况将方法写出来 (接口类也指接口)

​	语法 ： 

​		interface 接口名 { 属性、方法（抽象、默认实现方法、静态方法） }

​		class 类名 implements 接口 { 本类成员 ，必须实现接口中的抽象方法（没有方法体的方法，再接口中，abstract可以省略不写） }

​	jdk7.0前，接口中的所有方法都没有方法体，即全部都是抽象方法

​	jdk8.0后（包含8），接口中可以有静态方法，默认方法（需要使用 default 来修饰该方法），即接口中可以有具体方法的实现

​	细节 

​		接口不能实例化

​		接口中的所有方法都是public，抽象方法可以不用写abstract

​		一个普通类实现接口，就必须j将该接口的所有方法都实现

​		抽象类实现接口，可以不实现接口中的抽象方法

​		一个类可以实现多个接口，接口通过 ， 隔开

​		接口的属性只能为final，等价于public static final ，访问属性为 接口名.属性

​		接口不能继承于其他类，但可以**继承**（不是实现）多个其他接口

​		接口的修饰符只能由public 或默认修饰（与类一致）

​	接口与继承类

​		实现接口是对Java单继承的补充

​		子类继承于父类时，就自动拥有了父类的功能，如果子类还需要进行扩展，可以通过实现接口的方式进行扩展

​		本身就有的就是继承，实现是通过学习

​	不同 ：

​		解决问题不同 ： 

​			继承解决代码复用性和可维护性

​			接口设计各种规范，让其他类来进行实现，更加灵活

​		灵活性 ： 

​			继承必须是 is - a 的关系，而接口只需满足 like - a （像...）

​		接口一定程度上实现代码的解耦（接口规范性 + 动态绑定）

​	接口的多态特性

​		多态参数

​			当形参是一个接口类型时，可以接受任何实现该接口类创建的实例对象（接口类型的变量，可以指向实现了该接口的类的实例对象）

​		多态数组

​			接口类型的数组(多态数组) (可以存放实现了该接口类的实例对象)

​		多态传递

​			当一个接口B继承于另一个接口A，此时有一个类实现了接口B，那么就相当于这个类也实现了接口A

类的成员 ：属性、方法、构造器、代码块、内部类（重、难）

内部类（重难点）

​	一个类的内部中又完整了另一个类的结构，被嵌套的类就称为内部类，嵌套其他类的类被称为外部类，与外部类平级的没有嵌套其他类的称为外部其他类

​	最大特点：可以直接访问私有属性，体现类与类之间的包含关系

​	4种内部类

​		定义在外部类局部位置 （方法上...） 

​			局部内部类（有类名）

​			匿名内部类（无类名，重点）

​		定义在外部类的成员位置上

​			成员内部类（不用static修饰）

​			静态内部类（使用static修饰）

​	局部内部类

​		通常在方法上，可以直接访问外部类的所有成员，包括私有属性

​		局部内部类不能被访问修饰符所修饰，但可以被final修饰，使其不能被继承

​		本质还是一个类

​		作用域 ： 仅仅在局部内部类所在的方法或代码块中

​		外部类使用局部内部类，在方法（代码块）中去创建局部内部类的实例对象，再通过实例对象来完成调用

​		外部其他类不能访问局部内部类（本来就是一个局部变量）

​		当外部类与内部类的成员重名时，采用就近原则，如果想直接访问外部类成员 ，采用外部类.this.成员（外部类.this 就是一个对象，谁调用就是谁）

​	匿名内部类（！！！！）

​		本质是一个类，还是处于外部类的局部，没有类名字（系统分配名字，看不到罢了），同时还是一个对象

​		基本语法 ：

​			new 类或接口 （参数列表） {}

​		引入 ： 当我们要使用一个接口并创建一个对象时，传统上是直接创建一个类来实现该接口，并创建该类的实例对象，

​			但问题来了 ：如果我们只会使用一次这个类，用完了就不用了，那么按照传统的实用就不太合适了，于是匿名内部类就来了

```
基于接口
IA tiger = new IA() { //接口实现匿名内部类
	重写IA中的抽象方法
};
编译类型 ： IA  运行类型就是 ： 匿名内部类 （系统分配类名 ： 外部类 + $1） 
底层在创建了匿名内部类后会立马创建一个对象实例并返回给相关引用
匿名内部类返回实例后就会消失
底层匿名内部类实现 ： 
class XXXX implements IA {
	重写IA中的抽象方法
}
基于类
Father father = new Father(形参列表){
		重写Father 中的方法（如果Father是抽象类，则必须全部实现Father中的所有抽象方法）
};
编译类型 ： Father  运行类型 ： 外部类$1;
底层匿名内部类实现 ：
class XXXX extends Father{
	重写Father 中的方法（如果Father是抽象类，则必须全部实现Father中的所有抽象方法）
}
需要注意的是 ：
	形参列表将会传递给Father的构造器，而匿名内部类无法重写Father的构造器！
	Father father = new Father(); 与Father father = new Father(){};
	两者区别 ：前者就是Father类创建实例，运行类型为father，后者为基于father类创建匿名内部类，运行类型为 外部类$1
```

​	细节 

​		匿名内部类既是一个类，也是一个对象，因此调用一个方法有两种方法

​			使用引用接受，再通过引用调用 ； 直接调用

​		可以直接访问外部类的所有成员 （访问形式 ： 直接访问，）

​		匿名内部类不能添加访问修饰符（因为是一个局部变量）

​		作用域在所在的方法和代码块，并且使用一次就没了	

​		外部其他类无法访问到匿名内部类

​		当外部类与匿名内部类的成员重名时，采用就近原则，如果想直接访问外部类成员 ，采用外部类.this.成员 （外部类.this 就是一个对象，谁调用就是谁）

​	引用场景 

​		当作实参直接传递，简洁高效（相互不影响，不会一直存在）

成员内部类 

​	定义在外部类的成员位置，并且没有static修饰

​	可以直接访问外部类的所有成员，包括私有

​	可以添加任何访问修饰符，因为本质是一个成员

​	内部类访问外部类成员 ： 直接访问 

​	外部类访问内部类成员 ： 创建内部类实例对象，再访问

​	外部其他类访问内部类 ：

​		外部类.内部类  引用名 = 外部类实例.new 内部类名()

​		在外部类提供一个方法，返回内部类实例

​		new 外部类(). new 内部类()  相当于第一种形式

​	当外部类的成员与内部类的成员重名时，将遵循就近原则，如果想要访问外部类的成员，使用 ： 外部类.this.成员名

静态内部类 

​	定义在外部类的成员位置，使用static修饰

​	可以直接访问外部类的静态成员，不能访问非静态成员 （静态内部类访问外部类）

​	可以添加任何访问修饰符

​	作用域为整个外部类体

​	外部类访问静态内部类 ： 创建静态内部类对象进行访问

​	外部其他类访问静态内部类 ：

​		直接通过类名来进行访问（要确保符合访问权限） 外部类.内部类  引用 = new 外部类.内部类（）

​		编写方法返回静态内部类 （静态方法也行） （如果不想创建外部类实例对象，就可以通过静态方法来返回静态内部类）

​	当外部类的成员与内部类的成员重名时，将遵循就近原则，如果想要访问外部类的成员，使用 ： 外部类.成员名

```
/**
 * @author XXX
 * @version 1.0
 */在idea中自动生成这段代码 ：文件 - 编辑器 - 文件和代码模板 -include，加上就行
```

## 枚举与注解

### 枚举（enumeration，enum）

​	将具体的对象一个一个列举出来，就是一个枚举类

​	枚举就是一种常量的集合（一组特殊的类，里面包含一组有限特定的对象）

实现方式 

​	自定义枚举  

​		私有化构造器 ，使其无法通过构造器创建新的对象 

​		取消set方法，防止修改对象属性（枚举对象是只读 ）

​		在类的内部直接创建固定对象实例（static 、final、public 向外暴露对象）(访问就是类.对象名 )

​		枚举对象名通常全部使用大写（常量命名规范），根据需要，可以有多个属性

​	enum关键字实现枚举

​		使用enum代替class

​		使用 常量名(形参列表) 代替 public static final 类名 常量名 = new 类名(形参列表)  形参列表中的形参还会传递给构造器

​		多个常量对象使用 , 分隔

​		常量必须放在枚举类最前面

​	细节 

​		使用enum开发一个枚举类时，该类默认继承于Enum类，并且该枚举类还是一个final类型 （javap）

​		如果我们使用一个无参构造器来创建常量对象，则可以省略（），即 常量名

​		常量对象的匿名内部类 ：枚举常量后面的 `{}` 是在为该常量创建一个匿名内部类，这个内部类负责实现接口中的抽象方法，这是 Java 枚举类型支持的一种特殊语法

​	Enum常用方法 ：

​		name() :返回 一个枚举对象的名字

​		ordinal() : 返回一个枚举对象的编号

​		values ： 返回一个枚举类型数组，里面存放了所有的枚举类型对象

​		valuesOf() ： 接受一个字符串，将其转换为一个枚举对象（前提是这个字符串与枚举对象名字相等，否则报错）

​		compareTo() ： 接受一个枚举对象，比较调用该方法的枚举对象与接受的枚举对象的编号，返回两者的差值

​	细节 

​		类使用enum关键字后，隐式继承Enum类，不能再继承其他类（单继承机制）

​		enum类可以实现接口 enum 类名 implements 接口名

​	for()增强 ： 语法 ： for(类型  引用名 ： 数组){ 循环体 }  类型与数组类型一致   

​		执行流程 ： 依次从数组中取出一个元素，将其赋值给引用名，然后执行循环体，直到数组遍历完停止执行 

### 注解（Annotation）/ 元数据（Metadata）

​	注解 ： 被称为元数据，用于修饰解释 包、类、方法、属性、构造器、局部变量等数据信息

​	和注释一样，不影响程序逻辑，但注解可以被编译或运行，相当于嵌入在代码中的补充信息

​	JavaSE 中，注解往往是用于标记过时功能，忽略警告等，JavaEE 中，用于配置应用程序的任何切面，代替Java EE 旧版中所遗留的繁冗代码和 XML配置等

​	使用Annotation 时，在其前面增加 @，并将Annotation当作一个修饰符使用，用于修饰它支持的程序元素

​	基本Annotation ：

​		@Override ： 限定某个方法，是重写父类方法，该注解只能用于方法（不能修饰其他类，包、属性等）

​					如果不写@Override，结果还是父类方法的重写

​					写了@Override,编译器会主动检查是否重写了父类的方法，是就编译通过，不是就编译错误，起到语法校验

​		@Deprecated ： 用于表示某个程序元素（类、方法..）已经过时，即不推荐使用，但是还是可以使用的

​					可以修饰方法 、 包、 字段、 参数 、 类 ....

​					可以做到新旧版本的兼容和过渡

​		@SuppressWarnings : 抑制编译器警告

​					程序可以运行，但是编译器会使用下划线提示一个警告

​					如果不想显示这些警告，可以通过@SuppressWarnings来抑制这些警告

​					在{""}中，可以加入你想要抑制的警告信息,all 是抑制所有的警告信息

​					SuppressWarnings作用范围与放置位置有关(语句、方法、类)

​					 修饰类、字段、方法、参数、构造器...传递一个字符串数组，表明可以接受多个抑制信息



​	@interface的说明 ： 表示是一个注解类，并不表示接口（jdk1.5加入）

​	@Target ：是修饰注解的注解，为元注解

​	元注解 

​		修饰注解的注解

​		Retention : 指定注解的作用范围

​				@Retention包含一个RetentionPolicy类型的成员变量，使用该元注解必须为该value成员变量指定值

​				RetentionPolicy.SOURCE ： 编译器使用后，直接丢弃这种策略的注解（Java源码上生效）

​				RetentionPolicy.CLASS ： 编译器使用后，将注解保留到class文件，运行时，JVM不会保留注解，这是默认值（一直到class文件上）

​				RetentionPolicy.RUNTIME ： 编译器使用后，将注解保留到class文件，运行时，JVM会保留注解，程序可以通过反射获取该注解

​		Target ： 指定注解使用的地方

​				也包含一个名为value的成员变量，里面指明可以使用的位置

​		Documented ： 指定注解是否会在javadoc上体现，注解会不会显示在javadoc文档上

​		Inherited ：子类会继承父类的注解 ，被其修饰的注解将会拥有继承性

## 异常Exception

​	异常 ： Java语言中，将程序执行中发生的不正常现象(语法错误和逻辑错误不是异常)

​	分类 ：

​		Error（错误） ：是严重错误，程序崩溃

​		Exception（异常） ： 运行时异常（程序运行时，发生的异常）

​						    编译时异常（编译时，编译器检查出来的异常）

异常体系图

​	虚线  ：实现接口 ，实现 ： 继承类

​	小结 

​		运行时异常，编译器是检查不出来，一般是编程时的逻辑错误，程序员应该避免，RuntimeException类及其子类都属于运行时异常

​		运行时异常不需要进行处理（太普遍了，会对程序可读性和运行效率产生影响）

​		编译时异常 ：编译器要求必须处理的异常

​	常见运行时异常

​		NullPointerException : 空指针异常 当程序试图在使用对象的时候使用了null，就抛出该异常

​		ArithmeticException :  出现异常的运算条件时，抛出该异常（除0）

​		ArrayIndexOutOfBoundsException : 数组索引为负数或者大于等于数组长度时，抛出该异常		

​		ClassCastException ： 试图将对象强制转化为不是实例的子类时，抛出改该异常

​		NumberFormatException : 数字格式不正确异常 ，将一个字符串转换为数值类型时，但字符串不能转成适当格式时抛出异常

​	常见编译异常

​		SOLException : 操作数据库时，查询表可能发生异常

​		IOEException ：操作文件时，发生异常

​		FileNotFoundException ： 操作一个不存在的文件

​		ClassNotFoundExceotion ：加载类，类不存在

​		EOFException ： 操作文件，到文件末尾，发生异常

​		IllegalArgumentException : 参数异常（命令行参数） 

​	异常处理 

​		发生异常时，对异常的处理方式

​		try - catch -finally ： 程序员在代码中捕获异常，自行处理

​		throws ： 将发生异常抛出，交给调用者（谁调用，谁处理）处理，最顶级的处理者为JVM（处理异常信息 ： 简单暴力，直接输出异常信息，中断程序）。	当发生异常后，没有try-catch-finally或者没有显示throws，将会默认给其添加一个隐式的throws		

​	try -catch方式 ：

​		基本语法 ：

​			try { 可疑代码 }catch(Exception e) { 异常处理 } （没有finally也是可以的）

​		细节 

​			如果发生异常，则异常发生后面的代码不会执行，直接进入到catch块

​			如果没有异常发，则顺序执行try的代码块，不进入catch

​			如果希望不管是否发生异常，都想要执行某段代码（关闭连接，释放资源），则使用finally

​			可以存在多个catch语句，捕获不同的异常（执行不同的业务处理），要求父类异常在后，子类异常在前，如果发生一个异常，将自会匹配到一个catch 

​			可以使用 try-finally（执行一段代码，不管是否发生异常，都必须执行某个业务逻辑），这种就是相当于没有捕获异常，程序会直接崩掉（但还是执行finally）

​		当一个方法体内部使用try-catch-finally来处理异常时，即使catch捕获到异常，并在catch内部执行了return语句，并返回了一个值，但并不会立马跳出方法，继续执行finally中的代码，如果这个finally也有return语句，将会对catch的return进行覆盖，返回finally中的值

​		如果finally中没有返回值，并修改了捕获了异常的catch中的返回值，则最终返回的值为之前的返回值（会使用临时变量进行存放返回值，然后返回临时变量的值）

throws 方式 ：

​	语法 ： 方法（） throws  异常,异常.....

​	如果一个方法可能产生某种异常，但并不能确定如何处理这种异常，则此方法应显示地声明抛出异常，表示该方法将不会处理这些异常，由**方法的调用者负责处理**

​	在方法声明中用throws语句可以声明抛出异常列表，throws后面的异常类型可以是方法中产生异常的类型或者其父类

​	细节 

​		对于编译异常，必须使用try-catch或throws处理

​		对于运行异常，程序没有处理（即没有显示处理），将会默认使用throws处理

​		子类方法重写父类方法时，对于异常处理规定有以下要求 ： 子类抛出的异常处理类型要么与父类异常处理类型一致或者是父类异常的子类

​		在throws过程中，如果有方法try-catch，就相当于异常处理，不需要再选择throws （二选一）

​		当一个方法主动抛出一个异常时，该异常将会交给调用该方法的调用者来处理这个异常，如果抛出了编译异常，就必须要求调用者通过try-catch或者继续抛出throws来解决这个编译异常，否则将会包错；如果抛出了运行异常，如果调用者不进行处理也可以（默认处理机制throws）

自定义异常

​	定义类 ： 自定义类名 继承Exception(属于编译异常)、RunTimeException（属于运行异常）（一般继承于RunTimeException，成为运行异常，可以使用默认处理机制）

throw 与 throws 的区别

## 常用类

### 包装类Wrapper

​	包装类 ： 针对八种基本数据类型相应的引用类型 (可以调用相应的方法)

​	包装类与基本数据类型的转换（装箱和拆箱）

​		装箱 ： 基本数据类型转换到包装类   拆箱 ：包装类转换到基本数据类型 （JDK5前是手动装箱，JDK5后为自动装箱）

```
	int 与 Integer 的转换 
	int n1 = 10;
	Integer integer1 = Integer.valueOf(n1); // 装箱  一个弃用的方法 ： Integer integer1 = new Integer(n1); (9~弃用并标记移除)
	int n2 = integer1.intValue(); // 拆箱
	
	自动：
	int n2 = 10;
	Integer integer2 = n2; // 底层还是valueOf()
	int n3 = integer2; // 底层是 intValue()
	（其余类型一致）
	
	Integer 与 String 的转换
	Integer i = 10; //都不会改变原来integer类型
	String str1 = i + ""; //1
	String str2 = i.toString(); //2
	String str2 = String.valueOf(i) //3 String.valueOf 是接受一个Object类型 ,并将其转换为字符串（可以借此将基本类型转为字符串）
	
	String str3 = "1234";
	Integer i2 = Integer.parseInt(str3);
	Integer i3 = new Integer(str3) // 9~弃用并标记移除
	
Integer 和 Character 的常用方法 
Integer.MIN_VALUE  ： 返回最大值
Integer.MAX_VALUE ： 返回最小值

Character.isDigit() ： 判断字符是不是数字
Character.isLetter() ： 判断字符是不是字母
Character.isUpperCase() ： 判断字符是不是大写
Character.isLowerCase() ： 判断字符是不是小写
Character.isWhitespace() ： 判断字符是不是空格
Character.toUpperCase() ： 将字符转换为大写
Character.toLowerCase() ： 将字符转换为小写
	
```

​		Integer.valueOf()  :  该方法再装箱时，会判断数值是否再在 -128 ~127之间，如果是，将直接从数组中返回对应值，如果不在，将主动新建一个对象并返回（return new Integer(i)） 

### String类

​	String对象用于保存字符串（一组字符序列）

​	字符串常量对象是用双引号括起的字符序列 ， 使用Unicode编码，一个字符两个字节

​	String类实现了两个接口 ： Serializable 和 Comparable ，前者可以使String对象进行串行化（网络传输），后者可以是String对象进行相互比较

​	String中有属性 ： private final char value[] ：用来存放字符串内容 （jdk9+后改为byte[],逻辑类似）

​	value被final修饰，表示不可修改，但是这个不可被修改是指指向的地址（一个字符数组）不可进行修改，但地址中的内容（数组存放的内容）可以进行修改

​	整体上String也是一个不可变类，然后对String的修改会导致创建并使value指向一个新的字符串

​	常用构造器 ：new String() ; new String(String original) ; new String(char[] a); new String(char[] a,int startIndex,int count); new String(byte[] b)

​	创建方式 ：

​		直接赋值 ：直接在常量池中查找是否含有该字符串，有则直接指向该字符串，没有则在常量池中创建一个字符串并指向该字符串

​		调用构造器 ： 先在堆中开辟一块空间，然后堆中的value指向常量池中的对应字符串（有就直接指向，没有就创建再指向），最后将堆中的地址返回给引用

intern() ：最终返回的是常量池中存放相应字符串的地址（没有就会创建出来再返回地址）

对于 String a  = "hello" + "abc";这条语句，编译器会自动优化，使其等价于 ： String a = "helloabc"。即该语句会生成一个对象

编译器不傻，会判断常量池中的对象是否有引用指向，没有就不创建，有就创建一个

```
        String a = "hello";
        String b = "abc";
//        1.先创建一个 StringBuilder sb = StringBuilder();
//        2.执行 sb.append("hello");
//        3.再执行 sb.append("abc");
//        4. String c = sb.toString();
//        最后就是c指向了堆中的一个对象(String),该对象的value并不会指向常量池中的"helloabc"(并且常量池中
//        也没有"helloabc"这个字符串)，而是指向自身存放字符序列的数组
        String c = a + b;  // 创建StringBuffer对象，不断通过append将字符串加进去，存放到堆中
//        当调用intern()方法后，直接把当前堆中这个 String 对象引用放入常量池。
//        常量池的引用也将会指向堆中的String对象(新增字符串 ： "helloabc")
        System.out.println(c == c.intern()); // true
//        String d = "helloabc";
//        System.out.println(c == d);
    }
```

常量相加看池，变量相加看堆，final 特殊编译归池

intern() → 把堆中字符串注册到常量池（JDK7+ 不复制）,并返回字符串在常量池的索引



​	常用方法 

​		equals() 方法

​		equalsIgnoreCase() 忽略大小写比较内容

​		length() 

​		indexOf() : 获取字符或字符串在指定字符串中第一次出现的索引位置，找不到返回-1

​		lastIndexOf() ：获取字符或字符串在指定字符串中最后一次出现的索引位置，找不到返回-1

​		substring() : 截取指定范围的子串，一个参数就是从该索引到头，两个索引就是截取两个索引之间  [  )

​		trim() ：去前后格

​		 toUpperCase() : 转大写 (不会修改原字符串)

​		toLowerCase() : 转小写(不会修改原字符串)

​		concat() ：拼接字符串

​		 replace() : 替换字符串中的字符

​		split() : 分隔字符串，对于某些分隔字符，需要进行转义 ： | 、\\...  在对字符串进行分割，如果有特殊字符，需要加入转义符 ： /

​		toCharArryay() : 转换成字符数组

​		compareTo() 比较两个字符串的大小，前者大返回正数，后者大返回负数(前字符减去后字符)，相等为0

​			长度相同，并且每个字符都相同，返回0	

​			长度相同或不相同，在比较时，可以区分大小写，就返回 ： c1 - c2(c1 != c2)

​			如果前面的部分都相同，就返回str1.len - str2.len

​		format() 格式字符串  %s(字符串替换) %d(整数) %.2f(小数，并保留2位小数点，四舍五入) %c(char) : 都是占位符，由后面的变量替换

### StringBuffer 类

​	对String的增强，代表可变的字符序列，可以对字符串内容进行增删

​	主要使用在多线程

​	很多方法与String相同，但StringBuffer是可变长度，同时StringBuffer是一个容器

​	直接父类 ： AbstractStringBuilder, 存在属性 ：byte[] value 存放字符序列，没有final修饰

​	实现了Serializable 和 Comparable 接口，可以实现串行化 和比较

​	StringBuffer 被final修饰，无法被继承

​	StringBuffer 与 String的区别 ：

​		String保存的是字符串常量，不能被修改，每次更改都是改地址，创建新对象，效率低 （private final byte value[]）

​		StringBuffer 保存字符串变量，里面的值可以被修改，每次更改的是内容，不用每次更新地址/创建新对象（数组空间不够，才进行扩展修改地址/创建新对象）,效率高 （byte value[]，并存放在堆中）

​	StringBuffer 与 String 的相互转换

​		String 转 StringBuffer

​			StringBuffer构造器接受一个字符串 ； StringBuffer的append方法（实例方法），参数为接受字符串

​		StringBuffer 转 String

​			String的构造器接受StringBuffer； StringBuffer的toString方法

​	常用方法

​		append(String str) ： 在原先字符序列增加字符序列 ,当传递一个空对象时，主动转换为“null”字符串

​		delete(int a,intb) ： 删除索引在[a,b)之间的字符

​		replace(int a,int b,String str) ：将索引在[a,b)之间的字符序列替换成str

​		indexOf(String str) ：找出指定字串在字符串第一次出现的索引,找不到 ： -1

​		insert(int index,String str) ：在指定索引位置插入指定字符串，索引后的内容往后移

​		length() ： 返回长度

### StringBuilder类

​	一个可变的字符串序列，提供与StringBuffer兼容的API，但不保证同步（不是线程安全），是StringBuffer类的一个简易替换，**用在字符串缓存区被单个线程使用时**，建议使用该类，比StringBuffer更快（大多数实现上）

​	主要操作为 append 和 insert，可以重载这些方法，以接受任意类型数据

​	大体与StringBuffer一致

​	字符序列仍然存放在父类AbstractStringBuilder的byte value[]中(堆)

​	StringBuilder 的方法，没有做互斥处理，没有synchronized 关键字，因此在单线程的情况下使用StringBuilder

String 、StringBuffer、StringBuilder比较

​	StringBuffer 和 StringBuilder 非常相似，均是可变字符串序列，方法一致

​	String ： 不可变字符串序列，效率低，但复用性高(常量池不会出现相同字符串)

​	StringBuffer ：可变字符串序列，效率较高(增加，删除)，线程安全（方法都由 ： synchronized  修饰）

​	StringBuilder ：可变字符串序列，效率最高，线程不安全

​	String ： 在对String类型字符序列进行操作时，多次执行修改内容的操作会导致大量副本字符串对象（丢弃原有）留存在内存中，降低效率，极大影响效率

​	因此，当我们对String做出大量修改时，不使用String

使用 ： 

​	当字符串存在大量修改的操作，一般使用StringBuffer 和StringBuilder

​	当在单线程的情况下大量操作时，使用StringBuilder

​	当在多线程的情况下大量操作，使用Stringbuffer

​	如果对字符串很少修改，被多个对象引用，是用String

### Math类

​	执行基本数学运算的方法（大部分是静态方法）

​	abs ：绝对值

​	pow(int a,int b) : 求幂(a 的 b 次幂) (double)

​	ceil() : 向上取整，返回大于等于该参数的最小整数 (double)

​	floor() : 向下取整，返回小于等于该参数的最小整数(double)

​	round() : 四舍五入，floor(参数 + 0.5)

​	sqrt() : 求开方

​	random() : 随机数 ([0,1))  ：生成一个a - b 之间的数 ： Math.random * (b - a + 1) + a

​	max()最大值 、 min()最小值

### Arrays类

​	一系列静态方法，管理和操作数组

​	 toString() : 返回数组的字符串形式

​	sort() : 排序数组 分默认排序(传递数组就行，从大到小)和定制排序

```
定制排序 ： 传入一个接口Comparator实现定制排序(一个实现该接口的匿名内部类)
//                  两个参数 ： 一个是待排序数组，一个就是实现了Comparator接口的匿名内部类(实现compare方法)
//        执行流程 ：
//        先是Arrays.sort()方法，
//        进入TimSort类的private static <T> void binarySort(T[] a, int lo, int hi, int start,
//        Comparator<? super T> c)
//        代码执行binarySort方法时，会根据动态绑定机制执行我们传入的匿名内部类compare();
//        然后就是根据compare()的返回值来决定排列顺序
//        接口编程 + 动态绑定 + 匿名内部类 的综合使用
```

​	binarySearch() : 通过二分搜索进行查找，并返回下标，要求数组为有序数组

​		有序就行(大到小，小到大)，如果是无序的，将不能使用binarySearch

​		如果数组不存在该元素，返回负数(-(low + 1) 即这个数如果存在的话，下标+1的负数).

​	copyOf() : 数组元素的复制

​		从integers 数组中拷贝 integers.length 个元素到newArray中 （底层使用System.arraycopy()）

​		如果拷贝的长度大于原数组，将会在新数组的后面增加 null，如果长度小于0，抛出异常NegativeArraySizeException

​	fill() : 数组元素填充

​		把指定数组中的元素全部替换成指定元素

​	equals() : 比较两个数组中的元素是不是完全一样

​	asList() : 将一组值，转换为一个list集合

​		list 集合 ：编译类型 ： List(接口)， 运行类型 ： java.util.Arrays$ArrayList (Arrays 中的静态内部类)

### System类

​	exit() ：退出当前程序

​		参数 ：程序退出的状态， 0 表示正常状态

​	arraycopy() ： 复制数组（比较适合底层调用），一般情况下使用Arrays中的copyOf 

​		参数 ： 源数组， 源数组拷贝起始位置，目标数组，目标数组起始位置，拷贝长度

​	currentTimeMillens() ： 返回当前时间离1920-1-1的毫秒数

​	gc() ：运行系统垃圾回收机制

### BigInteger类

​	适合保存比较大的整数

​	在对 BigInteger 进行加减乘除时，应该使用相应方法，不能直接使用符号，可以通过创建一个要操作的BigInteger，再调用相关方法进行运算

​	底层上是将其作为一个字符串，然后再转为BigInteger

### BigDecimal类

​	适合保存精度较高的浮点数

​	整体与BigInteger一样，但是除法上有区别 ，可能抛错

​	当除法发生除不尽时，会抛出一个ArithmeticException错误，此时可以指定保留精度来避免抛错

​	在除法方法后增加 ：RoundingMode.CEILING 来使其自动保留到分子的精度  （BigDecimal.ROUND_CEILING(但是已经弃用)）

### 日期类

​	Date(第一代日期类) 

​		jdk1.0

​		单位毫秒，表事件特定的瞬间 （离1970.1.1 00:00:00 的毫秒数） 

​		获取当前系统时间 ： new Date() 通过创建一个对象获取时间 （此时该时间为国外格式，因此需要对格式进行转换）

​		给定指定毫秒数获取时间 ： new Date(long time) ： 传入一个long类型数值，会返回一个时间

​		转换格式 ： 创建一个 simpleDateFormat 对象 ，通过为构造器传参来指定时间格式

​				需要注意的是，格式的字母是规定好的，不能乱来

​		simpleDateFormat 的方法	

​			format() 方法 ：按照指定的格式将 Date 对象转换为字符串；

​			parse() 方法 ： 将字符串按照指定格式转换为 Date 对象 

```
SimpleDateFormat simpleDateFormat = new SimpleDateFormat("yyyy年MM月dd日 HH:mm:ss E");

String format = simpleDateFormat.format(date);

String format1 = "1996年12月12日 12:12:12 星期一";  // 必须符合 yyyy年MM月dd日 HH:mm:ss E ，否则抛错
Date parse = simpleDateFormat.parse(format1);

```

​	Calendar(第二代日期类)

​		jdk1.1 （引入Calendar后，Date大部分方法被弃用）

​		构造器受保护(protected)，通过getInstance()方法来获取实例对象

​		提供大量方法和字段供用户使用 （通过 实例对象.get(Calendar.字段) 获取相应字段表示的时间） （月份需 + 1 ，月份从零开始）

​		不提供格式化的类，需自行搭配

​	第三代日期类

​		jdk8

​		前两代日期问题 ：

​			可变性 ： 日期和时间这样的类是不能改变的，但calendar可以

​			偏移性 ： Date年份从1900开始，月从0开始（Calendar保持一致）

​			格式化 ：格式化对Date有用，但是对calendar没有用

​			前两代日期也不是线程安全，不能处理闰秒（每隔两天多出一秒）

​		LocalDate ：日期（年月日）

​		LocalTime ：时间 （时分秒）

​		LocalDateTime ： （年月日时分秒）

```
     使用now() 返回表示当前时间日期的 对象
        LocalDateTime date = LocalDateTime.now(); // 日期 + 时间
        System.out.println(date);
        System.out.println("年 :" + date.getYear());
        System.out.println("月 :" + date.getMonth()); // 英文
        System.out.println("月 :" + date.getMonthValue()); // 数值
        System.out.println("日 :" + date.getDayOfMonth());
        System.out.println("时 :" + date.getHour());
        System.out.println("分钟 :" + date.getMinute());
        System.out.println("秒 :" + date.getSecond());

        LocalDate date1 = LocalDate.now(); // 日

        LocalTime date2 = LocalTime.now(); // 时间
        
               //格式化 
               // 创建 DateTimeFormatter 对象 （静态方法 ： ofPattern("对应格式创建")）
               // 转换对应时间对象成字符串 （format 方法）
        DateTimeFormatter dateTimeFormatter = DateTimeFormatter.ofPattern("yyyy-MM-dd HH:mm:ss");
        String format = dateTimeFormatter.format(date);
        System.out.println(format);
        
        //        提供 plus 和 minus 方法来对当前时间进行加减
        LocalDateTime localDateTime = date.plusDays(890); // 增加890
        String format1 = dateTimeFormatter.format(localDateTime);
        System.out.println(format1);

        LocalDateTime localDateTime1 = date.minusMinutes(3456); // 查看3456分钟前的时间
        String format2 = dateTimeFormatter.format(localDateTime1);
        System.out.println(format2)；
```

IDEA小点 ： 在类的图标中，properties 指get，setxx方法中，认为xx是一个属性，并将其列出来

验证正确性 ： 列出正确情况，再取反获取错误情况

## 集合

​	数组缺点 ：

​		长度必须指定，并且无法进行更改

​		必须保存同一类型的数据

​		增加/删除元素较为困难

​	引入集合 ：

​		可以动态保存任意多个元素（类型可以不一致）

​		提供一系列操作元素的方法	

​		添加、删除元素代码更加简洁

### 集合的分类 

​	单例 ： Collection接口的两个重要子接口 ： set 和 List ，其实现子类都是单例集合	

​	双列 ： Map 接口的实现子类都是双列集合

​	关于集合体系图键image文件夹

```
//    单例集合(举个例子)
    ArrayList arrayList = new ArrayList();
    arrayList.add("a"); // 加单个数据的就是单例集合

//    双列集合
    HashMap hashMap = new HashMap();
    hashMap.put("Num1", "b"); // 加两个数据的就是双列集合
```



### Collection 接口实现类的特点

​	collection 实现子类可以存放多个元素，每个元素都可以是 Object 或其子类

​	有的可以存放重复元素，有的不行

​	实现子类有的是有序的（List），有的是无序的（Set）

​	没有直接实现子类，通过子接口的 List 和 Set 实现的

### Collection 常用方法

​	add() 添加单个元素 , 存在自动装箱过程

​	remove() : 删除单个元素 (两种形式 ： 删除指定索引(返回删除对象)，删除指定对象(返回true false))

​	contains() : 查找元素是否存在

​	size() : 获取元素个数

​	isEmpty() : 检查集合是否为空

​	clear() : 清空集合

​	addAll() : 添加多个元素 ，接受实现了Collection接口的类

​	containsAll() : 查找多个元素是否存在

​	removeAll() : 删除多个元素

### Collection 接口遍历元素方式

#### 	使用Iterator（迭代器） 

​		Iterator对象成为迭代器，主要用于遍历Collection集合的元素

​		任何实现了Collection接口的集合类都能获取到一个iterator()方法用于返回一个是实现了Iterator接口的对象（即一个迭代器）

​		Iterator仅用于遍历集合，本身不存放任何东西

​		迭代器的执行原理 ： 

```
通过iterator方法获取一个迭代器对象
Collection list = new ArrayList();
Iterator iterator = list.iterator(); // 获取
while(iterator.hasNext()) { 先通过hasNext()判断是否还有下一个元素
	System.out.println(iterator.next()); //  控制指针下移，返回下移后指针指向的集合元素
}
在调用迭代器的next()方法之前，必须先调用hasNext()方法进行检测，若不调用，并且下一条记录无效，直接调用next() 将会抛出NoSuchElementException

//       快速生成构造器遍历 ： itit (Ctrl + j 查看快捷键生成)

//        当执行完while循环时,next()已经指向了最后的一个元素,再次执行将会抛出错误
//        iterator.next(); // NoSuchElementException
//        因此,想要在遍历一次集合时,想要重置一遍迭代器
  iterator = list.iterator();
        while (iterator.hasNext()) {
            Object next =  iterator.next();
            System.out.println("next = " + next);
        }
```

​	

#### 	增强 for() 循环

​		就是简化版的iterator （底层仍然是迭代器） （快速生成 ： I 大写i）

### List接口和常用方法

​	是Collection接口的子接口

​	List 集合的类的元素是有序的(添加元素和取出顺序一致)，并可以重复

​	List 集合中每个元素都有对应的顺序索引(支持索引)(List 容器中每个元素都对应一个整数型序列号记载其在容器中的位置，可以根据序列号存取容器中的元素)

​	实现 List 接口的类有很多，但常用的为 ： ArrayList Vector LinkedList

​	常用方法

​	三种遍历方法

​		迭代器、增强for()、普通for

#### ArrayList 

​	细节 

​		ArrayList 可以加入多个 null

​		由数组来实现数据存储

​		基本等同于Vector，除 ArrayList 是线程不安全(没有synchronized修饰方法)(执行效率高)；多线程下不建议使用 ArrayList

​	底层结构解读：

​		ArrayList 中维护了一个 Object 类型的数组 ： elementData  transient Object[] elementData transient 表示该属性不会倍序列化

​		当创建一个 ArrayList 对象时，若使用无参构造器，则初始elementData 容量为0，进行第一次添加时，扩容为10，再次扩容时，则扩容1.5倍 

​		如果使用指定大小的构造器，则初始elementDate 的容量为指定大小，如果想要扩容，则扩容1.5倍

#### Vector 

​	底层也是一个对象数组 ： protected Object[] elementData

​	是线程同步的（线程安全），每个操作方法带有synchronized（但这样效率低），因此开发时，想要线程同步安全，考虑 Vector

​	底层结构 ：

​		无参构造器（直接调用有参构造器，赋10） 给10，满后按2倍扩容（其实可以指定每次扩容数）

​		有参构造器（单值），给指定值，满后按指定值2倍扩容

​		上面两个无参都会调用下面的双参构造器，并给最后的值赋值为0

​		双参构造器 ：一个是初始vector的存储数组长度，后面的参数就是每次扩容的空间（为0就是扩2倍）

#### LinkedList

​	底层实现了双向链表和双端队列特点

​	可以添加任意元素（可重复），null 也行

​	线程不安全，没有实现同步

​	底层操作机制

​		LinkedList 底层维护了一个双向链表；

​		维护两个属性 ： first 和 end 指向双向链表的第一个节点（首节点）和最后一个节点（尾节点）

​		每个节点都是 Node 对象，里面维护了 prev 、 next 、 item 三个属性，prev 指向前一个节点， next 指向后一个节点，最终实现了双向链表

​		LinkedList 的元素添加和删除，不通过数组完成，效率相对较高

​	ArrayList 和 LinkedList 选择

​		改查多 ： ArrayList  增删多 ： LinkedList （没有涉及线程并发的情况下，使用）

### Set 接口和常用方法

​		无序（存取顺序不一致），没有索引

​		不允许相同元素重复，最多包含一个null

​		常用方法 

​			继承与Collection，常用方法与Collection一样

​		遍历方式

​			迭代器 、 增强for()循环，不能使用索引方式获取（没有提供 get 方法）

#### 	HashSet

​		实现了 Set 接口

​		底层就是 HashMap

​		底层机制 ：HashMap， HashMap 的底层又是 ： 数组 + 链表 + 红黑树		

​		HashSet 底层添加元素实现

​			底层是 HashMap

​			添加一个元素时，会先得到 hash 值 ，hash 值将会通过转换形成索引值

​			找到存储数据的表 table ，查看该索引上是否已经存放了元素

​			如果没有，直接加入

​			如果有，调用 equals 比较（可以由程序员决定），如果相同，放弃添加，不同就添加到最后

​			JDK8 中 , 一条链表的元素个数到达 8（如果table大小未到，则直接为 table 扩容后树化），并且 table 的大小 大于等于 64，就会转换为红黑树（进行树化）（JDK17保持该特点）

因此，不能添加重复元素的根本原因在于 hash() 得到的哈希值 与 equals() 方法 两个都相同的情况下不能实现添加

```
源码解读
      7: new HashSet()
          public HashSet() {
               map = new HashMap<>();  // 底层就是 HashMap
           }
      8：add()
       public boolean add(E e) { // e : "java"
           return map.put(e, PRESENT)==null; //  static Object PRESENT = new Object()
       }

       put():
       public V put(K key, V value) {
           return putVal(hash(key), key, value, false, true);
       }
       hash(key) 会得到 key 的哈希值，但并不等价与 hashCode() ：h = key.hashCode()) ^ (h >>> 16)

       putVal() : 核心
       final V putVal(int hash, K key, V value, boolean onlyIfAbsent,
          boolean evict) {
           Node<K,V>[] tab; Node<K,V> p; int n, i; // 辅助变量
           // if 判断 table 是不是为空，或者table的大小是不是为0，整体上就是第一次扩容 (16)
           if ((tab = table) == null || (n = tab.length) == 0)
               n = (tab = resize()).length;
           // 求出 存放的 hash 值应该放入 table 的哪个索引位置，并将该位置的对象赋值给 p
           // 继续判断 p 是不是 null 看这个位置是不是空的
           空就创建一个Node对象newNode(hash(判断后面是不是相同的), key, value, null)，放入该位置
           没空就准备放链表
           if ((p = tab[i = (n - 1) & hash]) == null)
               tab[i] = newNode(hash, key, value, null);
           else {
               Node<K,V> e; K k;
               if (p.hash == hash &&
                   ((k = p.key) == key || (key != null && key.equals(k))))
                   //p.hash == hash : 如果当前索引位置上的对象的 hash 与要添加的 key 的哈希值一样
                   //(k = p.key) == key ：当前索引上的对象的 key 与 要添加 key 是同一个对象
                   //(key != null && key.equals(k)) ： 或者不是同一个对象，但是内容相同
                   // 满足，就不加入
                   e = p;
                   // 再判读 p 是不是红黑树，如果是，就调用 putTreeVal 进行添加
               else if (p instanceof TreeNode)
                   e = ((TreeNode<K,V>)p).putTreeVal(this, tab, hash, key, value);
               else {
                 // 依次与该链表中的每一个元素相比较，如果比到最后，都不同，直接加在链表最后面
                       // 添加元素到链表后，立即判断是不是该链表是否已经达到 8 个节点，
                       // 达到了就调用 treeifyBin 对当前链表进行树化
                       // 如果 table 的长度没有到达 64， 就会先对 table 进行扩容后才进行树化
                   // 如果再比较过程中，发现了相同情况，直接跳出 for 循环
                   for (int binCount = 0; ; ++binCount) {
                       if ((e = p.next) == null) {
                           p.next = newNode(hash, key, value, null);
                           if (binCount >= TREEIFY_THRESHOLD - 1) // -1 for 1st
                               treeifyBin(tab, hash);
                           break;
                       }
                       if (e.hash == hash &&
                           ((k = e.key) == key || (key != null && key.equals(k))))
                           break;
                       p = e; // 移动 p 节点
                   }
               }
               if (e != null) { // existing mapping for key
                   V oldValue = e.value;
                   if (!onlyIfAbsent || oldValue == null)
                       e.value = value;
                   afterNodeAccess(e);
                   return oldValue;
               }
           }
           ++modCount;
           if (++size > threshold) // 在第一次扩容中 resize() 方法中确定的临界值
               resize();
           afterNodeInsertion(evict); //HashMap 留给子类去实现的一个空方法
           return null;
       }

*/
```

​	HashSet 扩容机制与 转换为红黑树机制

​		第一次扩容时，将会使 table 扩容为 16；临界值为 table.length * 加载因子（0.75 loadFactor）: 12

​		当 table 数组的元素达到临界值时，会再次扩容 （*2），再次计算临界值

​		只要往HashSet 增加一个节点，不管加在数组还是链表，增加一个节点size + 1

​		单条链表元素个数到达 8 ，并且 table 大小 大于等于 64，才会进行树化，否则仍采取数组扩容机制

#### LinkedHashSet

​	HashSet 的子类 ， 不能添加重复元素

​	底层是 LinkedHashMap , 底层维护一个 数组 + 双向链表

​	LinkedHashSet 是根据元素的 HashCode 决定存放位置，同时使用链表维护元素的次序图（存放与取出是同一顺序），使其看起来是插入保存到

​	底层机制 ：

​		LinkedHashMap 中维护了一个 hash 表和双向链表（有 head 和 tail 分别指向该链表的头部和尾部）

​		每个节点都会有 before 和 after 属性，用于指向其他节点

​		在添加一个元素时，会先求出器 hash 值，再得出索引，确定该元素在 hashtable的位置，并将该元素加入双向链表，已存在就不添加（与 HashSet 一样）

​		这样使得插入的顺序与遍历的顺序一致

​		table 的类型为 : HashMap@Node[],存放的节点类型为 : LinkedHashMap@Entry(Entry 继承了 Node)(多态)

​		扩容和添加机制还是HashSet，唯一区别就是一个双向链表，一个节点可以指向上一个节点和下一个节点

#### TreeSet 

​	最大特点 ：可以排序(传入一个实现了 Comparator 接口的 匿名内部类)

```
TreeSet 底层就是 TreeMap
构造器会把传入的比较器对象传给 TreeMap (TreeSet的底层) 的 comparator 属性
 public TreeSet(Comparator<? super E> comparator) {
     this(new TreeMap<>(comparator));
 }
    public TreeMap(Comparator<? super K> comparator) {
     this.comparator = comparator;
 }

 private V put(K key, V value, boolean replaceOld) {
     Entry<K,V> t = root;
     if (t == null) {
         addEntryToEmptyMap(key, value);
         return null;
     }
     int cmp;
     Entry<K,V> parent;
     // split comparator and comparable paths
     Comparator<? super K> cpr = comparator; // 传入 构造器的匿名内部类的对象
     if (cpr != null) { // 如果没有传入 比较器，将会执行下面的else
         do {
         	// 遍历所有 key ，为当前添加的 key 寻找适当的位置
             parent = t;
             // 动态绑定，直接调用构造器传入的匿名内部类的 compare 方法
             cmp = cpr.compare(key, t.key);
             if (cmp < 0)
                 t = t.left;
             else if (cmp > 0)
                 t = t.right;
             else { // 发现 相等，就返回，不添加
                 V oldValue = t.value;
                 if (replaceOld || oldValue == null) {
                     t.value = value;
                 }
                 return oldValue;
             }
         } while (t != null);
     } else { 
         Objects.requireNonNull(key);
         @SuppressWarnings("unchecked")
         Comparable<? super K> k = (Comparable<? super K>) key; // 使用 key（实现了Comparable 这个接口） 的 比较方法
         do { 
             parent = t;
             cmp = k.compareTo(t.key);
             if (cmp < 0)
                 t = t.left;
             else if (cmp > 0)
                 t = t.right;
             else { // 如果通过比较器比较后两个对象相同(就是比较规则为0,则不会添加这次的元素)
                 V oldValue = t.value;
                 if (replaceOld || oldValue == null) {
                     t.value = value;
                 }
                 return oldValue;
             }
         } while (t != null);
     }
     addEntry(key, value, parent, cmp < 0);
     return null;
 }
```

### Map 接口

​	JDK8 的 Map 特点

​	用于保存具有映射关系的数据 ：key - value (双列元素)(Set 其实也是这样的，value 指常量对象 PRESENT)

​	key 和 value 可以是任意引用类型的对象，会被封装到 HashMap$Node 中(即 Node 对象的 key属性 和 value属性)

​	key 不能被重复，原因与 HashSet 一样，但采用替换机制;

​	value 可以重复

​	key 和 value 都可以为 null，但是 key 只能有一个 null， value 可以多个

​	常用 String 作 key

​	key 与 value 存在单向一对一的关系，通过 key 可以找到对应的 value

```
//        k - v 最后就是存放在 HashMap$Node (node = newNode(hash,key,value,null))
//        k - v 为了程序员的遍历方便，还会创建一个 EntrySet 集合，
//        该集合类型存放的元素类型为 Entry (即实现了Entry 接口类的实例对象)，
//        EntrySet<Entry<k,v>> 即： transient Set<Map.Entry<K,V>> entrySet;
//        entrySet 中，定义的类型就是 Map.Entry,但实际上存放的还是 HashMap$Node
//        因为 HashMap$Node 实现了 Map.Entry
//        当把 HashMap$Node 存放进 EntrySet 时是方便了遍历(Entry 提供了两个方法一次就可以拿到 k 和 v)
//        Entry 中提供了K getKey(); V getValue();两个方法
//        为什么要 EntrySet 这个集合 ： 将底层分散的Node（或其他Entry实现）包装成一个符合集合规范的视图(引用方式)
//        让Map的遍历既能统一、安全，又能屏蔽底层实现细节，这正是 Java 面向接口编程思想的典型体现

//        HashMap中创建的Node节点本身就是Entry接口的实现，因此天然可被视为Entry对象；EntrySet作为视图，
//        通过遍历底层Node并以Entry类型引用它们，实现了对键值对的统一访问，而非主动 “转换” 或 “存放”Entry。

//        keySet()和values()和entrySet()一样，都是视图机制，目的是 “以不同形式访问已有数据，不额外拷贝存储”，
//        keySet() 访问所有的 key; values() 访问所有的value entrySet()则访问所有的 key - value
```

#### 	方法

​		put() : 添加元素

​		remove() : 删除 , 指定 key 或 key 和 value 删除

​		get() : 根据指定的 Key 返回对应的 value

​		set() : 获取当前的元素个数

​		isEmpty() : 判断个数是否为0

​		clear() : 清空所有的键值对

​		containsKey() : 查找键是否存在

​		replace(k,v) : 用新的 value 将指定的 key 对应的 value 替换，如果没有找到 key 将不进行操作

#### 	遍历方式

​		三种遍历方式 : (都可以使用增强 for 循环 和 迭代器)

​			通过 keySet() 获取所有 key, 再通过 get() 方法获取 value

​			通过 Values 获取所有的 value,但是无法获取到 key

​			通过 entrySet() 获取所有的 key - value,这时可以使用 getKey() 和 getValue() 获取 Key 和 Value 或者使用迭代器

#### 	小结	

​		常用实现类 ： HashMap（使用率最高实现类） 、 Hashtable 、properties

​		HashMap 是以 key - value 对的方式来存储数据 （HashMap$Node）

​		key 不能重复，但 value 可以重复， null 可以作 key 或 value

​		添加相同的 key 时， 会覆盖原有的 key - value ，等同于修改 value

​		与 HashSet 一样， HashMap 不保证映射顺序，底层通过 hash 表存储

​		HashMap 没有实现线程同步，因此是线程不安全的

#### HashMap

​	底层机制 

​		jdk7 前为数组 + 链表

​		扩容机制 与 HashSet 完全一样		

```
1.执行构造器 new HashMap()；
    初始化加载因子 ： loadFactor = 0.75
    HashMap$Node[] table = null;
2.执行put() 方法
public V put(K key, V value) {
    return putVal(hash(key), key, value, false, true);
}
3.执行putVal方法
    final V putVal(int hash, K key, V value, boolean onlyIfAbsent,
       boolean evict) {
    Node<K,V>[] tab; Node<K,V> p; int n, i;
    if ((tab = table) == null || (n = tab.length) == 0)
        n = (tab = resize()).length;
    if ((p = tab[i = (n - 1) & hash]) == null)
        tab[i] = newNode(hash, key, value, null);
    else {
        Node<K,V> e; K k;
    // 如果新增的 Node 对象的 hash值与当前 table 表索引位置的 Node 对象的hash 值相等
    // 并且 新增的 Node 对象与当前对象是同一个对象 或者 他们的equals 是相等的
        if (p.hash == hash &&
            ((k = p.key) == key || (key != null && key.equals(k))))
            e = p;
        else if (p instanceof TreeNode) // 判断当前 table 表索引位置的 Node 对象是不是红黑树
          // 按照红黑树的逻辑处理新增的 Node
            e = ((TreeNode<K,V>)p).putTreeVal(this, tab, hash, key, value);
        else { // 如果节点的后面是链表，就进行循环比较
            for (int binCount = 0; ; ++binCount) {
                if ((e = p.next) == null) { // 链表中没有与新增的 Node对象相同，将其加在最后
                    p.next = newNode(hash, key, value, null);
                    // 判断链表树是不是达到8，达到就调用方法进行树化
                    if (binCount >= TREEIFY_THRESHOLD - 1) // -1 for 1st
                    // 不会立即树化，要求链表 达到8，并且table长度达64，如果没有，则进行扩容
                    //否则才会进行树化
                        treeifyBin(tab, hash);
                    break;
                }
                // 发现链表中有相同的，就退出循环不做处理，再进行替换处理
                if (e.hash == hash &&
                    ((k = e.key) == key || (key != null && key.equals(k))))
                    break;
                p = e;
            }
        }
        if (e != null) { // existing mapping for key
            V oldValue = e.value;
            if (!onlyIfAbsent || oldValue == null)
                e.value = value; // 对原来的 value 进行替换
            afterNodeAccess(e);
            return oldValue;
        }
    }
    ++modCount;
    if (++size > threshold)
        resize();
    afterNodeInsertion(evict);
    return null;
}
```

#### Hashtable

​	存放数据的形式 ： k - v 

​	键值都不能为 null ，否则抛出 NullPointerException

​	使用方法基本上和 HashMap 一样	

​	Hashtable 是线程安全的（synchronized），而 HashMap 是不安全的

```
底层分析 ：
    1.底层数组为 ： Hashtable$Entry[] ,初始化为 11  加载因子还是 ： 0.75 临界值算法一样
    2. 键值对 是存放在 Hashtable$Entry 中，注意区分与 Map.Entry 的区别
        private static class Entry<K,V> implements Map.Entry<K,V>
    3.扩容 ： 原大小 * 2 + 1

     public Hashtable() {
        this(11, 0.75f); (数组大小，加载因子)
    }

    public synchronized V put(K key, V value) {
        // Make sure the value is not null
        if (value == null) {
            throw new NullPointerException();
        }

        // Makes sure the key is not already in the hashtable.
        Entry<?,?> tab[] = table;
        int hash = key.hashCode();
        int index = (hash & 0x7FFFFFFF) % tab.length;
        @SuppressWarnings("unchecked")
        Entry<K,V> entry = (Entry<K,V>)tab[index];
        // 看当前 table 上指定索引位置是不是空的 ，是就加上去
        for(; entry != null ; entry = entry.next) {
            if ((entry.hash == hash) && entry.key.equals(key)) {
                V old = entry.value;
                entry.value = value;
                return old;
            }
        }

        addEntry(hash, key, value, index);
        return null;
    }

     private void addEntry(int hash, K key, V value, int index) {
        Entry<?,?> tab[] = table;
        if (count >= threshold) { // 判断达到临界值了没
            // Rehash the table if the threshold is exceeded
            rehash();

            tab = table;
            hash = key.hashCode();
            index = (hash & 0x7FFFFFFF) % tab.length;
        }

        // Creates the new entry.
        @SuppressWarnings("unchecked")
        Entry<K,V> e = (Entry<K,V>) tab[index];
        // 将增加的键值对加上table表，并让其 next 指向原来在该索引上的键值对(原来没有就指空)
        // 插头法，插在头部，不插在尾部
        tab[index] = new Entry<>(hash, key, value, e);
        count++; // table表中的元素数量
        modCount++; // 修改次数
    }

    protected void rehash() {
        int oldCapacity = table.length;
        Entry<?,?>[] oldMap = table;

        // overflow-conscious code
        int newCapacity = (oldCapacity << 1) + 1; // 这就是扩容
        if (newCapacity - MAX_ARRAY_SIZE > 0) {
            if (oldCapacity == MAX_ARRAY_SIZE)
                // Keep running with MAX_ARRAY_SIZE buckets
                return;
            newCapacity = MAX_ARRAY_SIZE;
        }
        Entry<?,?>[] newMap = new Entry<?,?>[newCapacity];

        modCount++;
        threshold = (int)Math.min(newCapacity * loadFactor, MAX_ARRAY_SIZE + 1);
        table = newMap; // 替换原数组 (清空了table)
        // 将原内容加入 table
        for (int i = oldCapacity ; i-- > 0 ;) {
            for (Entry<K,V> old = (Entry<K,V>)oldMap[i] ; old != null ; ) {
                Entry<K,V> e = old;
                old = old.next;

                int index = (e.hash & 0x7FFFFFFF) % newCapacity;
                e.next = (Entry<K,V>)newMap[index];
                newMap[index] = e;
            }
        }
    }
```

#### Properties

​	继承于 Hashtable 类并实现了 Map 接口，也采用 k - v 形式保存数据（但要存放字符串！） ，并都不能为空 

​	使用特点与 Hashtable 类似

​	更多用于从 xxx.properties 文件中，加载数据到 Properties 类对象，并进行读取与修改

​		xxx.properties 文件通常是配置文件 

​	 getProperty（） ：用于获取配置文件中指定键（key）对应的字符串值（value） 的核心方法

#### TreeMap

​	整体情况与 TreeSet 一致（底层就是 TreeMap 实现），源码情况一致

### 集合实现类的选择

​	先判断存储类型 ： 一组对象（单列） 还是 一组键值对（双列）

​		一组对象 ： Collection （是否允许重复）

​			重复 ： List

​					增删多 ： LinkedList （双向列表）

​					查找多 ：ArrayList （Object 的可变数组）

​			不重复 ： Set

​					无序 ： HashSet （HashMap，数组 + 链表 + 红黑树）

​					排序 ：TreeSet

​					插入与取出顺序一致 ： LinkedHashSet  （数组+ 双向列表）

​		一组键值对 ： Map

​			键无序 ：HashMap （哈希表， jdk7 ： 数组 + 链表；jdk8：数组 + 链表+ 红黑树）

​			键排序 ： TreeMap

​			键插入与取出顺序一致  LinkedHashMap

​			读取文件 ： Properties

### Collections 工具类

​	操作 List 、Set 和Map 等集合的工具类

​	提供了一系列的静态方法为集合元素进行排序、查询和修改等操作

​	方法

reverse() :反转集合中元素的顺序

shuffle() : 对集合元素进行随机排序

sort(List,Comparator) : 根据指定的 Comparator 对 List 进行排序

swap(List,int,int) : 将 List 集合中的索引 i ，j 上位置的元素进行交换，不能超过范围

max(Collection) : 返回根据自然顺序进行排序后，集合中最大的元素

max(Collection,Comparator) : 返回根据指定排序方式进行排序后，集合中最大的元素

min(Collection) : 返回根据自然顺序进行排序后，集合中最小的元素

min(Collection,Comparator) : 返回根据指定排序方式进行排序后，集合中最小的元素

frequency(Collection,Object) : 返回指定集合中，指定元素出现的次数

copy(List dest,List src) : 将 src 中的内容复制到 dest 中 ,要求 dest 中size 必须 >= src的size

boolean replaceAll(List list,Object oldVal,Object newVal) ： 将指定集合中的指定元素替换为新元素

```
HashMap 的 remove
final Node<K,V> removeNode(int hash, Object key, Object value,
                               boolean matchValue, boolean movable) {
        Node<K,V>[] tab; Node<K,V> p; int n, index;
        // table不能空，长度大于0， hash转的索引上的位置不能空
        if ((tab = table) != null && (n = tab.length) > 0 &&
            (p = tab[index = (n - 1) & hash]) != null) {
            Node<K,V> node = null, e; K k; V v;
//            判断是不是要删除的元素(hash,key,以及是不是相等的)
            if (p.hash == hash &&
                ((k = p.key) == key || (key != null && key.equals(k))))
                node = p; // 记录这个删除的元素
            else if ((e = p.next) != null) { //找链表下面的
                if (p instanceof TreeNode) // 看链表上是不是树
                    node = ((TreeNode<K,V>)p).getTreeNode(hash, key);
                else {
                    do { // 循环对比
                        if (e.hash == hash &&
                            ((k = e.key) == key ||
                             (key != null && key.equals(k)))) {
                            node = e;
                            break;
                        }
                        p = e;
                    } while ((e = e.next) != null);
                }
            }
            //看是不是记录了要删除的对象
            if (node != null && (!matchValue || (v = node.value) == value ||
                                 (value != null && value.equals(v)))) {
                //判断是不是树
                if (node instanceof TreeNode)
                    ((TreeNode<K,V>)node).removeTreeNode(this, tab, movable);
                else if (node == p) // 删除的位置是表头，
                    tab[index] = node.next; // 换成链表的下一个节点
                else
                    p.next = node.next;
                ++modCount;
                --size;
                afterNodeRemoval(node);
                return node;
            }
        }
        return null;
    }
```



## 泛型

​	传统上，无法对加入到集合 ArrayList 中的数据类型进行约束（不安全）

​	遍历时，需要进行类型转换，如果集合中的数据量较大，对效率有影响

泛型就提供了 ： 编译时，检查添加元素的类型，提高了安全性； 减少了类型转换的次数；不在提示编译警告

​	泛型就是表示一种数据类型（具体由程序员选择） 的数据类型

​	泛型又称参数化类型，jdk5 出现，解决数据类型安全性的问题

​	泛型的作用是 ：在类声明时，通过一个标识表示类中的某个属性的类型 ,或者某个方法的返回值或参数类型 (具体的数据类型会在该属性的数据类型在定义对象时指定 即编译期间确定)

声明 

​	interface 接口 <T> {}  class 类名 <K,V>{}

​	K、V、T 表示数据类型，任何字母都可以，常用 T 表示

实例化 

​	在类名后指定类型参数的值

使用细节

​	T 、E 只能是引用类型

​	在给泛型指定具体类型后，可以传入该类型或者该类型的子类类型

​	泛型使用形式

​		传统 ：ArrayList<Integer> integers1 = new ArrayList<Integer>();

​		简化 ：ArrayList<Integer> integers2 = new ArrayList<>(); 常用，编译器会进行类型推断，默认是右侧的 Integer

​		 如果要求你传入一个泛型时，如果没有传入泛型，将会默认看成 Object

自定义泛型类 

​	就自己写了一个类，然后在后面定义了一些泛型

​	语法 ：

​		class 类 <T ,R...> {}

​	细节 

​		普通成员可以使用泛型

​		使用泛型的数组不能进行初始化   因为泛型表示符只能在创建对象时才能得到确定，编译器都不知道表示符是啥类型，要开辟多少空间

​		静态方法中不能使用类的泛型  静态方法是和类相关的，但泛型只会在创建对象的时候得到确定，静态成员都不知道是啥，JVM 也不知道怎么初始化

​		泛型类的类型，在创建对象时确定（创建对象时，要指定泛型类型）

​		如果创建对象时，没有指定类型，默认 Object

自定义泛型接口

​	语法

​		interface 接口 <T,R...> {}

​	细节

​		接口中，静态成员也不能使用泛型

​		泛型接口的类型，在继承接口或者实现接口时被确定

​		没有指定类型，则默认为 Object

自定义泛型方法

​	语法 

​		修饰符 <T,R...> 返回类型 方法名（参数列表） {}

​	细节

​		泛型方法，可以定义在普通类中，也可以定义在泛型类中	

​		泛型方法可以是静态方法

​		当泛型方法被调用时，类型会被确定  当调用方法时，编译器会根据参数类型 自动判断泛型标识符的类型

​		像 public void f(E e)  这种方法，修饰符后没有<T,R...> ，并不是泛型方法，而是使用了泛型

​		泛型方法可以使用类声明的泛型，也可以使用自己声明的泛型

泛型的继承与通配符

​	泛型不具备继承性 : List<Object> list = new ArrayList<String>();

​	通配符 ：

​		<?> : 接受任意类型的泛型

​		<? extends AAA> : 表示上限 接受 AAA 或AAA的子类

​		<? super CCC> : 表下限，接受 CCC 或 CCC的父类，不限于直接父类



JUnit

​	java 语言的单元测试框架

​	如何使用 ： 在想要测试的方法上一行增加 @Test ，然后鼠标悬停 alt + enter 使用 JUnit 5 等待加载完毕，

java绘图坐标体系

​	圆点在左上角，水平x ，垂直y ，单位像素， （x，y）

java绘图入门

​	原理 ：

​	Component类提供了两个和绘图相关的重要方法

​		paint(Graphics g) ：绘制组件外观

​		repaint() ：刷新组件外观

​	当组件第一次在屏幕显示的时候，程序会自动的调用 paint 方法来绘制组件

​	以下情况 paint 将会被调用 ：

​		窗口最小化后再最大化

​		窗口的大小发生改变

​		repaint 方法被调用

```
1. 先定义一个面板类，使其继承于 JPanel，后续画图将在这个面板进行
2. 重写 paint 方法，先调用 父类的 paint 方法，再进行绘制 重写方法参数 ：Graphics g
3. public 类继承 JFrame(对应窗口，就是一个画框)
4. 定义一个画板类属性
5. 实现一个无参构造器 ： 初始化一个画板，
6. this.add(画板对象) ： 将画板加入窗口
7. this.setSize(width,height) : 指定窗口大小
8. this.setVisible(true) : 使窗口可以显示
9. this.setDefaultCloseOperation(JFrame.EXIT_ON_CLOSE); ： 使点击关闭按钮实现程序完全退出
10. 在main 方法中创建一个public 类实例对象
```

Graphics 类	

```
   画园
//        g.drawOval(40, 40, 100, 100);

//        画直线
//        g.drawLine(25,25,50,50); // 各确定两个点连线

//        矩形边框
//        g.drawRect(25,25,100,100); // 确定一个点，后面为宽高

//        填充矩形
//        g.setColor(Color.blue);
//        g.fillRect(25,25,100,100);

//        填充椭圆
//        g.setColor(Color.red);
//        g.fillOval(25,25,100,100);

//        画图片 1.获取图片资源
//        图片必须放在 out 文件夹的 chapter15 即当前项目文件下
//        MyPanel.class.getResource("/5.png") MyPanel指你继承了 JPanel 类的 画板类，别乱来
//        Image image = Toolkit.getDefaultToolkit().getImage(MyPanel.class.getResource("/5.png"));
//        g.drawImage(image,25,25,244,155,this); // 宽高与图片一致，否则会变形

//        画字符串 ： 先给画笔设置颜色和字体
//        g.setColor(Color.red);
//        g.setFont(new Font("宋体", Font.BOLD, 20));
//        g.drawString("北京你好",100,100); // 对应左下角坐标

//        设置画笔颜色 setColor()
//        设置画笔字体 setFont(Font font)
```

通过键盘来控制图像 ：

​	使画笔类实现一个接口 ：KeyListener  （一个监听器，监听键盘事件） （alt + enter 快速实现方法重写）

```
// 有字符输出时，该方法将会触发
    @Override
    public void keyTyped(KeyEvent e) {

    }

//    当某个键按下时，该方法会触发
    @Override
    public void keyPressed(KeyEvent e) {

    }

//    当某个键按下后释放了，该方法将会触发
    @Override
    public void keyReleased(KeyEvent e) {
		//        System.out.println((char)e.getKeyCode() + "被按了");
        //        System.out.println(e.getKeyChar()); // 小写
        //        根据用户按下不同的键，来处理小球的移动
                switch (e.getKeyChar()) {
                    case 'w' :  y -= 10; break;
                    case 's' :  y += 10; break;
                    case 'a' :  x -= 10; break;
                    case 'd' :  x += 10; break;

                }
        //        还需要重绘一次画板
                this.repaint();
    }
```

但是要注意的时，添加后还需要再main类的构造器中增加一个  addKeyListener(panel)， 里面参数就是 ： KeyListener 实现类对象

Java事件处理机制

​	采取 “ 委派事件模型” 。当事件发生时，产生事件的对象，会把此 “信息” 传递给 “事件的监听者” 处理，这里的 信息 就是指 java.awt.event 事件类库里某个类所创建的对象，并将它称为 “事件的对象” 

​	事件源 ： 一个产生事件的对象

​	事件 ： 承载事件源状态改变时的对象



## 线程（基础）

​	进程是指运行中的程序，是程序的一次执行过程或者正在运行的一个程序，是动态的过程，有本身的产生，存在与消亡的过程

​	线程由进程创建，是进程的一个实体，线程也可以通过另一个线程创建

​	一个进程可以拥有多个线程

​	单线程 ：同一时刻，只允许执行一个线程

​	多线程 ： 同一时刻，可以执行多个线程

​	并发 ： 同一时刻，多个线程（）交替执行  单核CPU 执行多个任务就是并发

​	并行 ： 同一时刻，多个线程（任务）同时执行 多核 CPU 执行多个任务就是 并行

​	并发与并行可以同时存在

基本使用

​	实现方式

​		继承 Thread 类，重写 run 方法

​		实现 Runnable 接口， 重写 run 方法

​	继承 Thread 类

​		当一个类继承了 Thread 类 ，该类就可以当作线程类来使用

​		重写 run 方法，写上自己的业务逻辑， run 方法是 Thread 实现了 Runnable 接口的 run 方法

​		当一个程序开始执行时，会将 main 方法作为一个线程（main 线程）执行，main方法中调用 start 方法将会开辟出一个新的线程

​		当 main 线程使用 start 启动一个子线程时,main 线程并不会等待子线程执行完毕才执行,会继续执行, 当主线程一旦结束，如果还有子线程还在执行，则整个程序并不会停止，而是直到子线程结束（当线程全部执行完毕后，进程才会结束）

​		当主线程与子线程一起执行时，根据CPU数量来决定是并发还是并行

​		一个子线程可以继续开辟另一个子线程

​	实现 Runnable 接口

​		当一个类继承了其他类时，此时由于 java 单继承的机制，无法继承 Thread 类，此时可以通过实现 Runnable 接口

​		由于 Runnable 接口中只有一个 run 方法，因此无法直接调用 start 方法进行实现开辟一个子线程

​		此时想要通过有参构造器（接受一个实现了 Runnable 接口的类的对象）来创建一个 Thread 对象，并通过这个 Thread 对象来调用 start 方法

​		这种创建子线程方式是一种设计模式 ： 代理模式，分静态代理和动态代理，这里就是静态代理

Thread 与 Runnable 的区别

​	设计角度上，没有区别，本质还是调用 start() 方法来调用 start0 本地方法

​	但是实现 Runable接口 方式更加适合多线程共享一个资源的情况，并且避免了单继承的限制 建议使用 Runnable

线程终止

​	线程完成任务后，会自动退出

​	通过使用变量来控制run方法退出来停止线程，即通知方式

线程方法

​	setName : 设置线程名称 为参数

​	getName：返回该线程的名称

​	start ： 使线程开始执行，Java 虚拟机底层调用 start0 方法

​	run ： 调用线程对象的 run 方法

​	setPriority ： 更改线程优先级

​	getPriority ： 获取线程优先级

​	sleep ： 在指定毫秒数内让当前正在执行的线程休眠，暂停执行，静态方法

​	interrupt ： 中断线程，并不会真正结束线程，一般用于中断正在休眠的线程，将正在休眠的线程唤醒

​	细节

​		start 底层会创建一个线程，在调用 run 方法 ，而 run 方法就是一个普通方法，无法创建线程

​		线程优先级范围 ： 10（MAX_PRIORITY）， 5（NORM_PRIORITY）， 1（MIN_PRIORITY）

​	yield ： 线程的礼让，退出CPU，让其他线程来被执行，但礼让时间不一定，因此不一定礼让成功（如果 CPU 资源并不紧急，CPU 会认为我忙的过来，不需要你礼让，我安排就行；如果资源非常紧张，礼让成功几率更大） 静态方法

​	join ： 线程的插队，如果线程插队执行成功，则CPU 一定会先执行完插队线程的所有任务

用户线程 ：也称工作线程，当线程的任务执行完毕或者被通知方式结束的线程称为用户线程

守护线程 ： 一般为工作线程服务，当所有的用户线程全部执行完毕，守护线程将自动结束 （常见守护线程为垃圾回收机制）

将线程设置为守护线程  ：setDaemon(true)；要在线程启动之前设置为守护线程，否则抛出异常

线程生命周期

​	文档提供 6 种状态 ：new、runnable、blockable、waiting、timed_waiting、terminated

​	但是 runnable 可以细分为 ready 、running

线程同步机制

​	在多线程编程中，有一些敏感的数据不允许被多个线程同时访问，此时就使用同步访问技术，保证数据在任何同一时刻，最多有一个线程访问，以保证数据的完整性

​	就是当一个线程在对内存进行操作时，其他线程无法对该内存地址进行操作，唯有等到该线程操作完毕后，其他线程才能对该内存地址进行操作

同步具体方法

​	synchronized 修饰代码块

​	synchronized 修饰方法	

互斥锁 

​	Java 语言中引入互斥锁的概念，来保证共享数据操作的完整性	

​	每个对象都对应与一个可称为 “”	

​		
